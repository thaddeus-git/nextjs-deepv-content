---
title: "Understanding the 'M=' Option in Linux Kernel Makefiles"
slug: "understanding-m-option-linux-kernel-makefiles"
category: "system-devops"
subcategory: "linux"
description: "Demystify the 'M=' option in make commands for Linux kernel modules, explaining how it directs the kernel build system to your module's source directory."
tags: ["linux","makefile","linux-kernel","linux-device-driver","make"]
difficulty: "intermediate"
readTime: 7
lastUpdated: "2025-09-22T16:16:54.226Z"
featured: false
---

# Understanding the 'M=' Option in Linux Kernel Makefiles

When building out-of-tree Linux kernel modules, you often encounter a `make` command that looks something like this:

```bash
make -C ~/kernel-2.6 M=`pwd` modules
```

The `M=` part of this command can be confusing. It's not a standard `make` option but a variable assignment specifically used by the Linux kernel's build system to locate your module's source code.

## Quick Answer

The `M=` in `make -C <kernel_src_dir> M=<module_src_dir> modules` is a variable assignment that tells the kernel's top-level Makefile where your external module's source directory is located. The kernel build system then uses this path to compile your module, effectively "moving back" to your module's directory to find its source files.

## Concept Explanation

Let's break down the command `make -C ~/kernel-2.6 M=`pwd` modules`:

1.  **`make`**: The GNU Make utility, which executes commands defined in a Makefile.
2.  **`-C ~/kernel-2.6`**: This is a standard `make` option. It instructs `make` to change its current working directory to `~/kernel-2.6` *before* reading any Makefiles or performing any other actions. This directory is typically the root of your Linux kernel source tree.
3.  **`M=`pwd``**: This is the crucial part.
    *   `` `pwd` ``: This is a shell command substitution. The `pwd` command prints the current working directory. The backticks cause the shell to execute `pwd` and substitute its output (e.g., `/home/user/my_module`) directly into the `make` command line.
    *   **`M=<path>`**: This assigns the value of your current working directory (where your module's source code resides) to a `make` variable named `M`. This variable is *not* a standard `make` option; it's a convention specifically recognized and used by the Linux kernel's build system.
4.  **`modules`**: This is the target that `make` is instructed to build. In the context of the kernel's Makefile, the `modules` target is responsible for compiling external kernel modules.

So, in essence, you are telling the `make` utility:
"Go to the kernel source directory (`~/kernel-2.6`), and when you build the `modules` target, know that the source code for the external module is located at the path I'm providing via the `M` variable."

The kernel's Makefile (specifically, the `kbuild` system) then uses the `M` variable to set up its build environment, including `VPATH` (search path for prerequisites) and `KBUILD_EXTMOD`, to correctly find and compile your module's source files.

![Kernel Module Build Flow](PLACEHOLDER: Kernel Module Build Flow - /images/79e3daa8-1.webp)

## How the Kernel Makefile Uses `M`

The kernel's top-level Makefile contains logic to interpret the `M` variable. Here's a simplified look at relevant snippets often found in kernel Makefiles:

```makefile
# Use make M=dir to specify directory of external module to build
# Old syntax make ... SUBDIRS=$PWD is still supported
# Setting the environment variable KBUILD_EXTMOD takes precedence

ifdef SUBDIRS
  KBUILD_EXTMOD ?= $(SUBDIRS)
endif

ifeq ("$(origin M)", "command line")
  KBUILD_EXTMOD := $(M)
endif

# ... later in the Makefile ...
VPATH       := $(srctree)$(if $(KBUILD_EXTMOD),:$(KBUILD_EXTMOD))
module-dirs := $(addprefix _module_,$(KBUILD_EXTMOD))
```

*   The `ifeq ("$(origin M)", "command line")` block checks if `M` was passed as a variable on the command line. If it was, its value is assigned to `KBUILD_EXTMOD`.
*   `KBUILD_EXTMOD` then becomes the variable that holds the path to your external module.
*   This `KBUILD_EXTMOD` variable is used to modify `VPATH` (which tells `make` where to look for source files) and to define `module-dirs`, ensuring that the kernel build system can locate and compile your module's source files from your specified directory.

## Working Code Examples

### 1. Building an External Module Against a Specific Kernel Source

This is the most common scenario for developing kernel modules.

```bash
# Assume your module's source files (e.g., my_module.c, Makefile) are in the current directory.
# Assume kernel source is in /usr/src/linux-headers-$(uname -r)
# Or a custom kernel source path like ~/kernel-5.15

# Navigate to your module's directory
cd /path/to/your/module/source

# Build against the currently running kernel's headers
make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

# Or build against a specific kernel source tree
make -C ~/kernel-5.15 M=$(PWD) modules
```

In this example:
*   `$(shell uname -r)` expands to the release string of your current kernel (e.g., `5.15.0-76-generic`).
*   `/lib/modules/$(shell uname -r)/build` is a symbolic link to the build directory of your currently installed kernel headers.
*   `M=$(PWD)` passes your current directory (where your module's source is) to the kernel build system.

### 2. Example Module Makefile (`Makefile` in your module's directory)

For the kernel build system to compile your module, you need a simple `Makefile` in your module's source directory.

```makefile
# Makefile for an external kernel module

obj-m := my_module.o

# If your module has multiple source files, list them like this:
# my_module-objs := file1.o file2.o
# obj-m := my_module.o

# KERNELRELEASE is defined in the top-level Makefile
# KDIR is the path to the kernel source tree, passed by the -C option
# PWD is the current directory of this Makefile

all:
	$(MAKE) -C $(KDIR) M=$(PWD) modules

clean:
	$(MAKE) -C $(KDIR) M=$(PWD) clean
```

This `Makefile` is minimal because the heavy lifting is done by the kernel's main build system. It simply tells the kernel build system which object files (`.o`) make up your module (`obj-m`).

## Common Problems & Solutions

### Problem: `make: *** No rule to make target 'modules'. Stop.`
**Cause**: This usually means `make` couldn't find the kernel's Makefile or the `modules` target within it.
**Solution**: Double-check the path provided to the `-C` option. It must point to a valid kernel source or build directory (e.g., `/lib/modules/$(uname -r)/build` or your custom kernel source tree).

### Problem: `make: *** /lib/modules/5.15.0-76-generic/build: No such file or directory. Stop.`
**Cause**: The kernel headers for your running kernel are not installed.
**Solution**: Install the kernel headers for your specific kernel version.
*   **Debian/Ubuntu**: `sudo apt install linux-headers-$(uname -r)`
*   **Fedora/RHEL**: `sudo dnf install kernel-devel`

### Problem: `M=`pwd` doesn't work, but M=$(PWD) does.`
**Cause**: The backticks `` `pwd` `` are a shell feature for command substitution. `$(PWD)` is a `make` built-in variable that expands to the current working directory. While both often yield the same result, `$(PWD)` is generally more robust and idiomatic within Makefiles or when `make` is invoked in certain environments.
**Solution**: Prefer `M=$(PWD)` for consistency and reliability, especially within Makefiles. When invoking `make` directly from the shell, `` `pwd` `` is also perfectly valid.

## Summary

The `M=` option is a critical component for building out-of-tree Linux kernel modules. It acts as a bridge, allowing the powerful kernel build system to locate and compile your module's source code from its separate directory. By understanding its role in conjunction with the `-C` option, you can effectively manage and build your custom kernel modules.

---

## Image Generation Prompts

**PLACEHOLDER-1:** A flowchart illustrating the kernel module build process using `make -C ... M=...`.
**Nodes:**
1.  **Start:** User executes `make -C <kernel_src> M=<module_src> modules` from module directory.
2.  **Step 1: `make -C <kernel_src>`**: `make` changes directory to `<kernel_src>`.
3.  **Step 2: Read Kernel Makefile**: `make` reads the main kernel Makefile in `<kernel_src>`.
4.  **Step 3: `M=<module_src>` Variable Assignment**: Kernel Makefile detects `M` variable, assigns `<module_src>` to `KBUILD_EXTMOD`.
5.  **Step 4: Configure Build Paths**: Kernel Makefile uses `KBUILD_EXTMOD` to set `VPATH` and `module-dirs` to include `<module_src>`.
6.  **Step 5: Build `modules` Target**: Kernel Makefile proceeds to build the `modules` target.
7.  **Step 6: Compile Module**: `make` finds module source files (e.g., `my_module.c`) in `<module_src>` (via `VPATH`) and compiles them.
8.  **End:** Module (`my_module.ko`) is generated in `<module_src>`.
**Arrows:** Connect nodes sequentially.
**Visual Style:** Clean, modern flowchart with distinct colors for nodes and arrows. Use icons for `make` (gear), kernel (penguin), module (code block).