---
title: "Calculate Linear Acceleration in Android using Accelerometer"
slug: "calculate-linear-acceleration-android-accelerometer"
category: "mobile"
subcategory: "android"
description: "Learn how to calculate linear acceleration from raw accelerometer data in Android using a low-pass filter to remove gravity."
tags: ["android","sensors","accelerometer","linear-acceleration","sensor-fusion","java"]
difficulty: "intermediate"
readTime: 7
lastUpdated: "2025-09-22T16:16:54.246Z"
featured: false
---

# Calculate Linear Acceleration in Android using Accelerometer

## Quick Answer

To calculate linear acceleration from an Android accelerometer, you typically use a low-pass filter to isolate and remove the gravity component from the raw sensor readings. This involves maintaining a smoothed estimate of gravity and subtracting it from the current accelerometer values.

```java
// Initialize these globally or as class members
private float[] gravity = new float[3];
private float[] linear_acceleration = new float[3];
final float alpha = 0.8f; // Low-pass filter constant

@Override
public void onSensorChanged(SensorEvent event) {
    // Isolate the force of gravity with the low-pass filter.
    gravity[0] = alpha * gravity[0] + (1 - alpha) * event.values[0];
    gravity[1] = alpha * gravity[1] + (1 - alpha) * event.values[1];
    gravity[2] = alpha * gravity[2] + (1 - alpha) * event.values[2];

    // Remove the gravity contribution with the high-pass filter.
    linear_acceleration[0] = event.values[0] - gravity[0];
    linear_acceleration[1] = event.values[1] - gravity[1];
    linear_acceleration[2] = event.values[2] - gravity[2];

    // linear_acceleration now contains the device's linear acceleration
}
```

## Table of Contents
- Quick Answer
- Understanding the Problem
- The Low-Pass Filter Approach
- Implementing the Solution
- Common Problems & Solutions
- Real-World Use Cases
- Summary

## Understanding the Problem

Android's `TYPE_ACCELEROMETER` sensor measures the total acceleration applied to the device, which includes both the device's linear acceleration (motion) and the force of gravity. For many applications, only the linear acceleration is desired. Prior to Android 4.0, a `TYPE_LINEAR_ACCELERATION` software sensor was often available, but in newer versions, it became hardware-dependent (often requiring a gyroscope), leading to its absence on many devices.

The core challenge is to effectively separate the constant gravitational force from the dynamic linear motion using only the raw accelerometer data.

![Accelerometer Data Components](PLACEHOLDER: Accelerometer Data Components - /images/05bfd463-1.webp)

## The Low-Pass Filter Approach

The most common and effective method to extract linear acceleration from raw accelerometer data is by applying a low-pass filter. This technique is based on the principle that:
1.  **Gravity** is a relatively constant force (when the device is stationary or moving slowly). It changes slowly as the device's orientation changes.
2.  **Linear acceleration** (motion) changes rapidly.

A low-pass filter allows the slow-changing gravity component to pass through while attenuating the fast-changing linear acceleration. By subtracting this filtered gravity component from the raw accelerometer data, we are left with an approximation of the linear acceleration.

The filter equation used is:
`filtered_value = alpha * previous_filtered_value + (1 - alpha) * current_raw_value`

Where `alpha` is a constant between 0 and 1.
-   A higher `alpha` (e.g., 0.8 or 0.9) means the filter gives more weight to past values, making it smoother and more effective at isolating gravity, but also slower to react to orientation changes.
-   A lower `alpha` means it reacts faster but might let more linear acceleration "leak" into the gravity estimate.

![Low-Pass Filter Diagram](PLACEHOLDER: Low-Pass Filter Diagram - /images/05bfd463-2.webp)

## Implementing the Solution

Here's a complete Android example demonstrating how to set up the accelerometer listener and apply the low-pass filter to calculate linear acceleration.

```java
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.os.Bundle;
import android.util.Log;
import androidx.appcompat.app.AppCompatActivity;

public class MainActivity extends AppCompatActivity implements SensorEventListener {

    private static final String TAG = "LinearAcceleration";
    private SensorManager mSensorManager;
    private Sensor mAccelerometer;

    // Arrays to hold the gravity and linear acceleration values
    private float[] gravity = new float[3];
    private float[] linear_acceleration = new float[3];

    // Low-pass filter constant. A higher value means more smoothing (slower response to orientation changes).
    private final float ALPHA = 0.8f;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        mSensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);
        if (mSensorManager != null) {
            mAccelerometer = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
            if (mAccelerometer == null) {
                Log.e(TAG, "Accelerometer sensor not available on this device.");
            }
        } else {
            Log.e(TAG, "SensorManager not available.");
        }
    }

    @Override
    protected void onResume() {
        super.onResume();
        if (mAccelerometer != null) {
            // Register the listener for the accelerometer sensor
            mSensorManager.registerListener(this, mAccelerometer, SensorManager.SENSOR_DELAY_NORMAL);
        }
    }

    @Override
    protected void onPause() {
        super.onPause();
        // Unregister the listener to save battery when the activity is not active
        if (mSensorManager != null) {
            mSensorManager.unregisterListener(this);
        }
    }

    @Override
    public void onSensorChanged(SensorEvent event) {
        if (event.sensor.getType() == Sensor.TYPE_ACCELEROMETER) {
            // Isolate the force of gravity with the low-pass filter.
            // This effectively smooths out the accelerometer readings to get a stable gravity estimate.
            gravity[0] = ALPHA * gravity[0] + (1 - ALPHA) * event.values[0];
            gravity[1] = ALPHA * gravity[1] + (1 - ALPHA) * event.values[1];
            gravity[2] = ALPHA * gravity[2] + (1 - ALPHA) * event.values[2];

            // Remove the gravity contribution with the high-pass filter.
            // By subtracting the smoothed gravity from the raw readings, we get linear acceleration.
            linear_acceleration[0] = event.values[0] - gravity[0];
            linear_acceleration[1] = event.values[1] - gravity[1];
            linear_acceleration[2] = event.values[2] - gravity[2];

            // Log the linear acceleration values
            Log.d(TAG, String.format("Linear Acceleration X: %.2f, Y: %.2f, Z: %.2f",
                    linear_acceleration[0], linear_acceleration[1], linear_acceleration[2]));

            // You can now use linear_acceleration[0], linear_acceleration[1], linear_acceleration[2]
            // for your application logic (e.g., detecting shakes, steps, etc.)
        }
    }

    @Override
    public void onAccuracyChanged(Sensor sensor, int accuracy) {
        // Not used in this example, but can be implemented to handle sensor accuracy changes
    }
}
```

**Explanation:**
1.  **Initialization:** `gravity` and `linear_acceleration` arrays are declared as class members to maintain their state across `onSensorChanged` calls. `ALPHA` is the filter constant.
2.  **`onCreate`:** Obtains `SensorManager` and the default `TYPE_ACCELEROMETER`.
3.  **`onResume` / `onPause`:** Registers and unregisters the `SensorEventListener` to manage sensor updates efficiently and conserve battery.
4.  **`onSensorChanged`:**
    *   It first checks if the event is from the accelerometer.
    *   The low-pass filter is applied to `event.values` to update the `gravity` array. This `gravity` array will slowly converge to the actual gravity vector based on the device's orientation.
    *   The calculated `gravity` is then subtracted from the raw `event.values` to derive `linear_acceleration`.
    *   The resulting `linear_acceleration` values represent the device's motion independent of gravity.

## Common Problems & Solutions

### 1. `gravity` array initialization
**Problem:** The original question asks what `gravity` should contain on the first run. If `gravity` is initialized inside `onSensorChanged`, it will reset on every event, making the filter ineffective.
**Solution:** `gravity` (and `linear_acceleration`) must be declared as class members and initialized once, typically to `0.0f` for all components. The filter will then gradually converge to the correct gravity vector over a few sensor readings.

```java
// Correct: Declare as class members
private float[] gravity = new float[3]; // Automatically initialized to 0.0f by Java
private float[] linear_acceleration = new float[3];
```

### 2. Choosing the `ALPHA` value
**Problem:** The `ALPHA` constant significantly impacts the filter's behavior. An incorrect `ALPHA` can lead to noisy linear acceleration or slow response.
**Solution:**
*   **Higher `ALPHA` (e.g., 0.9, 0.95):** More aggressive smoothing. Better for isolating gravity when the device is mostly stationary or moving slowly. May introduce lag if the device's orientation changes rapidly.
*   **Lower `ALPHA` (e.g., 0.5, 0.7):** Less smoothing. Responds faster to orientation changes but might not completely remove gravity if there's significant linear motion.
*   **Experimentation:** The optimal `ALPHA` depends on the application. Start with `0.8f` and adjust based on observed behavior.

### 3. Sensor Update Rate (`SENSOR_DELAY`)
**Problem:** Using `SENSOR_DELAY_FASTEST` can consume a lot of battery and generate excessive data, which might not be necessary for linear acceleration.
**Solution:** Use an appropriate `SENSOR_DELAY`.
*   `SENSOR_DELAY_NORMAL`: Suitable for most UI-related motion.
*   `SENSOR_DELAY_UI`: Slightly faster than normal.
*   `SENSOR_DELAY_GAME`: Faster for game applications.
*   `SENSOR_DELAY_FASTEST`: Use only when high precision and real-time updates are critical, and battery consumption is not a primary concern.

### 4. Device Orientation Changes
**Problem:** When the device's orientation changes (e.g., rotating from portrait to landscape), the direction of gravity relative to the device's axes changes. The low-pass filter will eventually adapt, but there might be a brief period where the `linear_acceleration` values are inaccurate.
**Solution:** This is inherent to the low-pass filter approach. For applications requiring highly accurate linear acceleration independent of orientation changes, consider using Android's `TYPE_LINEAR_ACCELERATION` sensor if available, or more advanced sensor fusion techniques involving gyroscopes and magnetometers. However, for many common use cases (like step counting or shake detection), the low-pass filter is sufficient.

## Real-World Use Cases

Calculating linear acceleration is fundamental for many mobile applications:

*   **Step Counters/Pedometer:** Detecting distinct steps by analyzing peaks in linear acceleration.
*   **Shake Detection:** Identifying specific patterns of linear acceleration to trigger actions (e.g., shake to undo, shake to refresh).
*   **Activity Recognition:** Differentiating between walking, running, standing, or sitting based on the magnitude and pattern of linear acceleration.
*   **Gesture Recognition:** Recognizing complex gestures by analyzing sequences of linear acceleration.
*   **Basic Motion Tracking:** Estimating displacement or velocity (though this requires careful integration and drift compensation).
*   **Gaming:** Providing input based on device movement.

## Summary

While Android's `TYPE_LINEAR_ACCELERATION` sensor might not always be available, you can reliably calculate linear acceleration from the raw `TYPE_ACCELEROMETER` data. The key is to use a low-pass filter to separate the constant gravitational force from the dynamic linear motion. By maintaining a smoothed estimate of gravity and subtracting it from the current accelerometer readings, you can obtain a useful approximation of the device's linear acceleration, enabling a wide range of motion-sensing applications. Remember to initialize your filter variables correctly and choose an `ALPHA` value that balances responsiveness and smoothing for your specific use case.

---

## Image Generation Prompts

**PLACEHOLDER-1:** A conceptual diagram showing an Android phone with three arrows representing the X, Y, and Z axes of the accelerometer. One large downward arrow labeled "Gravity" points towards the bottom of the screen. A smaller, wavy arrow labeled "Linear Acceleration" points in a different direction. Text labels indicate that "Raw Accelerometer Data = Gravity + Linear Acceleration". The background should be a subtle, tech-themed gradient.

**PLACEHOLDER-2:** A flowchart or block diagram illustrating the low-pass filter process. Start with a "Raw Accelerometer Data" input block. This feeds into a "Low-Pass Filter (Alpha)" block. The output of this filter is "Estimated Gravity". Then, a "Subtraction" block takes "Raw Accelerometer Data" and "Estimated Gravity" as inputs. The final output block is "Linear Acceleration". Use arrows to show data flow. The filter block should mention `alpha * previous + (1 - alpha) * current`.