---
title: "Create Density-Colored Scatter Plots in Matplotlib"
slug: "matplotlib-density-colored-scatter-plot"
category: "programming-languages"
subcategory: "python"
description: "Learn various methods to create scatter plots colored by point density in Matplotlib, including KDE, histogram-based, and optimized approaches."
tags: ["python","matplotlib","data-visualization","density-plot","kernel-density","scipy"]
difficulty: "intermediate"
readTime: 10
lastUpdated: "2025-09-22T16:16:54.214Z"
featured: false
---

# How to Make a Scatter Plot Colored by Density in Matplotlib

Creating a scatter plot where the color of each point reflects the local density of other points is a powerful visualization technique. It helps in identifying clusters and high-density regions in your data, especially when dealing with a large number of overlapping points. This guide explores several methods to achieve this in Python using Matplotlib, ranging from Kernel Density Estimation (KDE) to histogram-based approaches and optimized libraries.

## Quick Answer

The most direct way to color a scatter plot by density is using `scipy.stats.gaussian_kde` to estimate point density and then mapping these density values to the `c` (color) argument of `plt.scatter`.

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import gaussian_kde

# Generate fake data
x = np.random.normal(size=1000)
y = x * 3 + np.random.normal(size=1000)

# Calculate the point density
xy = np.vstack([x, y])
z = gaussian_kde(xy)(xy)

# Sort points by density to ensure denser points are drawn on top
idx = z.argsort()
x, y, z = x[idx], y[idx], z[idx]

fig, ax = plt.subplots()
ax.scatter(x, y, c=z, s=50, cmap='viridis') # Use a colormap like 'viridis'
plt.colorbar(label='Density')
plt.title('Scatter Plot Colored by Gaussian KDE Density')
plt.show()
```

## Choose Your Method

Selecting the right method depends on your dataset size, desired accuracy, and performance requirements.

```mermaid
graph TD
    A[Start] --> B{Dataset Size?};
    B -- Small (<10k points) --> C[Gaussian KDE (scipy.stats.gaussian_kde)];
    B -- Medium (10k-100k points) --> D[Histogram-based (np.histogram2d + scipy.interpolate.interpn)];
    B -- Large (>100k points) --> E{Performance Critical?};
    E -- Yes --> F[Optimized Libraries (mpl-scatter-density, datashader)];
    E -- No --> D;
    C --> G[Good visual quality, accurate density];
    D --> H[Faster than KDE for larger data, good approximation];
    F --> I[Excellent performance for very large datasets, good visual quality];
    G --> J[End];
    H --> J;
    I --> J;
```
![Decision Tree for Density Plot Methods](PLACEHOLDER: Decision Tree for Density Plot Methods - /images/5f9d3ce3-1.webp)

## Table of Contents
1.  [Quick Answer](#quick-answer)
2.  [Choose Your Method](#choose-your-method)
3.  [Method 1: Gaussian Kernel Density Estimation (KDE)](#method-1-gaussian-kernel-density-estimation-kde)
4.  [Method 2: Histogram-based Interpolation](#method-2-histogram-based-interpolation)
5.  [Method 3: Optimized Libraries for Large Datasets](#method-3-optimized-libraries-for-large-datasets)
    *   [mpl-scatter-density](#mpl-scatter-density)
    *   [Datashader](#datashader)
6.  [Method 4: Basic 2D Histogram (`plt.hist2d`)](#method-4-basic-2d-histogram-plt.hist2d)
7.  [Performance Comparison](#performance-comparison)
8.  [Common Problems & Solutions](#common-problems-solutions)
9.  [Summary](#summary)

## Method 1: Gaussian Kernel Density Estimation (KDE)

This method uses `scipy.stats.gaussian_kde` to estimate the probability density function (PDF) of your data points. Each point is then colored according to its estimated density. Sorting the points by density before plotting ensures that denser points are drawn on top, preventing them from being obscured by sparser points.

**Pros:**
*   Provides a smooth, continuous density estimate.
*   Visually appealing for smaller datasets.

**Cons:**
*   Can be computationally expensive and slow for very large datasets (e.g., >10,000 points).

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import gaussian_kde

# 1. Generate sample data
np.random.seed(42)
x = np.random.normal(loc=0, scale=1, size=5000)
y = x * 2 + np.random.normal(loc=0, scale=0.5, size=5000)

# Add a second cluster for more interesting density
x = np.concatenate([x, np.random.normal(loc=3, scale=0.8, size=2000)])
y = np.concatenate([y, np.random.normal(loc=-2, scale=0.8, size=2000)])

# 2. Calculate the point density
# Stack x and y to create a 2D array for gaussian_kde
xy = np.vstack([x, y])
z = gaussian_kde(xy)(xy)

# 3. Sort the points by density
# This ensures that denser points are plotted on top, making them more visible.
idx = z.argsort()
x, y, z = x[idx], y[idx], z[idx]

# 4. Create the scatter plot
fig, ax = plt.subplots(figsize=(8, 6))
scatter = ax.scatter(x, y, c=z, s=50, cmap='viridis', edgecolor='none', alpha=0.8)

# 5. Add a color bar
cbar = fig.colorbar(scatter, ax=ax, label='Density (KDE)')
ax.set_title('Scatter Plot Colored by Gaussian KDE Density')
ax.set_xlabel('X-axis')
ax.set_ylabel('Y-axis')
plt.grid(True, linestyle='--', alpha=0.6)
plt.show()
```
![Gaussian KDE Density Plot](PLACEHOLDER: Gaussian KDE Density Plot - PLACEHOLDER-2)

**Explanation:**
1.  `np.vstack([x, y])` combines the x and y coordinates into a 2D array suitable for `gaussian_kde`.
2.  `gaussian_kde(xy)` creates a KDE object. Calling `(xy)` on this object evaluates the density at each original point.
3.  `z.argsort()` returns the indices that would sort the `z` array. We use these indices to reorder `x`, `y`, and `z` so that points with higher density values are at the end of the arrays and thus drawn last (on top).
4.  `ax.scatter(x, y, c=z, ...)` uses the calculated `z` values directly for coloring. `cmap='viridis'` sets the colormap, and `edgecolor='none'` removes borders around points for a cleaner look.

## Method 2: Histogram-based Interpolation

This method first creates a 2D histogram of the data to get a grid-based density estimate. Then, it interpolates these grid densities back to the original point locations. This approach can be significantly faster than KDE for larger datasets while still providing a good visual representation of density.

**Pros:**
*   Faster than KDE for large datasets.
*   Good balance between performance and visual quality.
*   Allows control over the granularity of the density estimation via `bins`.

**Cons:**
*   The choice of `bins` can influence the smoothness and accuracy of the density estimate.
*   Less "smooth" than pure KDE if `bins` are too coarse.

```python
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm
from matplotlib.colors import Normalize
from scipy.interpolate import interpn

def density_scatter(x, y, ax=None, sort=True, bins=20, **kwargs):
    """
    Scatter plot colored by 2D histogram density.
    """
    if ax is None:
        fig, ax = plt.subplots()

    # 1. Create a 2D histogram
    # data: 2D array of counts, x_e/y_e: bin edges
    data, x_e, y_e = np.histogram2d(x, y, bins=bins, density=True)

    # 2. Interpolate density values back to original points
    # interpn interpolates values from a grid (data) to specific points (np.vstack([x,y]).T)
    z = interpn(
        (0.5 * (x_e[1:] + x_e[:-1]), 0.5 * (y_e[1:] + y_e[:-1])), # Midpoints of bins
        data,
        np.vstack([x, y]).T,
        method="splinef2d", # Use spline interpolation for smoothness
        bounds_error=False
    )

    # Handle NaN values (points outside histogram range)
    z[np.where(np.isnan(z))] = 0.0

    # 3. Sort points by density for better visualization
    if sort:
        idx = z.argsort()
        x, y, z = x[idx], y[idx], z[idx]

    # 4. Create the scatter plot
    scatter = ax.scatter(x, y, c=z, **kwargs)

    # 5. Add a color bar
    norm = Normalize(vmin=np.min(z), vmax=np.max(z))
    cbar = plt.colorbar(cm.ScalarMappable(norm=norm, cmap=kwargs.get('cmap', 'viridis')), ax=ax)
    cbar.ax.set_ylabel('Density (Interpolated Histogram)')

    return ax

if __name__ == '__main__':
    np.random.seed(42)
    x = np.random.normal(loc=0, scale=1, size=100000)
    y = x * 3 + np.random.normal(loc=0, scale=0.5, size=100000)

    fig, ax = plt.subplots(figsize=(8, 6))
    density_scatter(x, y, ax=ax, bins=[50, 50], s=10, cmap='plasma', edgecolor='none', alpha=0.8)
    ax.set_title('Scatter Plot Colored by Interpolated Histogram Density')
    ax.set_xlabel('X-axis')
    ax.set_ylabel('Y-axis')
    plt.grid(True, linestyle='--', alpha=0.6)
    plt.show()
```
![Histogram Interpolation Density Plot](PLACEHOLDER: Histogram Interpolation Density Plot - /images/5f9d3ce3-3.webp)

**Explanation:**
1.  `np.histogram2d` calculates the 2D histogram, returning the counts (`data`) and the bin edges (`x_e`, `y_e`). `density=True` normalizes the counts to form a probability density.
2.  `interpn` is used to interpolate the density values from the histogram grid back to the exact coordinates of each original `(x, y)` point. `method="splinef2d"` provides a smooth interpolation.
3.  NaN values, which can occur if points fall outside the defined histogram bins, are set to 0.0.
4.  Similar to KDE, points are sorted by their interpolated density `z` before plotting.
5.  A `Normalize` object is used with `cm.ScalarMappable` to correctly map `z` values to the colormap for the colorbar.

## Method 3: Optimized Libraries for Large Datasets

For very large datasets (hundreds of thousands to millions of points), the previous methods can become too slow. Specialized libraries like `mpl-scatter-density` and `datashader` are designed for high-performance density plotting.

### mpl-scatter-density

This library provides a custom Matplotlib projection that efficiently computes and renders density plots using a 2D histogram approach, optimized for speed.

**Installation:**
```bash
pip install mpl-scatter-density
```

**Pros:**
*   Very fast for large datasets.
*   Integrates seamlessly with Matplotlib's API.
*   Handles zooming efficiently.

**Cons:**
*   Requires an additional library installation.

```python
import numpy as np
import matplotlib.pyplot as plt
import mpl_scatter_density # adds projection='scatter_density'
from matplotlib.colors import LinearSegmentedColormap

# Generate fake data (100,000 points)
np.random.seed(42)
x = np.random.normal(loc=0, scale=1, size=100000)
y = x * 3 + np.random.normal(loc=0, scale=0.5, size=100000)

# Define a custom colormap (optional, 'viridis' or others work too)
white_viridis = LinearSegmentedColormap.from_list(
    'white_viridis',
    [(0, '#ffffff'), (1e-20, '#440053'), (0.2, '#404388'), (0.4, '#2a788e'),
     (0.6, '#21a784'), (0.8, '#78d151'), (1, '#fde624')], N=256
)

fig = plt.figure(figsize=(8, 6))
# Use the 'scatter_density' projection
ax = fig.add_subplot(1, 1, 1, projection='scatter_density')
density = ax.scatter_density(x, y, cmap=white_viridis) # or just cmap='viridis'
fig.colorbar(density, label='Number of points per pixel')

ax.set_title('Scatter Plot Colored by Density (mpl-scatter-density)')
ax.set_xlabel('X-axis')
ax.set_ylabel('Y-axis')
plt.grid(True, linestyle='--', alpha=0.6)
plt.show()
```
![mpl-scatter-density Plot](PLACEHOLDER: mpl-scatter-density Plot - /images/5f9d3ce3-4.webp)

**Explanation:**
1.  Import `mpl_scatter_density`. This automatically registers the `scatter_density` projection.
2.  When creating the subplot, specify `projection='scatter_density'`.
3.  Call `ax.scatter_density(x, y, ...)` which is an optimized method provided by the projection. It internally handles the density calculation and plotting.

### Datashader

Datashader is a powerful library for rendering large datasets. It rasterizes data into a fixed-size image, making it extremely fast for millions or even billions of points. It can integrate with Matplotlib via `datashader.mpl_ext.dsshow`.

**Installation:**
```bash
pip install datashader pandas
```

**Pros:**
*   Unmatched performance for extremely large datasets.
*   Produces high-quality, anti-aliased images.
*   Supports various aggregation methods beyond simple counts.

**Cons:**
*   Requires additional libraries (`datashader`, `pandas`).
*   Can be a bit more complex to set up compared to direct Matplotlib.

```python
import numpy as np
import matplotlib.pyplot as plt
import datashader as ds
from datashader.mpl_ext import dsshow
import pandas as pd

# Generate fake data (100,000 points)
np.random.seed(42)
x = np.random.normal(loc=0, scale=1, size=100000)
y = x * 3 + np.random.normal(loc=0, scale=0.5, size=100000)

# Create a Pandas DataFrame, which Datashader often uses
df = pd.DataFrame(dict(x=x, y=y))

fig, ax = plt.subplots(figsize=(8, 6))

# Use dsshow to render the datashader plot on a Matplotlib axis
dsartist = dsshow(
    df,
    ds.Point("x", "y"), # Specify the x and y columns
    ds.count(),         # Aggregate by counting points in each pixel
    vmin=0,             # Minimum density value for colormap
    vmax=35,            # Maximum density value for colormap (adjust as needed)
    norm="linear",
    aspect="auto",
    ax=ax,
    cmap='fire'         # Colormap for the density
)

plt.colorbar(dsartist, label='Number of points per pixel (Datashader)')
ax.set_title('Scatter Plot Colored by Density (Datashader)')
ax.set_xlabel('X-axis')
ax.set_ylabel('Y-axis')
plt.grid(True, linestyle='--', alpha=0.6)
plt.show()
```
![Datashader Density Plot](PLACEHOLDER: Datashader Density Plot - /images/5f9d3ce3-5.webp)

**Explanation:**
1.  Data is converted to a Pandas DataFrame, a common input for Datashader.
2.  `dsshow` is the key function for Matplotlib integration.
3.  `ds.Point("x", "y")` specifies the columns to use for the scatter plot.
4.  `ds.count()` defines the aggregation method â€“ in this case, counting the number of points that fall into each pixel. Other aggregations like `ds.mean()` or `ds.sum()` can be used if you have a third variable.
5.  `vmin` and `vmax` help control the colormap scaling.

## Method 4: Basic 2D Histogram (`plt.hist2d`)

While not strictly a "scatter plot colored by density" in the sense of individual points, `plt.hist2d` creates a heatmap-like representation of density by dividing the plot area into bins and coloring each bin based on the number of points it contains. It's a quick and simple way to visualize density.

**Pros:**
*   Very simple to implement.
*   Fast for all dataset sizes.
*   Good for quickly identifying high-density regions.

**Cons:**
*   Does not show individual points, but rather aggregated bins.
*   The choice of `bins` significantly affects the appearance.
*   Zooming in might reveal blockiness if `bins` are too coarse.

```python
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import LogNorm # Optional: for better visualization of skewed data

# Generate fake data
np.random.seed(42)
x = np.random.normal(loc=0, scale=1, size=10000)
y = x * 3 + np.random.normal(loc=0, scale=0.5, size=10000)

fig, ax = plt.subplots(figsize=(8, 6))

# Create the 2D histogram
# bins: number of bins in x and y direction
# cmap: colormap to use
# cmin: minimum count for a bin to be plotted (useful to hide empty bins)
hist = ax.hist2d(x, y, bins=(50, 50), cmap='hot_r', cmin=1) # hot_r is reversed hot colormap
# hist = ax.hist2d(x, y, bins=(50, 50), cmap='hot_r', cmin=1, norm=LogNorm()) # Use LogNorm for skewed data

fig.colorbar(hist[3], ax=ax, label='Number of points in bin')
ax.set_title('2D Histogram (Density Map)')
ax.set_xlabel('X-axis')
ax.set_ylabel('Y-axis')
plt.grid(True, linestyle='--', alpha=0.6)
plt.show()
```
![Basic 2D Histogram](PLACEHOLDER: Basic 2D Histogram - /images/5f9d3ce3-6.webp)

**Explanation:**
1.  `ax.hist2d(x, y, bins=(50, 50), ...)` directly computes and plots the 2D histogram.
2.  `bins` can be an integer (for equal bins in x and y) or a tuple `(nx, ny)` for different bin counts.
3.  `cmin=1` is a useful trick to only plot bins that contain at least one point, making the plot look more like a scatter plot by hiding empty regions.
4.  `LogNorm()` from `matplotlib.colors` can be used with `norm=LogNorm()` to apply a logarithmic scaling to the color mapping, which is often beneficial when density values span a wide range.

## Performance Comparison

Here's a general comparison of the methods based on typical performance for different dataset sizes.

| Method                                  | Small Data (<10k points) | Medium Data (10k-100k points) | Large Data (>100k points) | Visual Quality | Ease of Use |
| :-------------------------------------- | :----------------------- | :---------------------------- | :------------------------ | :------------- | :---------- |
| **Gaussian KDE** (`gaussian_kde`)       | Excellent                | Slow                          | Very Slow                 | High (smooth)  | Medium      |
| **Histogram Interpolation**             | Good                     | Good                          | Moderate                  | Medium-High    | Medium      |
| **`mpl-scatter-density`**               | Good                     | Excellent                     | Excellent                 | High           | Easy        |
| **`Datashader`**                        | Good                     | Excellent                     | Excellent                 | High (raster)  | Medium      |
| **Basic 2D Histogram** (`plt.hist2d`)   | Excellent                | Excellent                     | Excellent                 | Medium (binned)| Easy        |

![Performance Comparison Chart](PLACEHOLDER: Performance Comparison Chart - /images/5f9d3ce3-7.webp)

## Common Problems & Solutions

*   **Slow performance with KDE for large datasets:**
    *   **Problem:** `gaussian_kde` becomes very slow for datasets with more than ~10,000 points.
    *   **Solution:** Switch to `mpl-scatter-density`, `datashader`, or the histogram-based interpolation method.
*   **Points obscuring each other:**
    *   **Problem:** In dense regions, points with lower density might be drawn on top of higher-density points, hiding the true density.
    *   **Solution:** Sort the points by their calculated density (`z.argsort()`) and plot them in ascending order of density. This ensures denser points are drawn last and are visible.
*   **No colorbar or incorrect colorbar:**
    *   **Problem:** The colorbar doesn't appear or doesn't correctly reflect the density values.
    *   **Solution:** Ensure you pass the scatter plot object to `plt.colorbar()` or `fig.colorbar()`. For custom density calculations, you might need to explicitly create a `ScalarMappable` with a `Normalize` object, as shown in the histogram interpolation example.
*   **`ValueError: Expected 2-dimensional array, got 1` with `gaussian_kde`:**
    *   **Problem:** This can occur in older Matplotlib versions if `edgecolor=''` is used.
    *   **Solution:** Change `edgecolor=''` to `edgecolor=None`.
*   **Blocky appearance with `plt.hist2d`:**
    *   **Problem:** The 2D histogram looks blocky, especially when zoomed in.
    *   **Solution:** Increase the number of `bins`. For a smoother appearance, consider `mpl-scatter-density` or the histogram-based interpolation. Using `LogNorm` can also improve visual range.

## Summary

Coloring scatter plots by density is a crucial technique for visualizing large datasets and identifying patterns.

*   For **smaller datasets**, `scipy.stats.gaussian_kde` offers a smooth and accurate density estimate. Remember to sort points by density for optimal visualization.
*   For **medium to large datasets**, the histogram-based interpolation method provides a good balance of performance and visual quality.
*   For **very large datasets**, specialized libraries like `mpl-scatter-density` and `datashader` are highly recommended for their efficiency and advanced rendering capabilities.
*   `plt.hist2d` offers a quick and simple heatmap-like density visualization, though it doesn't show individual points.

Choose the method that best fits your data size, performance needs, and desired level of detail.

---

## Image Generation Prompts

**PLACEHOLDER-1:** A decision tree flowchart. The root node is "Dataset Size?". Branches lead to "Small (<10k points)", "Medium (10k-100k points)", and "Large (>100k points)". "Small" leads to "Gaussian KDE". "Medium" leads to "Histogram-based Interpolation". "Large" branches into "Performance Critical?". "Performance Critical? Yes" leads to "Optimized Libraries (mpl-scatter-density, datashader)". "Performance Critical? No" leads back to "Histogram-based Interpolation". Each method node should have a brief description of its pros/cons. Use a clean, modern flowchart style with clear arrows.

**PLACEHHER-2:** A Matplotlib scatter plot. The plot shows two clusters of points. Points are colored by density using a 'viridis' colormap, with denser areas appearing yellow/green and sparser areas appearing purple/blue. A colorbar on the right is labeled "Density (KDE)". The title is "Scatter Plot Colored by Gaussian KDE Density". Axes are labeled "X-axis" and "Y-axis".

**PLACEHOLDER-3:** A Matplotlib scatter plot, similar to PLACEHOLDER-2 but with a 'plasma' colormap. The plot shows two clusters of points, colored by density derived from interpolated histogram values. Denser areas are yellow/white, sparser areas are dark purple. A colorbar on the right is labeled "Density (Interpolated Histogram)". The title is "Scatter Plot Colored by Interpolated Histogram Density". Axes are labeled "X-axis" and "Y-axis".

**PLACEHOLDER-4:** A Matplotlib scatter plot generated using `mpl-scatter-density`. The plot shows two clusters of points, colored by density using a custom colormap (similar to 'white_viridis' described in the code, starting white and transitioning to dark blue, then green, then yellow). A colorbar on the right is labeled "Number of points per pixel". The title is "Scatter Plot Colored by Density (mpl-scatter-density)". Axes are labeled "X-axis" and "Y-axis".

**PLACEHOLDER-5:** A Matplotlib plot generated using `datashader`. The plot shows two clusters of points, rendered as a density heatmap using a 'fire' colormap. Denser areas are bright yellow/white, fading to red and then black in sparser regions. A colorbar on the right is labeled "Number of points per pixel (Datashader)". The title is "Scatter Plot Colored by Density (Datashader)". Axes are labeled "X-axis" and "Y-axis".

**PLACEHOLDER-6:** A Matplotlib 2D histogram plot (heatmap). The plot shows two clusters of points, represented by colored bins using a 'hot_r' colormap. Denser bins are bright yellow/white, fading to red and then black. A colorbar on the right is labeled "Number of points in bin". The title is "2D Histogram (Density Map)". Axes are labeled "X-axis" and "Y-axis". The bins should be visible but not overly blocky, suggesting a reasonable bin count.

**PLACEHOLDER-7:** A bar chart comparing the performance of different density plotting methods. The X-axis lists the methods: "Gaussian KDE", "Histogram Interpolation", "mpl-scatter-density", "Datashader", "Basic 2D Histogram". The Y-axis represents "Relative Performance (Higher is Faster)". Bars should be colored differently. "Gaussian KDE" should have a low bar. "Histogram Interpolation" a medium bar. "mpl-scatter-density" and "Datashader" should have high bars. "Basic 2D Histogram" should have a very high bar. Include a small legend indicating what each bar color represents (e.g., "Small Data", "Medium Data", "Large Data" - though the chart should primarily show relative speed).