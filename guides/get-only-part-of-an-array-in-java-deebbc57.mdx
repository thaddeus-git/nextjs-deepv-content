---
title: "Get only part of an Array in Java?: Complete Guide with 0 Solutions"
slug: "get-only-part-of-an-array-in-java"
category: "programming-languages"
subcategory: "java"
description: "While Java doesn't have the direct slicing syntax array[index:] like Python, you can achieve similar results efficiently using Arrays.copyOfRange(). This met..."
tags: ["java","arrays"]
difficulty: "intermediate"
readTime: 29
lastUpdated: "2025-09-18T16:17:49.235Z"
featured: true
---

# Get only part of an Array in Java?: Complete Guide with 0 Solutions

## Quick Answer

While Java doesn't have the direct slicing syntax `array[index:]` like Python, you can achieve similar results efficiently using `Arrays.copyOfRange()`. This method provides a clean, concise, and robust way to extract a portion of an array, creating a new array containing the specified elements.

```java
import java.util.Arrays;

public class ArraySlicingExample {
    public static void main(String[] args) {
        int[] originalArray = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};

        // Get elements from index 3 to the end (inclusive)
        // Equivalent to Python's originalArray[3:]
        int[] subArrayFromIndex = Arrays.copyOfRange(originalArray, 3, originalArray.length);
        System.out.println("Sub-array from index 3: " + Arrays.toString(subArrayFromIndex));
        // Expected output: [40, 50, 60, 70, 80, 90, 100]

        // Get elements from index 1 up to (but not including) index 5
        // Equivalent to Python's originalArray[1:5]
        int[] subArrayRange = Arrays.copyOfRange(originalArray, 1, 5);
        System.out.println("Sub-array from index 1 to 5: " + Arrays.toString(subArrayRange));
        // Expected output: [20, 30, 40, 50]

        // Get elements from the beginning up to (but not including) index 4
        // Equivalent to Python's originalArray[:4]
        int[] subArrayToExclusiveIndex = Arrays.copyOfRange(originalArray, 0, 4);
        System.out.println("Sub-array to index 4: " + Arrays.toString(subArrayToExclusiveIndex));
        // Expected output: [10, 20, 30, 40]
    }
}
```

## Choose Your Method

Deciding the best way to get a part of an array in Java depends on your specific needs, including performance, readability, and whether you're dealing with primitive types or objects. This decision tree will guide you to the most suitable approach.

```mermaid
graph TD
    A[Start: Need to get a part of a Java Array?] --> B{Are you working with primitive arrays (e.g., int[], double[]) or Object arrays (e.g., String[], CustomObject[])?};

    B -- Primitive Arrays --> C{Do you need a new array, or can you work with a view/reference to the original?};
    B -- Object Arrays --> D{Do you need a shallow copy or a deep copy of the objects within the sub-array?};

    C -- Need New Array --> E{Do you need to specify both start and end indices, or just a start index to the end?};
    C -- Work with View/Reference (Advanced/Rare for sub-arrays) --> F[Consider `ByteBuffer.wrap()` for byte arrays or custom wrapper classes for other primitives. Generally not recommended for simple sub-array extraction.];

    E -- Both Start & End Indices --> G[`Arrays.copyOfRange()` (Recommended for üöÄ Speed Seeker, üìö Learning Explorer, üîß Problem Solver)];
    E -- Start Index to End --> G;

    D -- Shallow Copy (New array, same object references) --> H[`Arrays.copyOfRange()` (Recommended for üöÄ Speed Seeker, üìö Learning Explorer, üîß Problem Solver)];
    D -- Deep Copy (New array, new copies of objects) --> I[Iterate and manually clone/copy each object. (Recommended for üèóÔ∏è Architecture Builder, üé® Output Focused for specific deep copy needs)];

    G --> J[End: `Arrays.copyOfRange()` is your go-to for most scenarios.];
    H --> J;
    I --> J;
    F --> J;

    subgraph Personas
        G -- üöÄ Speed Seeker --> G_Speed[Fastest, minimal code];
        G -- üìö Learning Explorer --> G_Learning[Educational, best practices];
        G -- üîß Problem Solver --> G_Problem[Just works, copy-paste];
        I -- üèóÔ∏è Architecture Builder --> I_Arch[Scalable, maintainable];
        I -- üé® Output Focused --> I_Output[Specific object state preservation];
        F -- ‚ö° Legacy Maintainer --> F_Legacy[If forced by legacy APIs];
    end
```

## Table of Contents
- [Quick Answer](#quick-answer)
- [Choose Your Method](#choose-your-method)
- [Ready-to-Use Code](#ready-to-use-code)
- [Method 1: Using `Arrays.copyOfRange()`](#method-1-using-arrayscopyofrange)
- [Method 2: Using `System.arraycopy()`](#method-2-using-systemarraycopy)
- [Method 3: Manual Iteration (Looping)](#method-3-manual-iteration-looping)
- [Method 4: Using Streams (Java 8+)](#method-4-using-streams-java-8)
- [Method 5: Using `ArrayList.subList()` (for `List`s)](#method-5-using-arraylistsublist-for-lists)
- [Performance Comparison](#performance-comparison)
- [Java Version Support](#java-version-support)
- [Common Problems & Solutions](#common-problems--solutions)
- [Real-World Use Cases](#real-world-use-cases)
- [Related: Other Java Operations](#related-other-java-operations)
- [Summary](#summary)
- [Frequently Asked Questions](#frequently-asked-questions)
- [Tools & Resources](#tools--resources)

## Ready-to-Use Code

Here are the most common and efficient ways to get a part of an array in Java, ready for you to copy and paste into your projects.

### 1. `Arrays.copyOfRange()` - The Modern Standard (üöÄ Speed Seeker, üìö Learning Explorer, üîß Problem Solver)

This is generally the most recommended method for its simplicity, readability, and efficiency. It creates a new array containing the specified range.

```java
import java.util.Arrays;

public class CopyOfRangeSnippet {
    public static void main(String[] args) {
        String[] originalStrings = {"apple", "banana", "cherry", "date", "elderberry", "fig"};

        // Extract elements from index 2 (inclusive) to index 5 (exclusive)
        String[] subArray1 = Arrays.copyOfRange(originalStrings, 2, 5);
        System.out.println("Sub-array (2 to 5 exclusive): " + Arrays.toString(subArray1));
        // Expected output: [cherry, date, elderberry]

        // Extract elements from index 3 (inclusive) to the end of the array
        String[] subArray2 = Arrays.copyOfRange(originalStrings, 3, originalStrings.length);
        System.out.println("Sub-array (3 to end): " + Arrays.toString(subArray2));
        // Expected output: [date, elderberry, fig]

        // Extract elements from the beginning to index 4 (exclusive)
        String[] subArray3 = Arrays.copyOfRange(originalStrings, 0, 4);
        System.out.println("Sub-array (0 to 4 exclusive): " + Arrays.toString(subArray3));
        // Expected output: [apple, banana, cherry, date]
    }
}
```

### 2. `System.arraycopy()` - High Performance for Primitives (üöÄ Speed Seeker, ‚ö° Legacy Maintainer)

When performance is absolutely critical, especially with large primitive arrays, `System.arraycopy()` can be slightly faster as it's a native method. However, it requires more manual setup (creating the destination array first).

```java
public class ArrayCopySnippet {
    public static void main(String[] args) {
        int[] originalInts = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

        // Define start index and length of the desired sub-array
        int startIndex = 4; // Start from the 5th element (index 4)
        int length = 3;     // Get 3 elements

        // 1. Create a new destination array of the correct size
        int[] subArray = new int[length];

        // 2. Copy elements from original to subArray
        // Parameters: src, srcPos, dest, destPos, length
        System.arraycopy(originalInts, startIndex, subArray, 0, length);

        System.out.print("Sub-array using System.arraycopy: [");
        for (int i = 0; i < subArray.length; i++) {
            System.out.print(subArray[i]);
            if (i < subArray.length - 1) {
                System.out.print(", ");
            }
        }
        System.out.println("]");
        // Expected output: [5, 6, 7]
    }
}
```

### 3. Streams API (Java 8+) - Functional and Expressive (üìö Learning Explorer, üèóÔ∏è Architecture Builder)

For a more functional programming style, especially when you need to perform other operations (like filtering or mapping) on the sub-array, the Streams API is a powerful choice.

```java
import java.util.Arrays;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class StreamSnippet {
    public static void main(String[] args) {
        Integer[] originalIntegers = {100, 200, 300, 400, 500, 600, 700};

        // Get elements from index 2 (inclusive) to index 5 (exclusive)
        // For Object arrays (Integer[]), use Stream.of()
        Integer[] subArray1 = Stream.of(originalIntegers)
                                    .skip(2) // Skip first 2 elements
                                    .limit(3) // Take next 3 elements (300, 400, 500)
                                    .toArray(Integer[]::new);
        System.out.println("Sub-array (Streams, Object[]): " + Arrays.toString(subArray1));
        // Expected output: [300, 400, 500]

        int[] originalPrimitives = {1, 2, 3, 4, 5, 6, 7, 8};

        // Get elements from index 1 (inclusive) to index 4 (exclusive)
        // For primitive arrays (int[]), use IntStream.range() or Arrays.stream()
        int[] subArray2 = IntStream.range(1, 4) // Indices 1, 2, 3
                                   .map(i -> originalPrimitives[i])
                                   .toArray();
        System.out.println("Sub-array (Streams, primitive[]): " + Arrays.toString(subArray2));
        // Expected output: [2, 3, 4]
    }
}
```

## Method 1: Using `Arrays.copyOfRange()`

**Personas:** üöÄ Speed Seeker, üìö Learning Explorer, üîß Problem Solver, üé® Output Focused

`Arrays.copyOfRange()` is arguably the most idiomatic and recommended way to extract a portion of an array in Java. Introduced in Java 6, it provides a convenient and safe method for creating a new array containing elements from a specified range of an existing array.

### How it Works

This method takes three arguments:
1.  `original`: The array from which a range is to be copied.
2.  `from`: The initial index of the range to be copied, inclusive.
3.  `to`: The final index of the range to be copied, exclusive. (This means the element at `to` index is NOT included).

It returns a new array of the same type as the original, containing the elements from `from` up to (but not including) `to`. If `from` is equal to `to`, an empty array is returned. If `from` is greater than `to`, an `IllegalArgumentException` is thrown. If `from` or `to` are out of bounds relative to the `original` array's length, an `ArrayIndexOutOfBoundsException` is thrown.

### Advantages

*   **Simplicity and Readability:** The method signature clearly indicates its purpose.
*   **Safety:** Handles boundary conditions and throws appropriate exceptions.
*   **Convenience:** Automatically creates the new array of the correct size.
*   **Generality:** Works for both primitive arrays (e.g., `int[]`, `double[]`) and object arrays (e.g., `String[]`, `MyObject[]`). For object arrays, it performs a shallow copy (references to the same objects are copied).

### Disadvantages

*   **New Array Creation:** Always creates a new array, which might incur a slight overhead for very large arrays or in extremely performance-sensitive loops.
*   **Shallow Copy for Objects:** For object arrays, it copies references, not the objects themselves. If you modify an object in the sub-array, the original object in the source array will also be affected. A deep copy requires manual iteration or serialization.

### Code Examples

#### Example 1: Basic Integer Array Slicing

```java
import java.util.Arrays;

public class CopyOfRangeIntExample {
    public static void main(String[] args) {
        int[] numbers = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};

        // Get elements from index 2 (inclusive) to index 6 (exclusive)
        // This will include elements at indices 2, 3, 4, 5
        int[] subArray1 = Arrays.copyOfRange(numbers, 2, 6);
        System.out.println("Sub-array from index 2 to 6 (exclusive): " + Arrays.toString(subArray1));
        // Expected output: [30, 40, 50, 60]

        // Get elements from index 5 (inclusive) to the end of the array
        int[] subArray2 = Arrays.copyOfRange(numbers, 5, numbers.length);
        System.out.println("Sub-array from index 5 to end: " + Arrays.toString(subArray2));
        // Expected output: [60, 70, 80, 90, 100]

        // Get elements from the beginning (index 0) to index 3 (exclusive)
        int[] subArray3 = Arrays.copyOfRange(numbers, 0, 3);
        System.out.println("Sub-array from beginning to index 3 (exclusive): " + Arrays.toString(subArray3));
        // Expected output: [10, 20, 30]
    }
}
```

#### Example 2: String Array Slicing (Object Array)

```java
import java.util.Arrays;

public class CopyOfRangeStringExample {
    public static void main(String[] args) {
        String[] fruits = {"apple", "banana", "cherry", "date", "elderberry", "fig", "grape"};

        // Get elements from index 1 to 4 (exclusive)
        String[] selectedFruits = Arrays.copyOfRange(fruits, 1, 4);
        System.out.println("Selected fruits: " + Arrays.toString(selectedFruits));
        // Expected output: [banana, cherry, date]

        // Demonstrate shallow copy: modifying an object in the sub-array
        // (Note: Strings are immutable, so this example uses a custom mutable object for demonstration)
        class MutableItem {
            String name;
            MutableItem(String name) { this.name = name; }
            @Override public String toString() { return name; }
        }

        MutableItem[] originalItems = {
            new MutableItem("Item A"), new MutableItem("Item B"), new MutableItem("Item C")
        };
        MutableItem[] subItems = Arrays.copyOfRange(originalItems, 0, 2);

        System.out.println("\nOriginal items before modification: " + Arrays.toString(originalItems));
        System.out.println("Sub items before modification: " + Arrays.toString(subItems));

        // Modify an object through the subItems array
        subItems[0].name = "Modified Item A";

        System.out.println("Original items after modification: " + Arrays.toString(originalItems));
        System.out.println("Sub items after modification: " + Arrays.toString(subItems));
        // Expected output:
        // Original items before modification: [Item A, Item B, Item C]
        // Sub items before modification: [Item A, Item B]
        // Original items after modification: [Modified Item A, Item B, Item C]
        // Sub items after modification: [Modified Item A, Item B]
        // This clearly shows that originalItems[0] was also modified because subItems[0] holds a reference to the same object.
    }
}
```

#### Example 3: Handling Edge Cases and Exceptions

```java
import java.util.Arrays;

public class CopyOfRangeEdgeCases {
    public static void main(String[] args) {
        double[] data = {1.1, 2.2, 3.3, 4.4, 5.5};

        // Case 1: Empty range (from == to)
        double[] emptyArray = Arrays.copyOfRange(data, 2, 2);
        System.out.println("Empty array (from 2 to 2): " + Arrays.toString(emptyArray));
        // Expected output: []

        // Case 2: from > to (throws IllegalArgumentException)
        try {
            double[] invalidRange = Arrays.copyOfRange(data, 3, 1);
            System.out.println("Invalid range: " + Arrays.toString(invalidRange));
        } catch (IllegalArgumentException e) {
            System.out.println("Caught expected exception for from > to: " + e.getMessage());
            // Expected output: Caught expected exception for from > to: 3 > 1
        }

        // Case 3: from or to out of bounds (throws ArrayIndexOutOfBoundsException)
        try {
            double[] outOfBoundsFrom = Arrays.copyOfRange(data, -1, 2);
            System.out.println("Out of bounds 'from': " + Arrays.toString(outOfBoundsFrom));
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("Caught expected exception for 'from' out of bounds: " + e.getMessage());
            // Expected output: Caught expected exception for 'from' out of bounds: -1
        }

        try {
            double[] outOfBoundsTo = Arrays.copyOfRange(data, 0, data.length + 1);
            System.out.println("Out of bounds 'to': " + Arrays.toString(outOfBoundsTo));
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("Caught expected exception for 'to' out of bounds: " + e.getMessage());
            // Expected output: Caught expected exception for 'to' out of bounds: 6
        }
    }
}
```

## Method 2: Using `System.arraycopy()`

**Personas:** üöÄ Speed Seeker, ‚ö° Legacy Maintainer, üèóÔ∏è Architecture Builder (for fine-grained control)

`System.arraycopy()` is a native method provided by the Java platform for copying a contiguous block of elements from one array to another. It's a low-level, highly optimized operation, often used when maximum performance is required or when working with older Java codebases.

### How it Works

The method signature is:
`public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length);`

1.  `src`: The source array.
2.  `srcPos`: The starting position in the source array.
3.  `dest`: The destination array.
4.  `destPos`: The starting position in the destination array.
5.  `length`: The number of array elements to be copied.

Unlike `Arrays.copyOfRange()`, `System.arraycopy()` does not create the destination array for you. You must first create an array of the correct type and size to hold the copied elements.

### Advantages

*   **Performance:** Being a native method, it's often the fastest way to copy array elements, especially for large arrays of primitive types. It's implemented in highly optimized C/C++ code.
*   **Flexibility:** Allows copying parts of an array into *any* position within another *pre-existing* array, not just creating a new sub-array. This can be useful for in-place modifications or merging.
*   **No Intermediate Objects:** Doesn't create any intermediate objects, which can be beneficial in memory-constrained environments.

### Disadvantages

*   **Manual Destination Array Creation:** You must explicitly create the destination array and ensure it's large enough. This adds a step and potential for `ArrayIndexOutOfBoundsException` if not sized correctly.
*   **Less Convenient:** More verbose than `Arrays.copyOfRange()` for simple sub-array extraction.
*   **Error Prone:** Incorrect `srcPos`, `destPos`, or `length` can lead to `ArrayIndexOutOfBoundsException` or `ArrayStoreException` (if types are incompatible), and these errors might be harder to debug than those from `copyOfRange()`.
*   **Shallow Copy for Objects:** Like `Arrays.copyOfRange()`, it performs a shallow copy for object arrays.

### Code Examples

#### Example 1: Basic Integer Array Slicing

```java
public class ArrayCopyIntExample {
    public static void main(String[] args) {
        int[] originalArray = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};

        int startIndex = 3; // Start copying from index 3 (value 40)
        int length = 4;     // Copy 4 elements (40, 50, 60, 70)

        // 1. Calculate the size of the new sub-array
        // Note: For a range from 'startIndex' to 'endIndex' (exclusive), length = endIndex - startIndex
        // Here, we explicitly define the length.
        int[] subArray = new int[length];

        // 2. Perform the copy
        // src: originalArray
        // srcPos: startIndex (3)
        // dest: subArray
        // destPos: 0 (start filling the subArray from its beginning)
        // length: length (4)
        System.arraycopy(originalArray, startIndex, subArray, 0, length);

        System.out.print("Sub-array using System.arraycopy: [");
        for (int i = 0; i < subArray.length; i++) {
            System.out.print(subArray[i]);
            if (i < subArray.length - 1) {
                System.out.print(", ");
            }
        }
        System.out.println("]");
        // Expected output: [40, 50, 60, 70]
    }
}
```

#### Example 2: String Array Slicing (Object Array)

```java
import java.util.Arrays;

public class ArrayCopyStringExample {
    public static void main(String[] args) {
        String[] planets = {"Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"};

        int startIndex = 2; // Start from "Earth"
        int endIndex = 5;   // Copy up to "Jupiter" (exclusive)
        int length = endIndex - startIndex; // Length will be 3 (Earth, Mars, Jupiter)

        String[] innerPlanets = new String[length];

        System.arraycopy(planets, startIndex, innerPlanets, 0, length);
        System.out.println("Inner planets: " + Arrays.toString(innerPlanets));
        // Expected output: [Earth, Mars, Jupiter]

        // Example of copying to a specific position in an existing array
        String[] destinationArray = new String[5];
        Arrays.fill(destinationArray, "EMPTY"); // Initialize with placeholder

        // Copy "Mars", "Jupiter" from original array starting at index 3
        // into destinationArray starting at index 1
        System.arraycopy(planets, 3, destinationArray, 1, 2);
        System.out.println("Destination array after partial copy: " + Arrays.toString(destinationArray));
        // Expected output: [EMPTY, Mars, Jupiter, EMPTY, EMPTY]
    }
}
```

#### Example 3: Handling Overlapping Copies (In-place Shift)

`System.arraycopy()` can handle overlapping source and destination regions correctly. This is useful for shifting elements within the *same* array.

```java
import java.util.Arrays;

public class ArrayCopyOverlapExample {
    public static void main(String[] args) {
        int[] data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        System.out.println("Original array: " + Arrays.toString(data));

        // Shift elements from index 3 (value 4) to index 0
        // Copy elements 4, 5, 6, 7 to the beginning of the array
        // src: data, srcPos: 3, dest: data, destPos: 0, length: 4
        System.arraycopy(data, 3, data, 0, 4);
        System.out.println("Array after shifting (4 elements from index 3 to 0): " + Arrays.toString(data));
        // Expected output: [4, 5, 6, 7, 5, 6, 7, 8, 9, 10]
        // Note: The original elements 1, 2, 3 are overwritten.
        // The elements 5, 6, 7 are duplicated because they were copied before being overwritten.

        // To shift elements to the right (e.g., insert at beginning), copy from right to left
        int[] data2 = {1, 2, 3, 4, 5};
        System.out.println("\nOriginal array 2: " + Arrays.toString(data2));
        // Shift elements 1, 2, 3 to indices 2, 3, 4
        // src: data2, srcPos: 0, dest: data2, destPos: 2, length: 3
        System.arraycopy(data2, 0, data2, 2, 3);
        System.out.println("Array 2 after shifting (3 elements from index 0 to 2): " + Arrays.toString(data2));
        // Expected output: [1, 2, 1, 2, 3]
        // Note: The elements 1, 2 are duplicated.
    }
}
```

## Method 3: Manual Iteration (Looping)

**Personas:** üìö Learning Explorer, ‚ö° Legacy Maintainer, üé® Output Focused (for deep copies or custom logic)

Manual iteration using a `for` loop is the most fundamental way to copy elements from one array to another. While generally less efficient than `Arrays.copyOfRange()` or `System.arraycopy()` for simple slicing, it offers maximum control and is essential for scenarios requiring custom logic during the copy process, such as deep copying objects or transforming elements.

### How it Works

You typically:
1.  Create a new destination array of the desired size.
2.  Use a `for` loop to iterate from the `startIndex` of the original array up to the `endIndex`.
3.  Inside the loop, copy each element from the original array to the corresponding position in the new array.

### Advantages

*   **Maximum Control:** Allows for custom logic during the copy, such as:
    *   **Deep Copying:** If your array contains mutable objects, you can create new instances of those objects in the sub-array.
    *   **Transformation:** You can modify elements as they are copied (e.g., squaring numbers, converting case of strings).
    *   **Filtering:** You can conditionally copy elements based on certain criteria.
*   **Understandability:** For beginners, the explicit loop might be easier to grasp than native methods.
*   **No External Dependencies:** Doesn't rely on specific utility methods, just basic language constructs.

### Disadvantages

*   **Performance:** Generally slower than `Arrays.copyOfRange()` or `System.arraycopy()` due to Java's loop overhead and lack of native optimization.
*   **Verbosity:** Requires more lines of code for a simple slice.
*   **Error Prone:** More opportunities for off-by-one errors in loop conditions or index calculations.
*   **Manual Array Creation:** Like `System.arraycopy()`, you must manually create the destination array.

### Code Examples

#### Example 1: Basic Integer Array Slicing with Loop

```java
import java.util.Arrays;

public class ManualLoopIntExample {
    public static void main(String[] args) {
        int[] originalArray = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};

        int startIndex = 2; // Inclusive
        int endIndex = 7;   // Exclusive (copy up to index 6)

        // Calculate the length of the sub-array
        int subArrayLength = endIndex - startIndex;

        // Ensure valid range
        if (subArrayLength < 0 || startIndex < 0 || endIndex > originalArray.length) {
            System.err.println("Invalid range specified.");
            return;
        }

        int[] subArray = new int[subArrayLength];

        for (int i = 0; i < subArrayLength; i++) {
            subArray[i] = originalArray[startIndex + i];
        }

        System.out.println("Sub-array using manual loop: " + Arrays.toString(subArray));
        // Expected output: [30, 40, 50, 60, 70]
    }
}
```

#### Example 2: Deep Copying Objects with Manual Loop

This is where manual iteration shines. If your array contains mutable objects and you want the sub-array to have completely independent copies of these objects, you must perform a deep copy.

```java
import java.util.Arrays;

public class ManualLoopDeepCopyExample {

    static class User implements Cloneable {
        String name;
        int age;

        User(String name, int age) {
            this.name = name;
            this.age = age;
        }

        // Implement clone for deep copying (or use a copy constructor)
        @Override
        protected Object clone() throws CloneNotSupportedException {
            return super.clone(); // Shallow copy of primitives, but creates new User object
        }

        // Or a copy constructor for better practice
        User(User other) {
            this.name = other.name;
            this.age = other.age;
        }

        @Override
        public String toString() {
            return "User{name='" + name + "', age=" + age + '}';
        }
    }

    public static void main(String[] args) {
        User[] originalUsers = {
            new User("Alice", 30),
            new User("Bob", 24),
            new User("Charlie", 35),
            new User("David", 29)
        };

        int startIndex = 1;
        int endIndex = 3; // Copy Bob and Charlie
        int subArrayLength = endIndex - startIndex;

        User[] subUsers = new User[subArrayLength];

        for (int i = 0; i < subArrayLength; i++) {
            // Deep copy using copy constructor
            subUsers[i] = new User(originalUsers[startIndex + i]);
            // Or using clone() if implemented:
            // try {
            //     subUsers[i] = (User) originalUsers[startIndex + i].clone();
            // } catch (CloneNotSupportedException e) {
            //     e.printStackTrace();
            // }
        }

        System.out.println("Original users before modification: " + Arrays.toString(originalUsers));
        System.out.println("Sub users before modification: " + Arrays.toString(subUsers));

        // Modify an object in the sub-array
        subUsers[0].name = "Bobby"; // This is 'Bob' in the sub-array
        subUsers[0].age = 25;

        System.out.println("\nOriginal users after modification: " + Arrays.toString(originalUsers));
        System.out.println("Sub users after modification: " + Arrays.toString(subUsers));
        // Expected output shows that modifying subUsers[0] does NOT affect originalUsers[1]
        // Original users after modification: [User{name='Alice', age=30}, User{name='Bob', age=24}, User{name='Charlie', age=35}, User{name='David', age=29}]
        // Sub users after modification: [User{name='Bobby', age=25}, User{name='Charlie', age=35}]
    }
}
```

#### Example 3: Transforming Elements During Copy

```java
import java.util.Arrays;

public class ManualLoopTransformExample {
    public static void main(String[] args) {
        String[] words = {"hello", "world", "java", "programming"};

        int startIndex = 1;
        int endIndex = 3; // Copy "world", "java"
        int subArrayLength = endIndex - startIndex;

        String[] upperCaseWords = new String[subArrayLength];

        for (int i = 0; i < subArrayLength; i++) {
            upperCaseWords[i] = words[startIndex + i].toUpperCase(); // Transform to uppercase
        }

        System.out.println("Original words: " + Arrays.toString(words));
        System.out.println("Uppercase sub-array: " + Arrays.toString(upperCaseWords));
        // Expected output:
        // Original words: [hello, world, java, programming]
        // Uppercase sub-array: [WORLD, JAVA]
    }
}
```

## Method 4: Using Streams (Java 8+)

**Personas:** üìö Learning Explorer, üèóÔ∏è Architecture Builder, üé® Output Focused

Java 8 introduced the Streams API, which provides a powerful and expressive way to process collections of data. While not always the most performant for simple array slicing compared to `Arrays.copyOfRange()` or `System.arraycopy()`, it offers a functional approach that can be highly readable and composable, especially when combined with other stream operations like filtering, mapping, or reducing.

### How it Works

To get a part of an array using streams, you typically:
1.  Convert the array into a `Stream` (e.g., `Arrays.stream(array)` for primitives or `Stream.of(array)` for objects).
2.  Use `skip(n)` to discard the first `n` elements (equivalent to the `startIndex`).
3.  Use `limit(m)` to take the next `m` elements (where `m` is the desired length of the sub-array).
4.  Collect the results back into an array using `toArray()`.

### Advantages

*   **Readability and Expressiveness:** The fluent API makes the intent clear, especially for complex transformations.
*   **Composability:** Easily chain multiple operations (filter, map, sort, etc.) before or after slicing.
*   **Parallel Processing:** Streams can be easily parallelized (`.parallelStream()`) for potential performance gains on multi-core processors, though this has overhead and isn't always faster for small arrays.
*   **Functional Style:** Aligns with modern functional programming paradigms.

### Disadvantages

*   **Performance Overhead:** For simple slicing, streams can be slower than `Arrays.copyOfRange()` or `System.arraycopy()` due to the overhead of creating stream objects and lambda expressions.
*   **New Array Creation:** Always creates a new array.
*   **Shallow Copy for Objects:** Like other methods, it performs a shallow copy for object arrays unless you explicitly map to new object instances.
*   **Primitive vs. Object Streams:** Requires different approaches for primitive arrays (`IntStream`, `LongStream`, `DoubleStream`) versus object arrays (`Stream<T>`).

### Code Examples

#### Example 1: Integer Array Slicing with `IntStream`

```java
import java.util.Arrays;
import java.util.stream.IntStream;

public class StreamIntExample {
    public static void main(String[] args) {
        int[] numbers = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};

        int startIndex = 3; // Inclusive
        int endIndex = 7;   // Exclusive (copy up to index 6)
        int length = endIndex - startIndex;

        // Using IntStream.range to generate indices, then map to values
        int[] subArray1 = IntStream.range(startIndex, endIndex)
                                   .map(i -> numbers[i])
                                   .toArray();
        System.out.println("Sub-array (IntStream.range): " + Arrays.toString(subArray1));
        // Expected output: [40, 50, 60, 70]

        // Using Arrays.stream for primitive arrays, then skip and limit
        int[] subArray2 = Arrays.stream(numbers)
                                .skip(startIndex)
                                .limit(length)
                                .toArray();
        System.out.println("Sub-array (Arrays.stream + skip/limit): " + Arrays.toString(subArray2));
        // Expected output: [40, 50, 60, 70]
    }
}
```

#### Example 2: String Array Slicing with `Stream.of()`

```java
import java.util.Arrays;
import java.util.stream.Stream;

public class StreamStringExample {
    public static void main(String[] args) {
        String[] colors = {"red", "green", "blue", "yellow", "purple", "orange"};

        int startIndex = 1; // Inclusive
        int endIndex = 4;   // Exclusive (copy up to index 3)
        int length = endIndex - startIndex;

        // For object arrays, use Stream.of() or Arrays.stream()
        String[] subArray = Stream.of(colors)
                                  .skip(startIndex)
                                  .limit(length)
                                  .toArray(String[]::new); // Supplier for array constructor
        System.out.println("Sub-array (Stream.of + skip/limit): " + Arrays.toString(subArray));
        // Expected output: [green, blue, yellow]
    }
}
```

#### Example 3: Combining Slicing with Transformations

```java
import java.util.Arrays;
import java.util.stream.Stream;

public class StreamTransformExample {
    public static void main(String[] args) {
        String[] names = {"alice", "bob", "charlie", "david", "eve"};

        int startIndex = 1; // Start from "bob"
        int endIndex = 4;   // End before "eve" (copy "bob", "charlie", "david")
        int length = endIndex - startIndex;

        // Get a sub-array, then transform elements to uppercase
        String[] transformedSubArray = Stream.of(names)
                                             .skip(startIndex)
                                             .limit(length)
                                             .map(String::toUpperCase) // Transform each element
                                             .toArray(String[]::new);

        System.out.println("Original names: " + Arrays.toString(names));
        System.out.println("Transformed sub-array: " + Arrays.toString(transformedSubArray));
        // Expected output:
        // Original names: [alice, bob, charlie, david, eve]
        // Transformed sub-array: [BOB, CHARLIE, DAVID]
    }
}
```

#### Example 4: Deep Copying Objects with Streams (More Complex)

While streams perform shallow copies by default, you can achieve a deep copy by mapping each object to a new, cloned instance.

```java
import java.util.Arrays;
import java.util.stream.Stream;

public class StreamDeepCopyExample {

    static class Product implements Cloneable {
        String id;
        double price;

        Product(String id, double price) {
            this.id = id;
            this.price = price;
        }

        @Override
        protected Object clone() throws CloneNotSupportedException {
            return super.clone(); // Shallow copy of primitives, but new Product object
        }

        Product(Product other) { // Copy constructor
            this.id = other.id;
            this.price = other.price;
        }

        @Override
        public String toString() {
            return "Product{id='" + id + "', price=" + price + '}';
        }
    }

    public static void main(String[] args) {
        Product[] originalProducts = {
            new Product("P001", 10.50),
            new Product("P002", 25.00),
            new Product("P003", 5.99),
            new Product("P004", 120.00)
        };

        int startIndex = 1;
        int endIndex = 3; // Copy P002, P003
        int length = endIndex - startIndex;

        Product[] deepCopiedSubArray = Stream.of(originalProducts)
                                             .skip(startIndex)
                                             .limit(length)
                                             .map(Product::new) // Use copy constructor for deep copy
                                             // Or if using clone(): .map(p -> { try { return (Product) p.clone(); } catch (CloneNotSupportedException e) { throw new RuntimeException(e); } })
                                             .toArray(Product[]::new);

        System.out.println("Original products before modification: " + Arrays.toString(originalProducts));
        System.out.println("Deep-copied sub-array before modification: " + Arrays.toString(deepCopiedSubArray));

        // Modify an object in the deep-copied sub-array
        deepCopiedSubArray[0].price = 27.50; // This is 'P002' in the sub-array

        System.out.println("\nOriginal products after modification: " + Arrays.toString(originalProducts));
        System.out.println("Deep-copied sub-array after modification: " + Arrays.toString(deepCopiedSubArray));
        // Expected output shows originalProducts[1] (P002) is NOT affected by the change in deepCopiedSubArray[0].
    }
}
```

## Method 5: Using `ArrayList.subList()` (for `List`s)

**Personas:** üìö Learning Explorer, üîß Problem Solver, üèóÔ∏è Architecture Builder (when working with `List`s)

While the original question specifically asks about arrays, it's very common in Java to work with `List`s, especially `ArrayList`s, which are backed by arrays. If your data is already in an `ArrayList` or can be easily converted, `ArrayList.subList()` provides a powerful and efficient way to get a "view" of a portion of the list.

### How it Works

The `subList(int fromIndex, int toIndex)` method of `ArrayList` returns a *view* of the portion of this list between the specified `fromIndex`, inclusive, and `toIndex`, exclusive. The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list, and vice-versa. Structural changes in the original list (e.g., adding or removing elements) will make the behavior of the sub-list undefined.

### Advantages

*   **No New Array Creation (View):** The primary advantage is that it doesn't create a new array or copy elements. It provides a lightweight view, which is very memory-efficient.
*   **Modifiable View:** You can modify elements within the sub-list, and these changes will be reflected in the original list.
*   **List Interface:** The returned object is a `List`, allowing you to use all `List` interface methods on the sub-portion.
*   **Convenience:** Simple and readable syntax.

### Disadvantages

*   **View, Not Copy:** This is crucial. If you need an independent copy, you must explicitly create a new `ArrayList` from the sub-list (e.g., `new ArrayList<>(originalList.subList(from, to))`).
*   **Structural Modification Issues:** If the original list is structurally modified (elements added/removed) after `subList()` is called, the sub-list becomes invalid and subsequent operations on it will throw a `ConcurrentModificationException`.
*   **Not for Primitive Arrays:** This method is specifically for `List`s of objects, not primitive arrays. You'd need to convert a primitive array to a `List<WrapperType>` first.
*   **Performance for Conversion:** If you start with a primitive array and convert it to an `ArrayList` just to use `subList()`, the initial conversion overhead might negate the benefits.

### Code Examples

#### Example 1: Basic `ArrayList.subList()` Usage

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class ArrayListSubListExample {
    public static void main(String[] args) {
        List<String> cities = new ArrayList<>(Arrays.asList(
            "London", "Paris", "Rome", "Berlin", "Madrid", "Lisbon", "Amsterdam"
        ));

        int fromIndex = 2; // Inclusive (Rome)
        int toIndex = 5;   // Exclusive (Berlin, Madrid, Lisbon)

        // Get a sub-list (view)
        List<String> europeanCapitals = cities.subList(fromIndex, toIndex);
        System.out.println("Original list: " + cities);
        System.out.println("Sub-list (view): " + europeanCapitals);
        // Expected output:
        // Original list: [London, Paris, Rome, Berlin, Madrid, Lisbon, Amsterdam]
        // Sub-list (view): [Rome, Berlin, Madrid]
    }
}
```

#### Example 2: Modifying Elements Through the Sub-list

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class SubListModificationExample {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
        System.out.println("Original list before modification: " + numbers);

        List<Integer> middlePart = numbers.subList(3, 7); // Elements at index 3, 4, 5, 6 (4, 5, 6, 7)
        System.out.println("Sub-list before modification: " + middlePart);

        // Modify an element in the sub-list
        middlePart.set(0, 400); // Changes the element at index 0 of sub-list, which is index 3 of original list
        middlePart.add(99);     // Adds an element to the sub-list, which also adds to the original list

        System.out.println("Sub-list after modification: " + middlePart);
        System.out.println("Original list after modification: " + numbers);
        // Expected output:
        // Original list before modification: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        // Sub-list before modification: [4, 5, 6, 7]
        // Sub-list after modification: [400, 5, 6, 7, 99]
        // Original list after modification: [1, 2, 3, 400, 5, 6, 7, 99, 8, 9, 10]
        // Note: The add operation on the sub-list structurally modified the original list.
    }
}
```

#### Example 3: Creating an Independent Copy from a Sub-list

To avoid the `ConcurrentModificationException` and have an independent list, create a new `ArrayList` from the sub-list.

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class SubListIndependentCopyExample {
    public static void main(String[] args) {
        List<Character> alphabet = new ArrayList<>(Arrays.asList(
            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'
        ));
        System.out.println("Original list: " + alphabet);

        // Create an independent copy of the sub-list
        List<Character> middleLetters = new ArrayList<>(alphabet.subList(2, 6)); // c, d, e, f
        System.out.println("Independent copy of sub-list: " + middleLetters);

        // Modify the original list structurally
        alphabet.add(0, 'Z'); // Add an element at the beginning
        System.out.println("Original list after structural modification: " + alphabet);

        // The independent copy remains unaffected and valid
        middleLetters.set(0, 'C'); // Modify the copy
        System.out.println("Independent copy after its own modification: " + middleLetters);

        // Try to access the original sub-list view (would throw ConcurrentModificationException)
        // List<Character> invalidSubList = alphabet.subList(2, 6); // This would be invalid if alphabet was modified after its creation
        // System.out.println(invalidSubList); // Would likely fail if 'alphabet' was modified structurally *after* 'invalidSubList' was created.
        // In this example, 'middleLetters' was created from a *snapshot* of 'alphabet.subList(2,6)', so it's safe.
    }
}
```

## Performance Comparison

When choosing a method to get a part of an array in Java, performance is often a key consideration. The "best" method can depend on array size, type (primitive vs. object), and whether you need a new array or a view.

Here's a comparison of the discussed methods:

| Feature / Method        | `Arrays.copyOfRange()`                               | `System.arraycopy()`                                   | Manual Loop (`for`)                                    | Streams (Java 8+)                                      | `ArrayList.subList()` (for `List`s)                      |
| :---------------------- | :--------------------------------------------------- | :----------------------------------------------------- | :----------------------------------------------------- | :----------------------------------------------------- | :------------------------------------------------------- |
| **Primary Use Case**    | General-purpose array slicing (new array)            | High-performance copy, in-place ops (new/existing array) | Custom logic, deep copy, transformation (new array)    | Functional slicing, chaining ops (new array)           | View of a `List` portion (no new array)                  |
| **Performance**         | **Excellent** (internally uses `System.arraycopy()`) | **Fastest** (native method)                            | **Slowest** (Java loop overhead)                       | **Good** (some overhead, can be parallelized)          | **N/A** (view, not copy; conversion overhead if from array) |
| **Memory Usage**        | Creates new array                                    | Creates new array (must be pre-allocated)              | Creates new array (must be pre-allocated)              | Creates new array + stream objects                     | No new array (view), but `ArrayList` itself uses memory |
| **Readability**         | **High** (clear intent)                              | Medium (more parameters)                               | Medium (explicit loop)                                 | High (fluent API, functional)                          | High (clear intent)                                      |
| **Flexibility**         | Medium (fixed to new array)                          | **High** (copy to any position, in-place)              | **Highest** (custom logic, deep copy, transform)       | High (chainable operations)                            | Medium (view, not independent copy)                      |
| **Error Handling**      | Throws `IllegalArgumentException`, `ArrayIndexOutOfBoundsException` | Throws `ArrayIndexOutOfBoundsException`, `ArrayStoreException` | Manual error handling needed                           | `IndexOutOfBoundsException` (if `skip`/`limit` invalid) | Throws `IndexOutOfBoundsException`, `ConcurrentModificationException` |
| **Primitive Arrays**    | Yes                                                  | Yes                                                    | Yes                                                    | Yes (`IntStream`, `Arrays.stream()`)                   | No (requires boxing/unboxing to `List<Wrapper>`)         |
| **Object Arrays**       | Yes (shallow copy)                                   | Yes (shallow copy)                                     | Yes (can do