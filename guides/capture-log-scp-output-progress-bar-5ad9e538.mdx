---
title: "Capture and Log SCP Output Including Progress Bar"
slug: "capture-log-scp-output-progress-bar"
category: "system-devops"
subcategory: "shell"
description: "Learn how to capture the full output of an SCP command, including the progress bar, for logging and monitoring purposes."
tags: ["scp","logging","shell","bash","linux","scripting"]
difficulty: "intermediate"
readTime: 7
lastUpdated: "2025-09-22T16:16:54.222Z"
featured: false
---

# Capture and Log SCP Output Including Progress Bar

When running `scp` commands within scripts, capturing its full output, especially the dynamic progress bar, can be challenging. Standard redirection methods often cause `scp` to suppress the progress bar because it detects that its output is not going to an interactive terminal. This guide explores various methods to effectively capture and log `scp` output, including the progress bar, and how to check for command success.

## Quick Answer

To capture the `scp` progress bar and full output to a log file, use the `script` command to simulate a terminal environment.

```bash
script -q -c "scp server:/path/to/file /tmp/" > scp_log.txt
```

This command tricks `scp` into believing it's running in an interactive terminal, allowing it to print the progress bar, which is then captured by `script` and redirected to `scp_log.txt`.

## Choose Your Method

The best method for capturing `scp` output depends on whether you need the progress bar, just the success/failure status, or verbose logging for debugging.

```mermaid
graph TD
    A[Start] --> B{Need SCP Progress Bar in Log?};
    B -- Yes --> C[Use `script` command];
    C --> D[Example: `script -q -c "scp source dest" > log.txt`];
    B -- No --> E{Need only Success/Failure Status?};
    E -- Yes --> F[Check `scp` exit code];
    F --> G[Example: `scp source dest && echo "Success"`];
    E -- No --> H{Need Verbose Output for Debugging?};
    H -- Yes --> I[Use `scp -v` and redirect stderr];
    I --> J[Example: `scp -v source dest 2> log.txt`];
    D --> K[End];
    G --> K;
    J --> K;
```

## Table of Contents
1. Quick Answer
2. Choose Your Method
3. Capturing Progress Bar with `script`
4. Checking SCP Success with Exit Codes
5. Verbose Logging for Debugging
6. Combining `script` with `tee` for Real-time Output and Logging
7. Common Problems and Solutions
8. Summary

## Capturing Progress Bar with `script`

The `scp` command, like many interactive tools, behaves differently when its output is redirected. It often suppresses dynamic elements like progress bars when it detects that it's not writing to a TTY (Teletypewriter) or terminal. The `script` command can simulate a terminal environment, allowing `scp` to output its progress bar, which `script` then captures.

### How it Works

The `script` command records everything printed to the terminal, including control codes, into a file. By running `scp` within `script`, you effectively "trick" `scp` into displaying its progress bar, and `script` captures this output.

```bash
script -q -c "scp server:/file /tmp/" > /tmp/test.txt
```

- `-q`: (quiet mode) Suppresses the "Script started/ended" messages.
- `-c "command"`: Executes the specified command within the `script` session.

**Example Output in `/tmp/test.txt`:**

```output
file    0%    0     0.0KB/s   --:-- ETA
file   18%   11MB  11.2MB/s   00:04 ETA
file   36%   22MB  11.2MB/s   00:03 ETA
file   54%   34MB  11.2MB/s   00:02 ETA
file   73%   45MB  11.2MB/s   00:01 ETA
file   91%   56MB  11.2MB/s   00:00 ETA
file  100%   61MB  10.2MB/s   00:06
```

This method is ideal when you need a complete record of the `scp` operation, including the visual progress, for auditing or detailed logging.

## Checking SCP Success with Exit Codes

If you don't need the detailed progress bar and are primarily interested in whether the `scp` operation succeeded or failed, checking its exit code is the most robust and straightforward method.

### How it Works

Standard Unix/Linux commands, including `scp`, return an exit code upon completion:
- `0`: Indicates success.
- `>0`: Indicates an error occurred.

You can use shell constructs like `&&` (logical AND) and `||` (logical OR) to execute commands conditionally based on the `scp` command's success.

```bash
scp myfile user@host.com:. && echo "SCP successful!" >> scp_status.log || echo "SCP failed!" >> scp_status.log
```

- `scp myfile user@host.com:.`: Executes the `scp` command.
- `&& echo "SCP successful!" >> scp_status.log`: If `scp` succeeds (exit code 0), this command is executed, logging a success message.
- `|| echo "SCP failed!" >> scp_status.log`: If `scp` fails (exit code >0), this command is executed, logging a failure message.

**Example:**

```bash
# Successful transfer
scp local_file.txt user@remote_host:/tmp/ && echo "local_file.txt copied successfully!" >> transfer.log

# Failed transfer (e.g., wrong path, permissions)
scp non_existent_file.txt user@remote_host:/tmp/ && echo "non_existent_file.txt copied successfully!" >> transfer.log || echo "Failed to copy non_existent_file.txt" >> transfer.log
```

**`transfer.log` after both commands:**

```output
local_file.txt copied successfully!
Failed to copy non_existent_file.txt
```

This approach is lightweight and perfect for automated scripts where you just need to know the outcome of the transfer.

## Verbose Logging for Debugging

For troubleshooting or when you need more detailed information about the `scp` process than just the progress bar or success status, the verbose option (`-v`) is invaluable.

### How it Works

The `-v` flag tells `scp` to print debugging messages about its progress, including connection details, authentication attempts, and file transfer specifics. This output is typically sent to `stderr` (standard error).

To capture this verbose output, you need to redirect `stderr` to a file.

```bash
scp -v -rC root@host:/path/to/directory . 2> copy.log
```

- `-v`: Enables verbose mode.
- `-r`: Recursively copies directories.
- `-C`: Enables compression.
- `2> copy.log`: Redirects `stderr` (file descriptor 2) to `copy.log`.

**Example `copy.log` content (abbreviated):**

```output
Executing: program /usr/bin/ssh -v -x -oFallBackToRsh=no -oProtocol=2 -oBatchMode=yes -l root host -p 22 scp -v -r -d -t /path/to/directory
debug1: Reading configuration data /etc/ssh/ssh_config
debug1: Connecting to host [IP_ADDRESS] port 22.
debug1: Connection established.
debug1: identity file /root/.ssh/id_rsa type 1
debug1: Authenticating to host [IP_ADDRESS]:22 as 'root'
debug1: SSH2_MSG_SERVICE_REQUEST sent
debug1: SSH2_MSG_SERVICE_ACCEPT received
debug1: SSH2_MSG_KEXINIT sent
debug1: SSH2_MSG_KEXINIT received
...
debug1: Sending command: scp -v -r -d -t /path/to/directory
debug1: client_loop: send disconnect
debug1: channel 0: free: client-session, nchannels 1
debug1: fd 0 clearing close-on-exec
debug1: fd 1 clearing close-on-exec
debug1: fd 2 clearing close-on-exec
debug1: Transferred: stdin 0, stdout 0, stderr 256 bytes in 0.0 seconds
debug1: Exit status 0
```

You can then parse this log file for specific information, such as the number of files copied:

```bash
grep "file" copy.log | wc -l
```

This method is particularly useful for diagnosing connection issues, authentication problems, or unexpected transfer behaviors.

## Combining `script` with `tee` for Real-time Output and Logging

Sometimes you need both: the `scp` progress bar displayed on the terminal *and* captured in a log file. The `tee` command allows you to achieve this by splitting the output stream.

### How it Works

`tee` reads standard input and writes it to both standard output (which goes to your terminal) and one or more files. By piping the output of `script` to `tee`, you can view the progress in real-time while simultaneously logging it.

```bash
script -q -c "scp server:/file /tmp/" | tee scp.log
```

- `script -q -c "scp server:/file /tmp/"`: Executes `scp` in a simulated terminal and captures its output.
- `| tee scp.log`: Pipes the captured output to `tee`, which then prints it to the console and saves it to `scp.log`.

**Example:**

When you run the command, you will see the progress bar updating in your terminal:

```output
file    0%    0     0.0KB/s   --:-- ETA
file   18%   11MB  11.2MB/s   00:04 ETA
...
file  100%   61MB  10.2MB/s   00:06
```

And `scp.log` will contain the same output:

```output
file    0%    0     0.0KB/s   --:-- ETA
file   18%   11MB  11.2MB/s   00:04 ETA
...
file  100%   61MB  10.2MB/s   00:06
```

This method provides the best of both worlds for interactive monitoring and persistent logging.

## Common Problems and Solutions

### Problem 1: `script` command not found or `-c` option missing.
Some older or minimal systems might not have `script` installed by default, or its version might not support the `-c` option.

**Solution:**
- **Install `util-linux`:** On most Linux distributions, `script` is part of the `util-linux` package.
  ```bash
  # Debian/Ubuntu
  sudo apt-get install util-linux
  # CentOS/RHEL
  sudo yum install util-linux
  ```
- **Alternative for older `script`:** If `-c` is not supported, you can run `script` interactively and then execute `scp`. This is less suitable for automation.
  ```bash
  script -q my_session.log
  scp server:/file /tmp/
  exit
  ```

### Problem 2: `script` command output includes control characters.
The output from `script` might contain ANSI escape codes or other control characters that make the log file difficult to read, especially if you're viewing it with a basic text editor.

**Solution:**
- **Filter control characters:** Use `sed` or `col` to remove these characters if they are problematic for your log parsing.
  ```bash
  script -q -c "scp server:/file /tmp/" | sed 's/\x1b\[[0-9;]*[a-zA-Z]//g' > scp_clean_log.txt
  # Or using col -b (backspace processing)
  script -q -c "scp server:/file /tmp/" | col -b > scp_clean_log.txt
  ```
  Note: `sed` command removes most common ANSI escape codes. `col -b` is good for removing backspace characters often used in progress bars.

### Problem 3: `scp` command hangs or requires password interactively.
If `scp` requires a password and you're running it in a script, it will hang waiting for input.

**Solution:**
- **Use SSH keys:** Configure passwordless SSH authentication using SSH keys. This is the most secure and recommended approach for automation.
- **`sshpass` (use with caution):** For non-interactive password entry, `sshpass` can be used, but it's generally discouraged due to security risks.
  ```bash
  sshpass -p 'your_password' scp myfile user@host.com:.
  ```
  **Warning:** Storing passwords in scripts is a security risk. Prefer SSH keys.

### Problem 4: `script` command creates a subshell, affecting script flow.
As noted in some answers, `script -c "command"` runs the command in a subshell. If your script relies on variables or environment changes from `command` to persist, this won't happen. Also, the parent script might not wait for the subshell to fully complete before moving on, especially if backgrounding.

**Solution:**
- **Ensure sequential execution:** If `script` is used, ensure the parent script explicitly waits for it. The `script -c "command"` form generally waits, but if you're doing complex backgrounding, be careful.
- **Handle exit codes:** Always check the exit code of the `script` command itself, not just the `scp` command inside it, if you need to ensure the entire operation completed successfully.
  ```bash
  script -q -c "scp server:/file /tmp/" > scp_log.txt
  if [ $? -eq 0 ]; then
      echo "SCP and logging successful."
  else
      echo "SCP or logging failed."
  fi
  ```

## Summary

Capturing `scp` output, especially the dynamic progress bar, requires understanding how `scp` interacts with its terminal environment.

-   **For capturing the progress bar in a log file:** Use the `script` command (`script -q -c "scp source dest" > log.txt`). This simulates a terminal, allowing `scp` to print its progress, which is then captured.
-   **For checking success/failure:** Rely on `scp`'s exit code (`scp source dest && echo "Success"`). This is the most robust method for automation.
-   **For verbose debugging:** Use the `-v` flag and redirect `stderr` (`scp -v source dest 2> debug.log`).
-   **For real-time display and logging:** Combine `script` with `tee` (`script -q -c "scp source dest" | tee log.txt`).

By choosing the appropriate method, you can effectively monitor and log your `scp` operations to meet your specific scripting and auditing needs.

---

## Image Generation Prompts

**PLACEHOLDER-1:** A clean, modern diagram illustrating the flow of `scp` output when redirected versus when run within `script`. Show `scp` command, then two paths: one with `>` redirection (showing progress bar suppressed), and one with `script -c "scp..." >` (showing progress bar captured). Use simple icons for terminal, log file, and `scp` process.

**PLACEHHER-2:** A simple diagram showing the `scp` command returning an exit code. Illustrate `scp` box, then an arrow pointing to a small box labeled "Exit Code (0 for success, >0 for error)", followed by conditional paths for "Success" and "Failure" leading to different actions (e.g., "Log Success" or "Log Failure").

**PLACEHOLDER-3:** A visual representation of the `tee` command. Show a single input stream (e.g., from `script -c "scp..."`) splitting into two output streams: one going to a "Terminal Display" icon and the other going to a "Log File" icon. Use arrows to clearly indicate data flow.