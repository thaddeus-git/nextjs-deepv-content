---
title: "Create a Bitmap from 2D List using Python PIL"
slug: "create-bitmap-from-2d-list-python-pil"
category: "programming-languages"
subcategory: "python"
description: "Learn how to generate a grayscale bitmap image from a 2D Python list using the Pillow (PIL) library, addressing common pixel manipulation errors."
tags: ["python","pillow","pil","image-processing","bitmap","2d-list"]
difficulty: "beginner"
readTime: 5
lastUpdated: "2025-09-22T16:16:54.227Z"
featured: false
---

# Create a Bitmap from 2D List using Python PIL

When working with image processing in Python, the Pillow library (a friendly fork of PIL) is a powerful tool. This guide will show you how to create a bitmap image from a 2D list of data, specifically focusing on generating a grayscale image where each pixel's intensity corresponds to a value in your list.

## Quick Answer

To create a grayscale bitmap from a 2D list using Pillow, initialize an image in 'L' mode (8-bit pixels, grayscale), then use `img.putpixel()` or `img.load()` to set pixel values. Remember that 'L' mode expects a single integer (0-255) for pixel values, not an RGB tuple.

```python
from PIL import Image

def create_grayscale_bitmap(data_2d, filename="output.bmp"):
    height = len(data_2d)
    width = len(data_2d[0]) if height > 0 else 0

    if not (height > 0 and width > 0):
        print("Input 2D list is empty or malformed.")
        return

    # Create a new grayscale image ('L' mode)
    img = Image.new('L', (width, height), color=0) # Start with black background

    # Load pixels for efficient manipulation
    pixels = img.load()

    # Iterate through the 2D data and set pixel values
    for y in range(height):
        for x in range(width):
            # Ensure value is within 0-255 range for grayscale
            pixel_value = int(max(0, min(255, data_2d[y][x])))
            pixels[x, y] = pixel_value

    img.save(filename)
    print(f"Bitmap saved as {filename}")

# Example 2D list (e.g., representing a gradient)
example_data = [
    [i * 16 + j * 16 for j in range(16)] for i in range(16)
]

create_grayscale_bitmap(example_data, "grayscale_example.bmp")
```

## Working Code Examples

This section provides a complete example of how to convert a 2D list into a grayscale bitmap using Pillow. We'll cover initializing the image, iterating through your data, and saving the result.

### 1. Basic Grayscale Bitmap from 2D List

This example demonstrates the core process of mapping a 2D list of numerical values (0-255) to a grayscale image.

```python
from PIL import Image

def generate_grayscale_image_from_2d_list(data_matrix, output_filename="output_grayscale.bmp"):
    """
    Generates a grayscale bitmap image from a 2D list of numerical data.

    Args:
        data_matrix (list of list of int/float): The 2D list where each inner
                                                 list is a row of pixel values.
                                                 Values should ideally be 0-255.
        output_filename (str): The name of the output bitmap file.
    """
    if not data_matrix or not data_matrix[0]:
        print("Error: Input data_matrix is empty.")
        return

    height = len(data_matrix)
    width = len(data_matrix[0])

    # Create a new image in 'L' mode (8-bit pixels, black and white)
    # 'L' mode expects a single integer value (0-255) for each pixel.
    img = Image.new('L', (width, height))

    # Use img.load() for efficient pixel access
    pixels = img.load()

    for y in range(height):
        for x in range(width):
            # Get the value from the 2D list
            raw_value = data_matrix[y][x]

            # Ensure the value is an integer and within the 0-255 range
            # for grayscale. Clamp values if they exceed this range.
            pixel_intensity = int(max(0, min(255, raw_value)))

            # Set the pixel. For 'L' mode, pixels[x, y] expects an integer.
            pixels[x, y] = pixel_intensity

    img.save(output_filename)
    print(f"Grayscale bitmap '{output_filename}' created successfully.")

# --- Example Usage ---
# Create a sample 2D list (e.g., a simple gradient)
sample_data = []
for i in range(100): # 100 rows
    row = []
    for j in range(150): # 150 columns
        # Create a gradient from top-left to bottom-right
        value = int((i / 99.0 * 127) + (j / 149.0 * 127)) # Scale to 0-255
        row.append(value)
    sample_data.append(row)

generate_grayscale_image_from_2d_list(sample_data, "gradient_grayscale.bmp")

# Another example: a checkerboard pattern
checkerboard_data = []
for i in range(50):
    row = []
    for j in range(50):
        if (i // 10 + j // 10) % 2 == 0:
            row.append(255) # White
        else:
            row.append(0)   # Black
    checkerboard_data.append(row)

generate_grayscale_image_from_2d_list(checkerboard_data, "checkerboard.bmp")
```
![Grayscale Bitmap Example](PLACEHOLDER: Grayscale Bitmap Example - /images/bd07128b-1.webp)

### 2. Creating an RGB Bitmap from 2D List (if data contains color channels)

If your 2D list actually contains tuples representing RGB values (e.g., `[(R,G,B), (R,G,B), ...]`), you would use the 'RGB' mode.

```python
from PIL import Image

def generate_rgb_image_from_2d_list(data_matrix_rgb, output_filename="output_rgb.bmp"):
    """
    Generates an RGB bitmap image from a 2D list where each element is an RGB tuple.

    Args:
        data_matrix_rgb (list of list of tuple): The 2D list where each element
                                                 is an (R, G, B) tuple (0-255).
        output_filename (str): The name of the output bitmap file.
    """
    if not data_matrix_rgb or not data_matrix_rgb[0]:
        print("Error: Input data_matrix_rgb is empty.")
        return

    height = len(data_matrix_rgb)
    width = len(data_matrix_rgb[0])

    # Create a new image in 'RGB' mode
    img = Image.new('RGB', (width, height))
    pixels = img.load()

    for y in range(height):
        for x in range(width):
            # Get the RGB tuple from the 2D list
            r, g, b = data_matrix_rgb[y][x]

            # Ensure values are integers and within 0-255 range
            r = int(max(0, min(255, r)))
            g = int(max(0, min(255, g)))
            b = int(max(0, min(255, b)))

            pixels[x, y] = (r, g, b)

    img.save(output_filename)
    print(f"RGB bitmap '{output_filename}' created successfully.")

# --- Example Usage ---
# Create a sample 2D list of RGB tuples
rgb_data = []
for i in range(50):
    row = []
    for j in range(range(50)):
        r = int(255 * (i / 49.0))
        g = int(255 * (j / 49.0))
        b = int(255 * (1 - (i + j) / 98.0))
        row.append((r, g, b))
    rgb_data.append(row)

generate_rgb_image_from_2d_list(rgb_data, "rgb_gradient.bmp")
```
![RGB Bitmap Example](PLACEHOLDER: RGB Bitmap Example - /images/bd07128b-2.webp)

## Common Problems & Solutions

When working with Pillow and pixel manipulation, especially from raw data, you might encounter a few common issues.

### 1. `TypeError: an integer is required` with `putpixel()`

**Problem:** The original question's code snippet had this error:
```python
img.putpixel((i,j), (255,255,255)) # Error here
```
This happens because the image was created in `'L'` mode: `img = Image.new('L', (100,100), 'white')`.
The `'L'` mode (Luminance) expects a single integer value (0-255) for each pixel, representing its grayscale intensity. You were passing an RGB tuple `(255,255,255)`.

**Solution:**
If your image is in `'L'` mode, pass a single integer for the pixel value:
```python
# For 'L' mode, use a single integer (0-255)
img.putpixel((i, j), 255) # Sets pixel to white (max intensity)
```
If you intend to use RGB colors, create the image in `'RGB'` mode:
```python
img = Image.new('RGB', (100, 100), 'white') # 'white' here is a string, PIL converts it to (255,255,255)
img.putpixel((i, j), (255, 0, 0)) # Sets pixel to red
```

### 2. Performance Issues with `putpixel()` in Loops

**Problem:** While `putpixel()` works, it can be very slow for large images when called inside nested loops.

**Solution:** For better performance, especially with larger images, use `img.load()` to get a pixel access object. This object allows direct pixel manipulation, which is significantly faster.

```python
from PIL import Image

# ... (image creation)
img = Image.new('L', (width, height))
pixels = img.load() # Get the pixel access object

for y in range(height):
    for x in range(width):
        # Set pixel directly using the pixel access object
        pixels[x, y] = your_grayscale_value # your_grayscale_value is an int 0-255
```
The `img.load()` method returns a pixel access object that behaves like a 2D array, allowing you to set `pixels[x, y]` directly. This bypasses the overhead of repeated function calls.

### 3. Incorrect Image Dimensions or Data Mapping

**Problem:** The generated image looks stretched, squashed, or doesn't match the input data.

**Solution:**
*   **Verify Dimensions:** Ensure that `width` and `height` used in `Image.new((width, height))` correctly correspond to the dimensions of your 2D list (`len(data_matrix[0])` for width, `len(data_matrix)` for height).
*   **Correct Indexing:** Remember that Pillow's `putpixel((x, y), ...)` and `pixels[x, y]` use `(column, row)` order, while your 2D list `data_matrix[row][column]` uses `(row, column)` order. Be careful with `x` and `y` indices in your loops.
    ```python
    # Correct mapping: data_matrix[y][x] corresponds to pixels[x, y]
    for y in range(height): # Iterate rows of data_matrix
        for x in range(width): # Iterate columns of data_matrix
            pixels[x, y] = data_matrix[y][x]
    ```

### 4. Values Out of Range (0-255)

**Problem:** Your 2D list contains values outside the 0-255 range, leading to unexpected colors or errors.

**Solution:** Always clamp your pixel values to the valid range before assigning them.

```python
# Assuming 'value' is from your 2D list
clamped_value = int(max(0, min(255, value)))
pixels[x, y] = clamped_value
```
This ensures that any value less than 0 becomes 0 (black) and any value greater than 255 becomes 255 (white for grayscale, or max intensity for a color channel).

## Related: Other Pillow Operations

Once you have your image, Pillow offers many other operations:

*   **Resizing:** `img.resize((new_width, new_height))`
*   **Cropping:** `img.crop((left, upper, right, lower))`
*   **Applying Filters:** `from PIL import ImageFilter; img.filter(ImageFilter.BLUR)`
*   **Drawing Shapes/Text:** Use `ImageDraw` module: `from PIL import ImageDraw; draw = ImageDraw.Draw(img); draw.line(...)`
*   **Converting Modes:** `img.convert('RGB')` or `img.convert('L')` to change between color modes.

These operations can be chained or applied after you've generated your initial bitmap from data.

## Summary

Creating a bitmap image from a 2D list in Python using Pillow is a straightforward process, primarily involving:

1.  **Initializing the Image:** Use `Image.new()` with the correct mode (`'L'` for grayscale, `'RGB'` for color) and dimensions.
2.  **Accessing Pixels:** For efficiency, use `img.load()` to get a pixel access object.
3.  **Mapping Data:** Iterate through your 2D list and assign the corresponding (clamped) pixel values to `pixels[x, y]`. Remember the `(x, y)` vs `(row, column)` indexing.
4.  **Saving the Image:** Use `img.save()` to write the image to a file.

By understanding the image modes and efficient pixel manipulation techniques, you can effectively visualize your 2D data as bitmaps.

---

## Image Generation Prompts

**PLACEHOLDER-1:** A visual representation of a grayscale gradient bitmap image. The image should be 150x100 pixels. It should show a smooth gradient from dark (top-left) to light (bottom-right), illustrating the `gradient_grayscale.bmp` example. Below it, show a 50x50 pixel checkerboard pattern with alternating black and white squares, representing the `checkerboard.bmp` example. The style should be clean and technical.

**PLACEHOLDER-2:** A visual representation of an RGB gradient bitmap image. The image should be 50x50 pixels. It should display a smooth color gradient where red increases from left to right, green increases from top to bottom, and blue decreases from top-left to bottom-right, creating a blend of colors. The style should be clean and technical, similar to a color test pattern.