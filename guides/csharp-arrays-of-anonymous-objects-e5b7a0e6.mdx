---
title: "C# Arrays of Anonymous Objects Explained"
slug: "csharp-arrays-of-anonymous-objects"
category: "programming-languages"
subcategory: "csharp"
description: "Understand how to create and use arrays of anonymous objects in C#, a powerful feature for temporary data structures."
tags: ["c#","anonymous-types","arrays",".net","object-initializers"]
difficulty: "intermediate"
readTime: 7
lastUpdated: "2025-09-22T16:16:54.229Z"
featured: false
---

# C# Arrays of Anonymous Objects Explained

When working with C#, you might encounter code that creates an array of objects using a syntax like `new[] { new { ... } }`. This pattern leverages C# anonymous types and array initializers to create a collection of objects without explicitly defining a class or struct. This guide will demystify this syntax, explain its meaning, and show you how to use it effectively.

## Quick Answer

The expression `new[] { new { Text = "...", Count = ..., Link = "..." } }` in C# creates an array where each element is an **anonymous type**. An anonymous type is a class generated by the compiler on the fly, with properties inferred from the initialization values. This allows you to define lightweight, temporary data structures without formal class declarations.

```csharp
// Example of creating an array of anonymous objects
var dataSource = new[]
{
    new { Text = "Silverlight", Count = 10, Link = "/Tags/Silverlight" },
    new { Text = "IIS 7", Count = 11, Link = "http://iis.net" }
};

// dataSource is now an array of a compiler-generated type
// Each element has Text (string), Count (int), and Link (string) properties.
```

## Concept Explanation: Anonymous Types and Array Initializers

At its core, the code `new[] { new { ... } }` combines two C# features:

1.  **Anonymous Types**: Introduced in C# 3.0, anonymous types allow you to create objects without defining their class explicitly. The compiler infers the type and property names from the initialization. All properties are read-only.
2.  **Array Initializers**: This syntax `new[] { element1, element2, ... }` is a shorthand for creating and populating an array. When used with anonymous types, the compiler infers the common type of all elements in the array.

When you write `new { Text = "Silverlight", Count = 10, Link = "/Tags/Silverlight" }`, the C# compiler internally generates a class that looks something like this:

```csharp
internal sealed class __AnonymousType_0<T1, T2, T3> // Actual name is compiler-generated and complex
{
    public T1 Text { get; }
    public T2 Count { get; }
    public T3 Link { get; }

    // Constructor, Equals, GetHashCode, ToString methods are also generated
}
```

Then, when you create an array of these anonymous types, the compiler ensures that all elements in the array have the *same* anonymous type structure. If you try to mix anonymous types with different property names or types within the same array initializer, you'll get a compile-time error.

![Anonymous Type Creation Flow](PLACEHOLDER: Anonymous Type Creation Flow - /images/2923348e-1.webp)

### Key Characteristics:

*   **Implicitly Typed**: You must use the `var` keyword when declaring a variable of an anonymous type or an array of anonymous types, as their actual type name is not accessible directly.
*   **Read-Only Properties**: All properties of an anonymous type are read-only. You can initialize them, but not change them after creation.
*   **Compiler-Generated**: The actual class definition is created by the compiler at compile time.
*   **Scope**: Anonymous types are typically used for temporary data structures within a method or query, often in LINQ expressions.

## Working Code Examples

Let's explore how to create and use arrays of anonymous objects in various scenarios.

### 1. Basic Array Initialization

This is the most direct way to create an array of anonymous objects.

```csharp
using System;

public class Example
{
    public static void Main(string[] args)
    {
        // Create an array of anonymous objects
        var items = new[]
        {
            new { Name = "Apple", Price = 1.50m, Quantity = 100 },
            new { Name = "Banana", Price = 0.75m, Quantity = 200 },
            new { Name = "Orange", Price = 1.20m, Quantity = 150 }
        };

        Console.WriteLine("Inventory Items:");
        foreach (var item in items)
        {
            Console.WriteLine($"  Name: {item.Name}, Price: {item.Price:C}, Quantity: {item.Quantity}");
        }
    }
}
```

**Output:**

```text
Inventory Items:
  Name: Apple, Price: $1.50, Quantity: 100
  Name: Banana, Price: $0.75, Quantity: 200
  Name: Orange, Price: $1.20, Quantity: 150
```

### 2. Using Variables for Property Values

The property values don't have to be constants; they can be variables or expressions.

```csharp
using System;

public class DynamicExample
{
    public static void Main(string[] args)
    {
        string product1Name = "Laptop";
        decimal product1Price = 1200.00m;
        int product1Stock = 50;

        string product2Name = "Mouse";
        decimal product2Price = 25.00m;
        int product2Stock = 300;

        var products = new[]
        {
            new { Name = product1Name, Price = product1Price, Stock = product1Stock },
            new { Name = product2Name, Price = product2Price, Stock = product2Stock }
        };

        Console.WriteLine("Product Catalog:");
        foreach (var product in products)
        {
            Console.WriteLine($"  Product: {product.Name}, Price: {product.Price:C}, In Stock: {product.Stock}");
        }
    }
}
```

### 3. Populating from a Loop or Collection

You can dynamically build a collection of anonymous types, for instance, from a loop or by transforming an existing collection.

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

public class LoopExample
{
    public static void Main(string[] args)
    {
        List<string> cities = new List<string> { "New York", "London", "Paris", "Tokyo" };
        Random rand = new Random();

        // Create a list of anonymous objects
        var cityData = cities.Select(city => new
        {
            CityName = city,
            PopulationEstimate = rand.Next(1_000_000, 10_000_000),
            Country = city == "New York" ? "USA" :
                      city == "London" ? "UK" :
                      city == "Paris" ? "France" : "Japan"
        }).ToList(); // Convert to List<anonymous type>

        Console.WriteLine("City Information:");
        foreach (var data in cityData)
        {
            Console.WriteLine($"  City: {data.CityName}, Country: {data.Country}, Population: {data.PopulationEstimate:N0}");
        }
    }
}
```

### 4. Returning an Array of Anonymous Types from a Method

While you can't explicitly declare a method's return type as an anonymous type, you can return `object` or `IEnumerable<object>` and then cast it back to `dynamic` or use reflection if you need to access properties outside the method's scope. However, the most common and type-safe approach is to return `IEnumerable<T>` where `T` is a concrete type, or use `dynamic` if type safety is not a primary concern for that specific use case.

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

public class ReturnExample
{
    // This method returns an IEnumerable of anonymous types.
    // The actual return type is IEnumerable<T> where T is the compiler-generated anonymous type.
    // We use 'var' to capture this type.
    public static IEnumerable<object> GetProductSummary()
    {
        var products = new[]
        {
            new { Id = 1, Name = "Keyboard", Price = 75.00m },
            new { Id = 2, Name = "Monitor", Price = 250.00m },
            new { Id = 3, Name = "Webcam", Price = 50.00m }
        };
        return products;
    }

    public static void Main(string[] args)
    {
        // When receiving, you can use 'var' to infer the anonymous type
        // or cast to dynamic if you need to access properties without knowing the type at compile time.
        var summaries = GetProductSummary();

        Console.WriteLine("Product Summaries:");
        foreach (dynamic summary in summaries) // Using dynamic to access properties
        {
            Console.WriteLine($"  ID: {summary.Id}, Product: {summary.Name}, Cost: {summary.Price:C}");
        }
    }
}
```

## Common Problems & Solutions

### 1. Type Mismatch in Array Initializer

**Problem:** Trying to create an array of anonymous types where the elements have different property names or types.

```csharp
// This will cause a compile-time error
var mixedItems = new[]
{
    new { Name = "Item A", Value = 10 },
    new { Product = "Item B", Cost = 20.50m } // Different property names/types
};
```

**Solution:** Ensure all anonymous objects within the array initializer have the exact same property names, in the same order, and with compatible types.

```csharp
var consistentItems = new[]
{
    new { Name = "Item A", Value = 10 },
    new { Name = "Item B", Value = 20 }
};
```

### 2. Accessing Properties Outside Scope

**Problem:** Anonymous types are primarily for local scope. If you try to pass an anonymous type across method boundaries or store it in a field/property without using `dynamic` or a concrete type, you might lose type information.

```csharp
// This won't compile because the return type is not explicitly defined
// public static var GetAnonymousObject() { return new { Id = 1 }; }

// This will compile, but you lose compile-time type safety
public static object GetAnonymousObjectAsObject()
{
    return new { Id = 1, Name = "Test" };
}

public static void Main(string[] args)
{
    object obj = GetAnonymousObjectAsObject();
    // Console.WriteLine(obj.Id); // Compile-time error: 'object' does not contain a definition for 'Id'

    // Solution: Use dynamic
    dynamic dynObj = GetAnonymousObjectAsObject();
    Console.WriteLine(dynObj.Id); // Works at runtime
}
```

**Solution:**
*   For local usage, `var` is perfect.
*   When passing across method calls, consider if a concrete class or struct is more appropriate for long-term maintainability and type safety.
*   If you absolutely need to pass anonymous types and access their properties without a predefined class, use the `dynamic` keyword. Be aware that `dynamic` defers type checking to runtime, which can lead to runtime errors if properties don't exist.

### 3. Modifying Properties

**Problem:** Attempting to change the value of a property on an anonymous type after it has been created.

```csharp
var myObject = new { Name = "Initial", Value = 10 };
// myObject.Name = "Changed"; // Compile-time error: Property or indexer 'Name' cannot be assigned to -- it is read only
```

**Solution:** Anonymous type properties are read-only. If you need mutable objects, you must define a concrete class or struct.

### 4. Performance Considerations

While convenient, creating many anonymous types in a tight loop might have a slight overhead compared to using pre-defined structs or classes, especially if the objects are short-lived and frequently created. For most applications, this overhead is negligible.

## Real-World Use Cases

Arrays of anonymous objects are particularly useful in scenarios where you need a temporary, lightweight data structure, often for display or intermediate processing.

### 1. Data Binding in UI Frameworks (e.g., ASP.NET, WPF, WinForms)

As seen in the original question, `obj.DataSource` is a common pattern in UI frameworks. Anonymous types provide a quick way to prepare data for display without creating dedicated model classes for every small data set.

```csharp
// Example for a simple data grid or listbox
public void BindDataGrid()
{
    var data = new[]
    {
        new { Product = "Laptop", Price = 1200.00m, InStock = true },
        new { Product = "Mouse", Price = 25.00m, InStock = false },
        new { Product = "Keyboard", Price = 75.00m, InStock = true }
    };

    // Assuming 'myGrid' is a DataGridView or similar control
    // myGrid.DataSource = data;
    Console.WriteLine("Data prepared for binding:");
    foreach (var item in data)
    {
        Console.WriteLine($"  {item.Product} - {item.Price:C} (In Stock: {item.InStock})");
    }
}
```

### 2. LINQ Queries

Anonymous types are heavily used in LINQ queries, especially with the `Select` clause, to project a subset of properties or create new calculated properties from existing data.

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

public class Order
{
    public int OrderId { get; set; }
    public string CustomerName { get; set; }
    public decimal TotalAmount { get; set; }
    public DateTime OrderDate { get; set; }
}

public class LinqExample
{
    public static void Main(string[] args)
    {
        List<Order> orders = new List<Order>
        {
            new Order { OrderId = 1, CustomerName = "Alice", TotalAmount = 150.75m, OrderDate = new DateTime(2023, 1, 15) },
            new Order { OrderId = 2, CustomerName = "Bob", TotalAmount = 200.00m, OrderDate = new DateTime(2023, 1, 20) },
            new Order { OrderId = 3, CustomerName = "Alice", TotalAmount = 50.25m, OrderDate = new DateTime(2023, 2, 10) }
        };

        // Select specific properties into an anonymous type
        var orderSummaries = orders
            .Where(o => o.TotalAmount > 100)
            .Select(o => new
            {
                o.OrderId, // Property name inferred from source
                Customer = o.CustomerName, // Renamed property
                FormattedTotal = o.TotalAmount.ToString("C"),
                Year = o.OrderDate.Year
            })
            .ToArray(); // Convert to an array of anonymous objects

        Console.WriteLine("Order Summaries (Total > $100):");
        foreach (var summary in orderSummaries)
        {
            Console.WriteLine($"  Order ID: {summary.OrderId}, Customer: {summary.Customer}, Total: {summary.FormattedTotal}, Year: {summary.Year}");
        }
    }
}
```

![LINQ Anonymous Type Flow](PLACEHOLDER: LINQ Anonymous Type Flow - PLACEHOLDER-2)

### 3. Temporary Data Transfer Objects (DTOs)

For very short-lived data transfer within a single method or a small, isolated component, anonymous types can serve as simple DTOs, avoiding the need to define a full class.

## Related: Other C# Operations

### 1. Using `Tuple` or `ValueTuple`

For returning multiple values from a method or grouping related data, `Tuple` (reference type) or `ValueTuple` (value type, C# 7.0+) can be alternatives to anonymous types, especially when you need to pass them around more explicitly.

```csharp
using System;
using System.Collections.Generic;

public class TupleExample
{
    public static (string Name, int Age) GetPersonData() // ValueTuple return type
    {
        return ("John Doe", 30);
    }

    public static void Main(string[] args)
    {
        var person = GetPersonData();
        Console.WriteLine($"Person: {person.Name}, Age: {person.Age}");

        // Array of ValueTuples
        var people = new[]
        {
            ("Alice", 25),
            ("Bob", 35)
        };

        foreach (var p in people)
        {
            Console.WriteLine($"  {p.Item1} is {p.Item2} years old."); // Access by ItemN
            // Or with deconstruction:
            // var (name, age) = p;
            // Console.WriteLine($"  {name} is {age} years old.");
        }
    }
}
```

### 2. Defining a Concrete Class or Struct

For more complex data structures, data that needs to be mutable, or data that needs to be passed across assembly boundaries or used in a more persistent way, defining a proper class or struct is always the best practice.

```csharp
public class Product
{
    public string Name { get; set; }
    public decimal Price { get; set; }
    public int Quantity { get; set; }
}

public class ConcreteClassExample
{
    public static void Main(string[] args)
    {
        Product[] products = new Product[]
        {
            new Product { Name = "Desk", Price = 300.00m, Quantity = 50 },
            new Product { Name = "Chair", Price = 150.00m, Quantity = 100 }
        };

        foreach (var product in products)
        {
            Console.WriteLine($"Product: {product.Name}, Price: {product.Price:C}");
        }
    }
}
```

## Summary

Arrays of anonymous objects in C# are a powerful and concise way to create temporary, read-only data structures. They are particularly useful for:

*   **Quick data binding** in UI applications.
*   **Projecting data** in LINQ queries.
*   **Short-lived data transfer** within a limited scope.

While convenient, remember their limitations: they are implicitly typed, their properties are read-only, and they are best suited for local scope. For more robust, mutable, or widely used data structures, explicit class or struct definitions remain the preferred approach.

---

## Image Generation Prompts

**PLACEHOLDER-1:** A flowchart illustrating the C# compiler's process for handling anonymous types. Start with a "C# Code" box containing `new { Prop1 = value1, Prop2 = value2 }`. An arrow points to a "C# Compiler" box. From there, two arrows emerge: one pointing to "Generates Internal Class Definition (e.g., `internal sealed class __AnonymousType_0 { public T1 Prop1 { get; } ... }`)", and another pointing to "Replaces `new { ... }` with `new __AnonymousType_0(...)`". The overall style should be clean, modern, with C# specific icons or colors.

**PLACEHHER-2:** A diagram showing the flow of data through a LINQ query using anonymous types. Start with a "Source Collection (e.g., `List<Order>`)". An arrow points to a "`.Where(...)` Filter" box. Another arrow points to a "`.Select(o => new { ... })` Projection" box, with an example of `new { o.OrderId, Customer = o.CustomerName }` inside. This box should clearly indicate the creation of anonymous types. Finally, an arrow points to a "Result: `IEnumerable<AnonymousType>`" box. Use distinct colors for each stage and clear labels.