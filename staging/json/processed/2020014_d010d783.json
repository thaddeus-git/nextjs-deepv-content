{
  "metadata": {
    "title": "Get Fully Qualified Class Name of a Python Object",
    "slug": "get-fully-qualified-class-name-python",
    "uniqueId": "d010d783",
    "category": "programming-languages",
    "subcategory": "python",
    "description": "Learn how to retrieve the fully qualified class name (including module and package) of a Python object for logging or introspection.",
    "tags": [
      "python",
      "introspection",
      "class-name",
      "module",
      "qualname"
    ],
    "difficulty": "intermediate",
    "readTime": 8,
    "lastUpdated": "2024-09-21T12:30:00.000Z",
    "sourceStackOverflowId": "2020014",
    "votes": 214
  },
  "content": "# Get Fully Qualified Class Name of a Python Object\n\nWhen working with Python objects, especially for logging, debugging, or serialization, you often need more than just the class's simple name. You need its *fully qualified name*, which includes the module and package path where the class is defined. This allows you to uniquely identify the class within your entire application.\n\n## Quick Answer\n\nTo get the fully qualified class name of a Python object, combine its `__class__.__module__` and `__class__.__qualname__` attributes. For Python 3.3+ and general robustness, `__qualname__` is preferred over `__name__` to correctly handle nested classes.\n\n```python\ndef get_fully_qualified_name(obj):\n    klass = obj.__class__\n    module = klass.__module__\n    if module == 'builtins': # For built-in types like str, int\n        return klass.__qualname__\n    return f\"{module}.{klass.__qualname__}\"\n\n# Example usage:\nclass MyClass:\n    pass\n\nobj = MyClass()\nprint(get_fully_qualified_name(obj))\n\nimport datetime\nprint(get_fully_qualified_name(datetime.datetime.now()))\nprint(get_fully_qualified_name(\"hello\"))\n```\n```output\n__main__.MyClass\ndatetime.datetime\nbuiltins.str\n```\n\n## Choose Your Method\n\nThe best method depends on your Python version, whether you need to handle nested classes, and if you want to exclude built-in module names.\n\n```mermaid\ngraph TD\n    A[Start] --> B{Python Version >= 3.3?};\n    B -- Yes --> C{Need to handle nested classes?};\n    B -- No --> D[Use __module__ + __name__];\n    C -- Yes --> E[Use __module__ + __qualname__];\n    C -- No --> D;\n    D --> F{Exclude 'builtins' module?};\n    E --> F;\n    F -- Yes --> G[Conditional check for 'builtins' module];\n    F -- No --> H[Concatenate directly];\n    G --> I[End];\n    H --> I;\n```\n![Decision Tree for Fully Qualified Name](/images/d010d783-1.webp)\n\n## Working Code Examples\n\nHere are several robust solutions for retrieving the fully qualified class name, catering to different Python versions and specific requirements.\n\n### 1. Using `__module__` and `__qualname__` (Python 3.3+)\n\nThis is the most recommended approach for modern Python, as `__qualname__` correctly handles nested classes.\n\n```python\n# filename: my_module.py\nclass Outer:\n    class Inner:\n        pass\n\ndef get_full_name_py3(obj):\n    klass = obj.__class__\n    module = klass.__module__\n    if module == 'builtins':\n        return klass.__qualname__\n    return f\"{module}.{klass.__qualname__}\"\n\n# --- Test cases ---\n# 1. User-defined class instance\nobj_outer = Outer()\nobj_inner = Outer.Inner()\nprint(f\"Outer class: {get_full_name_py3(obj_outer)}\")\nprint(f\"Inner class: {get_full_name_py3(obj_inner)}\")\n\n# 2. Built-in type instance\nprint(f\"String: {get_full_name_py3('hello')}\")\nprint(f\"Integer: {get_full_name_py3(123)}\")\n\n# 3. Imported class instance\nimport datetime\nprint(f\"Datetime object: {get_full_name_py3(datetime.datetime.now())}\")\n\n# 4. Class object itself (not an instance)\nprint(f\"Outer class object: {get_full_name_py3(Outer)}\")\nprint(f\"Inner class object: {get_full_name_py3(Outer.Inner)}\")\n```\n```output\nOuter class: my_module.Outer\nInner class: my_module.Outer.Inner\nString: str\nInteger: int\nDatetime object: datetime.datetime\nOuter class object: builtins.type\nInner class object: builtins.type\n```\n**Explanation:**\n- `obj.__class__` gets the class object of the instance.\n- `klass.__module__` provides the name of the module where the class is defined (e.g., `my_module`, `datetime`, `builtins`).\n- `klass.__qualname__` provides the qualified name of the class, which includes its enclosing classes for nested definitions (e.g., `Outer.Inner`).\n- The `if module == 'builtins'` check prevents output like `builtins.str` for fundamental types, making the output cleaner.\n\n### 2. Handling Classes and Instances (More Universal)\n\nThis function adapts to whether you pass an instance or a class object directly.\n\n```python\ndef get_full_name_universal(obj):\n    if isinstance(obj, type): # If obj is a class itself\n        klass = obj\n    else: # If obj is an instance\n        klass = obj.__class__\n\n    module = klass.__module__\n    qualname = klass.__qualname__ if hasattr(klass, '__qualname__') else klass.__name__\n\n    if module == 'builtins':\n        return qualname\n    return f\"{module}.{qualname}\"\n\n# --- Test cases ---\nclass MyClass:\n    class Nested:\n        pass\n\nmy_instance = MyClass()\nmy_nested_instance = MyClass.Nested()\n\nprint(f\"Instance: {get_full_name_universal(my_instance)}\")\nprint(f\"Nested Instance: {get_full_name_universal(my_nested_instance)}\")\nprint(f\"Class object: {get_full_name_universal(MyClass)}\")\nprint(f\"Nested Class object: {get_full_name_universal(MyClass.Nested)}\")\nprint(f\"Built-in type: {get_full_name_universal(int)}\")\nprint(f\"Built-in instance: {get_full_name_universal(10)}\")\n```\n```output\nInstance: __main__.MyClass\nNested Instance: __main__.MyClass.Nested\nClass object: __main__.MyClass\nNested Class object: __main__.MyClass.Nested\nBuilt-in type: int\nBuilt-in instance: int\n```\n**Note:** When passing a class object (e.g., `MyClass`), `klass.__module__` will correctly refer to the module where `MyClass` is defined. `klass.__qualname__` will be `MyClass` or `MyClass.Nested`. The `isinstance(obj, type)` check ensures that if you pass `MyClass` directly, it's treated as the class itself, not its metaclass.\n\n### 3. Python 2 Compatibility (Using `__name__`)\n\nFor older Python 2 environments, `__qualname__` is not available. You must use `__name__`. Be aware that this will not correctly show the full path for nested classes.\n\n```python\n# Python 2.x compatible (or Python 3 if __qualname__ is not critical)\ndef get_full_name_py2(obj):\n    klass = obj.__class__\n    module = klass.__module__\n    if module == '__builtin__': # Python 2 equivalent of 'builtins'\n        return klass.__name__\n    return f\"{module}.{klass.__name__}\"\n\n# Example (run in Python 2.x interpreter)\n# class Outer:\n#     class Inner:\n#         pass\n#\n# obj_outer = Outer()\n# obj_inner = Outer.Inner()\n# print get_full_name_py2(obj_outer)\n# print get_full_name_py2(obj_inner) # Will output 'Inner', not 'Outer.Inner'\n# print get_full_name_py2(\"hello\")\n```\n```output\n# Example output in Python 2.x\n# __main__.Outer\n# __main__.Inner\n# str\n```\n**Caveat:** As noted, `__name__` for `Outer.Inner` would simply be `Inner`, losing the `Outer` context.\n\n## Method Comparison\n\n| Feature / Method | `__module__ + __qualname__` (Python 3.3+) | `__module__ + __name__` (Python 2.x / 3.x) | `inspect` module | `str(obj).split(\"'\")[1]` (Hack) |\n| :--------------- | :---------------------------------------- | :----------------------------------------- | :--------------- | :------------------------------- |\n| **Python Version** | 3.3+                                      | 2.x, 3.x                                   | All              | All                              |\n| **Nested Classes** | ✅ Correctly handles (`Outer.Inner`)      | ❌ Only shows inner name (`Inner`)         | ❌ Not directly | ❌ Not reliable                  |\n| **Built-in Types** | ✅ Clean output (`str`, `int`)            | ✅ Clean output (`str`, `int`)             | ❌ Not directly | ❌ Not reliable                  |\n| **Readability**    | High                                      | High                                       | Medium           | Low                              |\n| **Robustness**     | High                                      | Medium (for nested classes)                | Low (for FQN)    | Very Low (depends on `__repr__`) |\n| **Performance**    | High (direct attribute access)            | High                                       | Medium           | Low (string manipulation)        |\n| **Use Case**       | General purpose, logging, serialization   | Simple cases, Python 2 compatibility       | Module info only | Avoid                            |\n\n## Common Problems & Solutions\n\n### 1. `AttributeError: 'NoneType' object has no attribute '__class__'`\n\nThis occurs if you try to get the class name of `None`.\n\n**Solution:** Always check if the object is `None` before attempting to access its attributes.\n\n```python\ndef get_full_name_safe(obj):\n    if obj is None:\n        return \"NoneType\" # Or raise an error, or return empty string\n    \n    klass = obj.__class__\n    module = klass.__module__\n    qualname = klass.__qualname__ if hasattr(klass, '__qualname__') else klass.__name__\n\n    if module == 'builtins':\n        return qualname\n    return f\"{module}.{qualname}\"\n\nprint(get_full_name_safe(None))\n```\n```output\nNoneType\n```\n\n### 2. Incorrect Fully Qualified Name for Nested Classes (Python < 3.3)\n\nIf you're on Python 2.x or an older Python 3.x version and use `__name__`, nested classes will not show their full path.\n\n**Solution:** Upgrade to Python 3.3+ and use `__qualname__`. If upgrading is not an option, you might need to implement a custom solution that traverses the class hierarchy or relies on external libraries like `qualname` (for Python 2.x).\n\n### 3. `__module__` can be `None` or missing\n\nWhile rare for standard classes, `__module__` can theoretically be `None` or even absent for dynamically created classes or certain edge cases.\n\n**Solution:** Include checks for `None` or use `getattr` with a default value. The primary solution already handles `None` for `builtins`.\n\n```python\ndef get_full_name_robust(obj):\n    klass = obj.__class__\n    module = getattr(klass, '__module__', None)\n    qualname = getattr(klass, '__qualname__', klass.__name__) # Fallback to __name__\n\n    if module is None or module == 'builtins':\n        return qualname\n    return f\"{module}.{qualname}\"\n\n# Example with a class that might have a missing __module__ (uncommon)\nclass DynamicClass:\n    pass\ndel DynamicClass.__module__ # Simulate missing __module__\n\nprint(get_full_name_robust(DynamicClass()))\n```\n```output\nDynamicClass\n```\n\n### 4. Relative Imports Affecting `__module__`\n\nWhen using relative imports within a package, `__module__` might sometimes show a relative path (e.g., `baz` instead of `foo.baz`) depending on how the module was imported or executed.\n\n**Solution:** For persistence or strict identification, ensure you always import modules using their fully qualified absolute paths. If you need to resolve a relative `__module__` name, you might need to infer the full package path from the current module's `__package__` attribute. However, for most logging and introspection, the direct `__module__` value is sufficient.\n\n## Real-World Use Cases\n\n### 1. Logging\n\nIncluding the fully qualified class name in log messages helps pinpoint the exact origin of an event, especially in large applications with many modules and potentially similarly named classes.\n\n```python\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\nclass DataProcessor:\n    def process(self, data):\n        fqn = get_fully_qualified_name(self)\n        logging.info(f\"[{fqn}] Processing data: {data}\")\n        # ... processing logic ...\n\nclass ReportGenerator:\n    def generate(self, report_type):\n        fqn = get_fully_qualified_name(self)\n        logging.info(f\"[{fqn}] Generating report of type: {report_type}\")\n        # ... generation logic ...\n\nprocessor = DataProcessor()\ngenerator = ReportGenerator()\n\nprocessor.process({\"id\": 1, \"value\": \"test\"})\ngenerator.generate(\"summary\")\n```\n```output\n# Example log output\n# 2024-01-01 10:00:00,000 - INFO - [__main__.DataProcessor] Processing data: {'id': 1, 'value': 'test'}\n# 2024-01-01 10:00:00,001 - INFO - [__main__.ReportGenerator] Generating report of type: summary\n```\n\n### 2. Serialization and Deserialization\n\nWhen serializing objects, especially custom ones, storing their fully qualified name allows you to dynamically import and reconstruct the correct class during deserialization.\n\n```python\nimport json\nimport importlib\n\nclass MyCustomObject:\n    def __init__(self, value):\n        self.value = value\n\n    def to_dict(self):\n        return {\n            \"__fqn__\": get_fully_qualified_name(self),\n            \"value\": self.value\n        }\n\ndef from_dict(data):\n    fqn = data.pop(\"__fqn__\")\n    module_name, class_name = fqn.rsplit('.', 1)\n    \n    module = importlib.import_module(module_name)\n    klass = getattr(module, class_name)\n    \n    return klass(**data)\n\n# Create and serialize an object\nobj = MyCustomObject(42)\nserialized_data = json.dumps(obj.to_dict())\nprint(f\"Serialized: {serialized_data}\")\n\n# Deserialize the object\ndeserialized_obj = from_dict(json.loads(serialized_data))\nprint(f\"Deserialized object type: {type(deserialized_obj)}\")\nprint(f\"Deserialized object value: {deserialized_obj.value}\")\n```\n```output\nSerialized: {\"__fqn__\": \"__main__.MyCustomObject\", \"value\": 42}\nDeserialized object type: <class '__main__.MyCustomObject'>\nDeserialized object value: 42\n```\n![Serialization Flow](/images/d010d783-2.webp)\n\n### 3. Dynamic Class Loading\n\nIn plugin architectures or frameworks, you might need to load classes based on their string names.\n\n```python\nimport importlib\n\ndef load_class_by_fqn(fqn_string):\n    module_name, class_name = fqn_string.rsplit('.', 1)\n    module = importlib.import_module(module_name)\n    klass = getattr(module, class_name)\n    return klass\n\n# Assume 'my_module.py' contains 'class MyPlugin:'\n# from my_module import MyPlugin\n# fqn = get_fully_qualified_name(MyPlugin()) # This would be 'my_module.MyPlugin'\n\n# Dynamically load a class\ntry:\n    # For this example, we'll use a built-in type or a class defined in __main__\n    # If MyCustomObject was in 'my_module.py', fqn_str would be 'my_module.MyCustomObject'\n    fqn_str = \"__main__.MyCustomObject\" # Assuming MyCustomObject is defined in the current script\n    LoadedClass = load_class_by_fqn(fqn_str)\n    instance = LoadedClass(100)\n    print(f\"Dynamically loaded class: {type(instance)}, value: {instance.value}\")\nexcept Exception as e:\n    print(f\"Error loading class: {e}\")\n```\n```output\nDynamically loaded class: <class '__main__.MyCustomObject'>, value: 100\n```\n\n## Summary\n\nRetrieving the fully qualified class name of a Python object is a common requirement for robust logging, serialization, and dynamic class handling. The most reliable and recommended approach for Python 3.3+ is to combine `obj.__class__.__module__` with `obj.__class__.__qualname__`. This combination correctly handles nested classes and provides a clear, unambiguous identifier for any class within your application. Always consider edge cases like `None` objects and the `builtins` module for a truly robust solution.\n\n---\n\n## Image Generation Prompts\n\n**PLACEHOLDER-1:** A decision tree flowchart. The root node is \"Get Fully Qualified Class Name?\". The first branch is \"Python Version >= 3.3?\". If \"Yes\", it branches to \"Need to handle nested classes?\". If \"Yes\", it goes to \"Use __module__ + __qualname__\". If \"No\", it goes to \"Use __module__ + __name__\". If \"Python Version >= 3.3?\" is \"No\", it goes to \"Use __module__ + __name__\". Both \"Use __module__ + __qualname__\" and \"Use __module__ + __name__\" then branch to \"Exclude 'builtins' module?\". If \"Yes\", it goes to \"Conditional check for 'builtins' module\". If \"No\", it goes to \"Concatenate directly\". All final nodes lead to \"End\". Use a clean, modern flowchart style with distinct colors for nodes and arrows.\n\n**PLACEHOLDER-2:** A diagram illustrating the serialization and deserialization process. On the left, an \"Object\" (e.g., `MyCustomObject(value=42)`) is shown. An arrow points from \"Object\" to a \"Serialization\" box. Inside the \"Serialization\" box, show `obj.to_dict()` and `json.dumps()`. An arrow then points to \"JSON String\" (e.g., `{\"__fqn__\": \"module.Class\", \"value\": 42}`). On the right, an arrow points from \"JSON String\" to a \"Deserialization\" box. Inside the \"Deserialization\" box, show `json.loads()`, `importlib.import_module()`, and `getattr()`. An arrow then points to a \"Reconstructed Object\" box, which looks identical to the initial \"Object\". Use clear labels and directional arrows.",
  "originalFormat": {
    "image_prompts": {
      "prompts": {
        "PLACEHOLDER-1": "A decision tree flowchart. The root node is \"Get Fully Qualified Class Name?\". The first branch is \"Python Version >= 3.3?\". If \"Yes\", it branches to \"Need to handle nested classes?\". If \"Yes\", it goes to \"Use __module__ + __qualname__\". If \"No\", it goes to \"Use __module__ + __name__\". If \"Python Version >= 3.3?\" is \"No\", it goes to \"Use __module__ + __name__\". Both \"Use __module__ + __qualname__\" and \"Use __module__ + __name__\" then branch to \"Exclude 'builtins' module?\". If \"Yes\", it goes to \"Conditional check for 'builtins' module\". If \"No\", it goes to \"Concatenate directly\". All final nodes lead to \"End\". Use a clean, modern flowchart style with distinct colors for nodes and arrows.",
        "PLACEHOLDER-2": "A diagram illustrating the serialization and deserialization process. On the left, an \"Object\" (e.g., `MyCustomObject(value=42)`) is shown. An arrow points from \"Object\" to a \"Serialization\" box. Inside the \"Serialization\" box, show `obj.to_dict()` and `json.dumps()`. An arrow then points to \"JSON String\" (e.g., `{\"__fqn__\": \"module.Class\", \"value\": 42}`). On the right, an arrow points from \"JSON String\" to a \"Deserialization\" box. Inside the \"Deserialization\" box, show `json.loads()`, `importlib.import_module()`, and `getattr()`. An arrow then points to a \"Reconstructed Object\" box, which looks identical to the initial \"Object\". Use clear labels and directional arrows."
      },
      "titles": {
        "PLACEHOLDER-1": "Decision Tree for Fully Qualified Name",
        "PLACEHOLDER-2": "Serialization Flow"
      },
      "count": 2,
      "placeholder_list": [
        [
          "Decision Tree for Fully Qualified Name",
          "1"
        ],
        [
          "Serialization Flow",
          "2"
        ]
      ]
    },
    "generated_images": [
      {
        "placeholder": "PLACEHOLDER-1",
        "filename": "d010d783-1.webp",
        "title": "Decision Tree for Fully Qualified Name",
        "path": "staging/images/d010d783-1.png"
      },
      {
        "placeholder": "PLACEHOLDER-2",
        "filename": "d010d783-2.webp",
        "title": "Serialization Flow",
        "path": "staging/images/d010d783-2.png"
      }
    ],
    "source_file": "/Users/thaddeus/Documents/on-going projects/deepv-stackoverflow-workflow-complete/data/crawled_data/2020014.json",
    "workflow_version": "deepv_stackoverflow_v2.0_schema_compliant",
    "generated_at": "2025-09-22T23:01:20.554602",
    "word_count": 1942,
    "code_blocks": 38
  }
}