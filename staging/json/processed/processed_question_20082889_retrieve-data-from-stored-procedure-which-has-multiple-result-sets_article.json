{
  "metadata": {
    "title": "Retrieve data from stored procedure which has multiple result sets: Complete Guide with 6 Solutions",
    "slug": "retrieve-data-from-stored-procedure-which-has-multiple",
    "uniqueId": "c335a59c",
    "category": "programming",
    "subcategory": "general",
    "description": "For immediate T-SQL consumption of multiple result sets, the most direct and recommended approach is to refactor the stored procedure into smaller, single-pu...",
    "tags": [
      "sql-server",
      "stored-procedures"
    ],
    "difficulty": "intermediate",
    "readTime": 30,
    "publishedAt": "2025-09-18",
    "featured": false,
    "technology": "Sql-Server",
    "votes": 39,
    "answersCount": 7,
    "sourceStackOverflowId": "20082889",
    "generatedAt": "2025-09-18T11:46:39.868134",
    "workflowVersion": "deepv_stackoverflow_v1.0",
    "qualityMetrics": {
      "wordCount": 5942,
      "codeBlocks": 50,
      "sections": 65,
      "personaIntegration": 21,
      "practicalFocusScore": 100
    }
  },
  "content": "# Retrieve data from stored procedure which has multiple result sets: Complete Guide with 6 Solutions\n\nWhen working with SQL Server stored procedures, it's common to encounter scenarios where a single procedure returns multiple result sets. While client-side applications (like .NET with `SqlDataReader`) are well-equipped to handle this, retrieving and processing these distinct result sets directly within T-SQL can be a significant challenge. This comprehensive guide explores various strategies, from best practices to clever workarounds, to help you effectively manage multiple result sets from stored procedures in SQL Server.\n\n## Quick Answer\n\nFor immediate T-SQL consumption of multiple result sets, the most direct and recommended approach is to refactor the stored procedure into smaller, single-purpose procedures. If refactoring isn't an option, or if you need to selectively retrieve specific result sets, consider modifying the stored procedure to accept a parameter that dictates which result set(s) to return.\n\n**Example of Refactoring:**\n\n```sql\n-- Original Stored Procedure (returns two result sets)\nCREATE PROCEDURE dbo.GetSomething\nAS\nBEGIN\n    SELECT PersonID, FirstName, LastName FROM dbo.Person;\n    SELECT CarID, Make, Model FROM dbo.Car;\nEND;\nGO\n\n-- Refactored Stored Procedures (single result set each)\nCREATE PROCEDURE dbo.GetPeople\nAS\nBEGIN\n    SELECT PersonID, FirstName, LastName FROM dbo.Person;\nEND;\nGO\n\nCREATE PROCEDURE dbo.GetCars\nAS\nBEGIN\n    SELECT CarID, Make, Model FROM dbo.Car;\nEND;\nGO\n\n-- How to use the refactored procedures to get both results in T-SQL:\n-- Method 1: Insert into separate temp tables\nCREATE TABLE #PeopleTemp (PersonID INT, FirstName NVARCHAR(50), LastName NVARCHAR(50));\nINSERT INTO #PeopleTemp EXEC dbo.GetPeople;\n\nCREATE TABLE #CarsTemp (CarID INT, Make NVARCHAR(50), Model NVARCHAR(50));\nINSERT INTO #CarsTemp EXEC dbo.GetCars;\n\nSELECT * FROM #PeopleTemp;\nSELECT * FROM #CarsTemp;\n\nDROP TABLE #PeopleTemp;\nDROP TABLE #CarsTemp;\nGO\n```\n\n## Choose Your Method\n\nDeciding the best approach depends on your specific needs, environment, and constraints. Use the following decision tree to navigate to the most suitable solution.\n\n```mermaid\ngraph TD\n    A[Start: Need to retrieve multiple result sets from a SP?] --> B{Can you modify the Stored Procedure?};\n\n    B -- Yes --> C{Do you need all result sets or specific ones?};\n    B -- No --> D{Are you consuming from a .NET application?};\n\n    C -- All Result Sets --> E[Method 1: Refactor into single-purpose SPs];\n    C -- Specific Result Sets --> F[Method 2: Parameterized SP for selective retrieval];\n\n    D -- Yes --> G[Method 3: Use SqlDataReader.NextResult() in .NET];\n    D -- No --> H{Is CLR integration an option?};\n\n    H -- Yes --> I[Method 4: CLR Stored Procedure with SqlDataReader.NextResult()];\n    H -- No --> J{Can you tolerate a \"hacky\" T-SQL approach?};\n\n    J -- Yes --> K[Method 5: Dynamic SQL with temporary tables (Advanced)];\n    J -- No --> L[Method 6: XML Output (Consider performance)];\n\n    E --> M[End: Best Practice for T-SQL consumption];\n    F --> M;\n    G --> M[End: Standard .NET approach];\n    I --> M[End: Advanced T-SQL with .NET capabilities];\n    K --> M[End: T-SQL workaround];\n    L --> M[End: Alternative for complex data structures];\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px;\n    style M fill:#bbf,stroke:#333,stroke-width:2px;\n    style E fill:#ccf,stroke:#333,stroke-width:2px;\n    style F fill:#ccf,stroke:#333,stroke-width:2px;\n    style G fill:#ccf,stroke:#333,stroke-width:2px;\n    style I fill:#ccf,stroke:#333,stroke-width:2px;\n    style K fill:#ccf,stroke:#333,stroke-width:2px;\n    style L fill:#ccf,stroke:#333,stroke-width:2px;\n```\n\n## Table of Contents\n- [Quick Answer](#quick-answer)\n- [Choose Your Method](#choose-your-method)\n- [Ready-to-Use Code](#ready-to-use-code)\n- [Method 1: Refactor into Single-Purpose Stored Procedures](#method-1-refactor-into-single-purpose-stored-procedures)\n- [Method 2: Parameterized Stored Procedure for Selective Retrieval](#method-2-parameterized-stored-procedure-for-selective-retrieval)\n- [Method 3: Using SqlDataReader.NextResult() in .NET](#method-3-using-sqldatareader.nextresult-in-.net)\n- [Method 4: CLR Stored Procedure with SqlDataReader.NextResult()](#method-4-clr-stored-procedure-with-sqldatareader.nextresult)\n- [Method 5: Dynamic SQL with Temporary Tables (Advanced T-SQL Workaround)](#method-5-dynamic-sql-with-temporary-tables-advanced-t-sql-workaround)\n- [Method 6: XML Output for Multiple Result Sets](#method-6-xml-output-for-multiple-result-sets)\n- [Performance Comparison](#performance-comparison)\n- [SQL Server Version Support](#sql-server-version-support)\n- [Common Problems & Solutions](#common-problems--solutions)\n- [Real-World Use Cases](#real-world-use-cases)\n- [Related: Other SQL Server Operations](#related-other-sql-server-operations)\n- [Summary](#summary)\n- [Frequently Asked Questions](#frequently-asked-questions)\n- [Tools & Resources](#tools--resources)\n\n## Ready-to-Use Code\n\nHere are the top 3 ready-to-use solutions for common scenarios.\n\n### 1. Refactoring for T-SQL Consumption (Recommended for üèóÔ∏è Architecture Builder, üìö Learning Explorer)\n\n```sql\n-- Step 1: Define your base tables\nCREATE TABLE dbo.Person (\n    PersonID INT PRIMARY KEY IDENTITY(1,1),\n    FirstName NVARCHAR(50) NOT NULL,\n    LastName NVARCHAR(50) NOT NULL,\n    Email NVARCHAR(100) UNIQUE\n);\n\nCREATE TABLE dbo.Car (\n    CarID INT PRIMARY KEY IDENTITY(1,1),\n    Make NVARCHAR(50) NOT NULL,\n    Model NVARCHAR(50) NOT NULL,\n    Year INT,\n    PersonID INT FOREIGN KEY REFERENCES dbo.Person(PersonID)\n);\n\n-- Insert sample data\nINSERT INTO dbo.Person (FirstName, LastName, Email) VALUES\n('Alice', 'Smith', 'alice.s@example.com'),\n('Bob', 'Johnson', 'bob.j@example.com');\n\nINSERT INTO dbo.Car (Make, Model, Year, PersonID) VALUES\n('Toyota', 'Camry', 2020, 1),\n('Honda', 'Civic', 2022, 1),\n('Ford', 'F-150', 2023, 2);\nGO\n\n-- Step 2: Create refactored stored procedures\nCREATE PROCEDURE dbo.GetPeople\nAS\nBEGIN\n    SELECT PersonID, FirstName, LastName, Email FROM dbo.Person;\nEND;\nGO\n\nCREATE PROCEDURE dbo.GetCars\nAS\nBEGIN\n    SELECT CarID, Make, Model, Year, PersonID FROM dbo.Car;\nEND;\nGO\n\n-- Step 3: Consume in T-SQL using temporary tables\nCREATE TABLE #PeopleResults (\n    PersonID INT,\n    FirstName NVARCHAR(50),\n    LastName NVARCHAR(50),\n    Email NVARCHAR(100)\n);\n\nCREATE TABLE #CarResults (\n    CarID INT,\n    Make NVARCHAR(50),\n    Model NVARCHAR(50),\n    Year INT,\n    PersonID INT\n);\n\nINSERT INTO #PeopleResults EXEC dbo.GetPeople;\nINSERT INTO #CarResults EXEC dbo.GetCars;\n\nSELECT 'People Data' AS ResultSetName, * FROM #PeopleResults;\nSELECT 'Car Data' AS ResultSetName, * FROM #CarResults;\n\nDROP TABLE #PeopleResults;\nDROP TABLE #CarResults;\nGO\n```\n\n### 2. Parameterized Stored Procedure for Selective Retrieval (Recommended for üîß Problem Solver, üöÄ Speed Seeker)\n\n```sql\n-- Step 1: Create a stored procedure with a result set indicator parameter\nCREATE PROCEDURE dbo.GetSomethingSelective\n    @ResultSetIndicator INT = 0 -- 0 for all, 1 for People, 2 for Cars\nAS\nBEGIN\n    SET NOCOUNT ON;\n\n    IF @ResultSetIndicator = 0 OR @ResultSetIndicator = 1\n    BEGIN\n        SELECT PersonID, FirstName, LastName, Email FROM dbo.Person;\n    END;\n\n    IF @ResultSetIndicator = 0 OR @ResultSetIndicator = 2\n    BEGIN\n        SELECT CarID, Make, Model, Year, PersonID FROM dbo.Car;\n    END;\nEND;\nGO\n\n-- Step 2: Consume specific result sets in T-SQL\n-- Get only People data\nCREATE TABLE #PeopleOnly (\n    PersonID INT,\n    FirstName NVARCHAR(50),\n    LastName NVARCHAR(50),\n    Email NVARCHAR(100)\n);\nINSERT INTO #PeopleOnly EXEC dbo.GetSomethingSelective @ResultSetIndicator = 1;\nSELECT 'People Only' AS ResultSetName, * FROM #PeopleOnly;\nDROP TABLE #PeopleOnly;\nGO\n\n-- Get only Car data\nCREATE TABLE #CarsOnly (\n    CarID INT,\n    Make NVARCHAR(50),\n    Model NVARCHAR(50),\n    Year INT,\n    PersonID INT\n);\nINSERT INTO #CarsOnly EXEC dbo.GetSomethingSelective @ResultSetIndicator = 2;\nSELECT 'Cars Only' AS ResultSetName, * FROM #CarsOnly;\nDROP TABLE #CarsOnly;\nGO\n\n-- Get all data (behaves like original multi-result SP)\nEXEC dbo.GetSomethingSelective @ResultSetIndicator = 0;\nGO\n```\n\n### 3. .NET `SqlDataReader.NextResult()` (Recommended for üé® Output Focused, ‚ö° Legacy Maintainer)\n\n```csharp\nusing System;\nusing System.Data;\nusing System.Data.SqlClient;\nusing System.Collections.Generic;\n\npublic class MultiResultSetReader\n{\n    public static void ReadMultipleResultSets(string connectionString, string storedProcedureName)\n    {\n        using (SqlConnection connection = new SqlConnection(connectionString))\n        {\n            SqlCommand command = new SqlCommand(storedProcedureName, connection);\n            command.CommandType = CommandType.StoredProcedure;\n\n            try\n            {\n                connection.Open();\n                SqlDataReader reader = command.ExecuteReader();\n\n                // Process the first result set (e.g., People)\n                Console.WriteLine(\"--- First Result Set (People) ---\");\n                if (reader.HasRows)\n                {\n                    while (reader.Read())\n                    {\n                        Console.WriteLine($\"PersonID: {reader[\"PersonID\"]}, Name: {reader[\"FirstName\"]} {reader[\"LastName\"]}, Email: {reader[\"Email\"]}\");\n                    }\n                }\n                else\n                {\n                    Console.WriteLine(\"No rows found in the first result set.\");\n                }\n\n                // Move to the next result set (e.g., Cars)\n                if (reader.NextResult())\n                {\n                    Console.WriteLine(\"\\n--- Second Result Set (Cars) ---\");\n                    if (reader.HasRows)\n                    {\n                        while (reader.Read())\n                        {\n                            Console.WriteLine($\"CarID: {reader[\"CarID\"]}, Make: {reader[\"Make\"]}, Model: {reader[\"Model\"]}, Year: {reader[\"Year\"]}, PersonID: {reader[\"PersonID\"]}\");\n                        }\n                    }\n                    else\n                    {\n                        Console.WriteLine(\"No rows found in the second result set.\");\n                    }\n                }\n                else\n                {\n                    Console.WriteLine(\"\\nNo more result sets.\");\n                }\n\n                reader.Close();\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"An error occurred: {ex.Message}\");\n            }\n        }\n    }\n\n    public static void Main(string[] args)\n    {\n        // Replace with your actual connection string\n        string connectionString = \"Data Source=.;Initial Catalog=YourDatabaseName;Integrated Security=True\";\n        string storedProcedureName = \"dbo.GetSomething\"; // Assuming dbo.GetSomething from Quick Answer\n\n        // Ensure dbo.Person, dbo.Car, and dbo.GetSomething are created and populated\n        // You can run the setup script from the \"Ready-to-Use Code\" section first.\n\n        ReadMultipleResultSets(connectionString, storedProcedureName);\n    }\n}\n```\n\n## Method 1: Refactor into Single-Purpose Stored Procedures\n\n**Persona Focus:** üèóÔ∏è Architecture Builder, üìö Learning Explorer, üöÄ Speed Seeker\n\nThis method is often considered the cleanest and most maintainable approach, especially when consuming results directly within T-SQL. Instead of having one stored procedure return multiple, unrelated result sets, you break it down into several smaller, focused procedures, each returning a single result set.\n\n### Why Refactor?\n\n*   **Clarity and Maintainability:** Each procedure has a single responsibility, making it easier to understand, test, and maintain.\n*   **Performance:** You only execute the specific query needed, avoiding unnecessary data retrieval.\n*   **T-SQL Compatibility:** T-SQL's `INSERT...EXEC` statement works seamlessly with single-result-set procedures, allowing you to capture results into temporary tables or table variables.\n*   **Reusability:** Individual procedures can be reused independently in different contexts.\n\n### Implementation Steps\n\n1.  **Identify Result Sets:** Determine the distinct `SELECT` statements within your original multi-result stored procedure.\n2.  **Create New Procedures:** For each distinct `SELECT` statement, create a new stored procedure that encapsulates only that `SELECT` query.\n3.  **Update Calling Code:** Modify any T-SQL code that previously called the multi-result procedure to call the new, single-purpose procedures and capture their output.\n\n### Code Examples\n\nLet's assume we have the initial `dbo.GetSomething` procedure:\n\n```sql\n-- Original multi-result stored procedure\nCREATE PROCEDURE dbo.GetSomething\nAS\nBEGIN\n    -- Result Set 1: People\n    SELECT PersonID, FirstName, LastName, Email\n    FROM dbo.Person;\n\n    -- Result Set 2: Cars\n    SELECT CarID, Make, Model, Year, PersonID\n    FROM dbo.Car;\nEND;\nGO\n```\n\n#### Example 1.1: Refactored Procedures\n\n```sql\n-- Refactored procedure for People data\nCREATE PROCEDURE dbo.GetPeopleData\nAS\nBEGIN\n    SET NOCOUNT ON;\n    SELECT PersonID, FirstName, LastName, Email\n    FROM dbo.Person;\nEND;\nGO\n\n-- Refactored procedure for Car data\nCREATE PROCEDURE dbo.GetCarData\nAS\nBEGIN\n    SET NOCOUNT ON;\n    SELECT CarID, Make, Model, Year, PersonID\n    FROM dbo.Car;\nEND;\nGO\n```\n\n#### Example 1.2: Consuming Refactored Procedures in T-SQL\n\n```sql\n-- Declare temporary tables to hold the results\nCREATE TABLE #PeopleTemp (\n    PersonID INT,\n    FirstName NVARCHAR(50),\n    LastName NVARCHAR(50),\n    Email NVARCHAR(100)\n);\n\nCREATE TABLE #CarsTemp (\n    CarID INT,\n    Make NVARCHAR(50),\n    Model NVARCHAR(50),\n    Year INT,\n    PersonID INT\n);\n\n-- Execute and insert results from the first procedure\nINSERT INTO #PeopleTemp (PersonID, FirstName, LastName, Email)\nEXEC dbo.GetPeopleData;\n\n-- Execute and insert results from the second procedure\nINSERT INTO #CarsTemp (CarID, Make, Model, Year, PersonID)\nEXEC dbo.GetCarData;\n\n-- Now you can work with the data in your temporary tables\nSELECT 'People Data' AS Source, * FROM #PeopleTemp;\nSELECT 'Car Data' AS Source, * FROM #CarsTemp;\n\n-- Clean up temporary tables\nDROP TABLE #PeopleTemp;\nDROP TABLE #CarsTemp;\nGO\n```\n\n#### Example 1.3: Recreating the Original Multi-Result Behavior (Optional)\n\nIf you still need a single entry point that returns both result sets for client applications, you can create a wrapper procedure:\n\n```sql\n-- Wrapper procedure to mimic the original multi-result behavior\nCREATE PROCEDURE dbo.GetSomethingCombined\nAS\nBEGIN\n    SET NOCOUNT ON;\n    EXEC dbo.GetPeopleData;\n    EXEC dbo.GetCarData;\nEND;\nGO\n\n-- How a client application would call this (e.g., .NET SqlDataReader)\n-- This would return two result sets, just like the original dbo.GetSomething\n-- EXEC dbo.GetSomethingCombined;\n```\n\n### Considerations\n\n*   **Schema Changes:** If the schema of the underlying tables changes, you'll need to update the corresponding refactored procedures and any `INSERT...EXEC` statements that rely on their output schema.\n*   **Transaction Management:** If the original procedure performed multiple DML operations across result sets within a single transaction, ensure your refactored approach maintains transactional integrity if needed.\n*   **Overhead:** Calling multiple procedures incurs a slight overhead compared to a single call, but for most applications, the benefits of modularity outweigh this.\n\n## Method 2: Parameterized Stored Procedure for Selective Retrieval\n\n**Persona Focus:** üîß Problem Solver, üöÄ Speed Seeker, ‚ö° Legacy Maintainer\n\nThis method is a good compromise when you cannot fully refactor the stored procedure into separate entities, but you need the flexibility to retrieve specific result sets or all of them. It involves adding a parameter to the existing stored procedure that acts as a \"result set indicator.\"\n\n### How it Works\n\nThe stored procedure accepts an integer or string parameter. Based on the value of this parameter, `IF` or `CASE` statements control which `SELECT` statements are executed and thus which result sets are returned.\n\n### Implementation Steps\n\n1.  **Add Parameter:** Introduce a new input parameter (e.g., `@ResultSetIndicator INT`) to your existing multi-result stored procedure.\n2.  **Conditional Logic:** Wrap each `SELECT` statement with `IF` conditions that check the value of `@ResultSetIndicator`.\n3.  **Update Calling Code:** When calling the procedure, pass the appropriate value for `@ResultSetIndicator` to get the desired result set(s).\n\n### Code Examples\n\nLet's use our `dbo.GetSomething` procedure again:\n\n```sql\n-- Original multi-result stored procedure\n-- (Assume dbo.Person and dbo.Car tables exist and are populated)\nCREATE PROCEDURE dbo.GetSomething\nAS\nBEGIN\n    SELECT PersonID, FirstName, LastName, Email FROM dbo.Person;\n    SELECT CarID, Make, Model, Year, PersonID FROM dbo.Car;\nEND;\nGO\n```\n\n#### Example 2.1: Modifying the Stored Procedure with a Parameter\n\n```sql\n-- Drop the old procedure if it exists\nIF OBJECT_ID('dbo.GetSomethingSelective') IS NOT NULL\n    DROP PROCEDURE dbo.GetSomethingSelective;\nGO\n\n-- Create the new parameterized procedure\nCREATE PROCEDURE dbo.GetSomethingSelective\n    @ResultSetIndicator INT = 0 -- 0: All, 1: People, 2: Cars\nAS\nBEGIN\n    SET NOCOUNT ON;\n\n    -- Result Set 1: People\n    IF @ResultSetIndicator = 0 OR @ResultSetIndicator = 1\n    BEGIN\n        SELECT PersonID, FirstName, LastName, Email\n        FROM dbo.Person;\n    END;\n\n    -- Result Set 2: Cars\n    IF @ResultSetIndicator = 0 OR @ResultSetIndicator = 2\n    BEGIN\n        SELECT CarID, Make, Model, Year, PersonID\n        FROM dbo.Car;\n    END;\nEND;\nGO\n```\n\n#### Example 2.2: Consuming Specific Result Sets in T-SQL\n\n```sql\n-- Get only People data\nCREATE TABLE #PeopleOnly (\n    PersonID INT,\n    FirstName NVARCHAR(50),\n    LastName NVARCHAR(50),\n    Email NVARCHAR(100)\n);\nINSERT INTO #PeopleOnly (PersonID, FirstName, LastName, Email)\nEXEC dbo.GetSomethingSelective @ResultSetIndicator = 1;\nSELECT 'People Only' AS Source, * FROM #PeopleOnly;\nDROP TABLE #PeopleOnly;\nGO\n\n-- Get only Car data\nCREATE TABLE #CarsOnly (\n    CarID INT,\n    Make NVARCHAR(50),\n    Model NVARCHAR(50),\n    Year INT,\n    PersonID INT\n);\nINSERT INTO #CarsOnly (CarID, Make, Model, Year, PersonID)\nEXEC dbo.GetSomethingSelective @ResultSetIndicator = 2;\nSELECT 'Cars Only' AS Source, * FROM #CarsOnly;\nDROP TABLE #CarsOnly;\nGO\n```\n\n#### Example 2.3: Consuming All Result Sets (Default Behavior)\n\n```sql\n-- Execute with default parameter (0) to get all result sets\n-- This will return two result sets, similar to the original procedure\nEXEC dbo.GetSomethingSelective @ResultSetIndicator = 0;\nGO\n\n-- Or simply:\nEXEC dbo.GetSomethingSelective;\nGO\n```\n\n### Considerations\n\n*   **Parameter Management:** You need to consistently manage the `@ResultSetIndicator` parameter in all calling code.\n*   **Procedure Complexity:** The procedure can become more complex with many `SELECT` statements and conditional logic.\n*   **Performance:** While you avoid executing unnecessary `SELECT` statements, the procedure still contains all the logic, which might be slightly less efficient than completely separate procedures if the conditional logic itself is complex.\n*   **Schema Mismatch:** If you try to `INSERT...EXEC` a call that returns multiple result sets (e.g., `EXEC dbo.GetSomethingSelective @ResultSetIndicator = 0`), it will still fail because `INSERT...EXEC` expects a single, schema-matching result set. This method is primarily for *selectively* retrieving one result set at a time into a temporary table, or for client applications that can handle multiple result sets but want to control which ones are returned.\n\n## Method 3: Using SqlDataReader.NextResult() in .NET\n\n**Persona Focus:** üé® Output Focused, ‚ö° Legacy Maintainer, üìö Learning Explorer\n\nThis is the standard and most efficient way to handle multiple result sets from a stored procedure when consuming them from a .NET application. The `SqlDataReader` object provides the `NextResult()` method specifically for this purpose.\n\n### How it Works\n\nAfter executing a command that returns multiple result sets, the `SqlDataReader` initially points to the first result set. Calling `reader.NextResult()` advances the reader to the next available result set. You can call it repeatedly until it returns `false`, indicating no more result sets are available.\n\n### Implementation Steps\n\n1.  **Establish Connection:** Create a `SqlConnection` object.\n2.  **Create Command:** Create a `SqlCommand` object, setting its `CommandType` to `StoredProcedure` and `CommandText` to your stored procedure name.\n3.  **Execute Reader:** Call `command.ExecuteReader()` to get a `SqlDataReader`.\n4.  **Iterate Result Sets:** Use a `do...while(reader.NextResult())` loop to process each result set. Inside the loop, use `reader.Read()` to iterate through the rows of the current result set.\n\n### Code Examples\n\nLet's use our original `dbo.GetSomething` procedure that returns two result sets:\n\n```sql\n-- Original multi-result stored procedure\n-- (Assume dbo.Person and dbo.Car tables exist and are populated)\nCREATE PROCEDURE dbo.GetSomething\nAS\nBEGIN\n    SET NOCOUNT ON;\n    SELECT PersonID, FirstName, LastName, Email FROM dbo.Person;\n    SELECT CarID, Make, Model, Year, PersonID FROM dbo.Car;\nEND;\nGO\n```\n\n#### Example 3.1: Basic .NET Consumption with `SqlDataReader.NextResult()`\n\n```csharp\nusing System;\nusing System.Data;\nusing System.Data.SqlClient;\nusing System.Collections.Generic;\n\npublic class DataReaderExample\n{\n    public static void ProcessMultipleResultSets(string connectionString, string storedProcedureName)\n    {\n        using (SqlConnection connection = new SqlConnection(connectionString))\n        {\n            SqlCommand command = new SqlCommand(storedProcedureName, connection);\n            command.CommandType = CommandType.StoredProcedure;\n\n            try\n            {\n                connection.Open();\n                SqlDataReader reader = command.ExecuteReader();\n\n                int resultSetIndex = 0;\n                do\n                {\n                    resultSetIndex++;\n                    Console.WriteLine($\"\\n--- Processing Result Set {resultSetIndex} ---\");\n\n                    if (reader.HasRows)\n                    {\n                        // Get column names for the current result set\n                        List<string> columnNames = new List<string>();\n                        for (int i = 0; i < reader.FieldCount; i++)\n                        {\n                            columnNames.Add(reader.GetName(i));\n                        }\n                        Console.WriteLine($\"Columns: {string.Join(\", \", columnNames)}\");\n\n                        // Read rows from the current result set\n                        while (reader.Read())\n                        {\n                            // Access data by column name or index\n                            // Example: Dynamically print all column values\n                            for (int i = 0; i < reader.FieldCount; i++)\n                            {\n                                Console.Write($\"{reader.GetName(i)}: {reader.GetValue(i)} \\t\");\n                            }\n                            Console.WriteLine();\n                        }\n                    }\n                    else\n                    {\n                        Console.WriteLine(\"No rows found in this result set.\");\n                    }\n\n                } while (reader.NextResult()); // Move to the next result set\n\n                reader.Close();\n            }\n            catch (SqlException ex)\n            {\n                Console.WriteLine($\"SQL Error: {ex.Message}\");\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"General Error: {ex.Message}\");\n            }\n        }\n    }\n\n    public static void Main(string[] args)\n    {\n        string connectionString = \"Data Source=.;Initial Catalog=YourDatabaseName;Integrated Security=True\";\n        string storedProcedureName = \"dbo.GetSomething\"; // Our example SP\n\n        // Ensure dbo.Person, dbo.Car, and dbo.GetSomething are created and populated\n        // You can run the setup script from the \"Ready-to-Use Code\" section first.\n\n        ProcessMultipleResultSets(connectionString, storedProcedureName);\n    }\n}\n```\n\n#### Example 3.2: Mapping to Specific Objects\n\n```csharp\nusing System;\nusing System.Data;\nusing System.Data.SqlClient;\nusing System.Collections.Generic;\n\n// Define simple POCOs for mapping\npublic class Person\n{\n    public int PersonID { get; set; }\n    public string FirstName { get; set; }\n    public string LastName { get; set; }\n    public string Email { get; set; }\n}\n\npublic class Car\n{\n    public int CarID { get; set; }\n    public string Make { get; set; }\n    public string Model { get; set; }\n    public int Year { get; set; }\n    public int PersonID { get; set; }\n}\n\npublic class DataReaderMapperExample\n{\n    public static (List<Person> people, List<Car> cars) GetPeopleAndCars(string connectionString, string storedProcedureName)\n    {\n        List<Person> people = new List<Person>();\n        List<Car> cars = new List<Car>();\n\n        using (SqlConnection connection = new SqlConnection(connectionString))\n        {\n            SqlCommand command = new SqlCommand(storedProcedureName, connection);\n            command.CommandType = CommandType.StoredProcedure;\n\n            connection.Open();\n            using (SqlDataReader reader = command.ExecuteReader())\n            {\n                // First result set: People\n                while (reader.Read())\n                {\n                    people.Add(new Person\n                    {\n                        PersonID = reader.GetInt32(reader.GetOrdinal(\"PersonID\")),\n                        FirstName = reader.GetString(reader.GetOrdinal(\"FirstName\")),\n                        LastName = reader.GetString(reader.GetOrdinal(\"LastName\")),\n                        Email = reader.GetString(reader.GetOrdinal(\"Email\"))\n                    });\n                }\n\n                // Move to the second result set: Cars\n                if (reader.NextResult())\n                {\n                    while (reader.Read())\n                    {\n                        cars.Add(new Car\n                        {\n                            CarID = reader.GetInt32(reader.GetOrdinal(\"CarID\")),\n                            Make = reader.GetString(reader.GetOrdinal(\"Make\")),\n                            Model = reader.GetString(reader.GetOrdinal(\"Model\")),\n                            Year = reader.GetInt32(reader.GetOrdinal(\"Year\")),\n                            PersonID = reader.GetInt32(reader.GetOrdinal(\"PersonID\"))\n                        });\n                    }\n                }\n            }\n        }\n        return (people, cars);\n    }\n\n    public static void Main(string[] args)\n    {\n        string connectionString = \"Data Source=.;Initial Catalog=YourDatabaseName;Integrated Security=True\";\n        string storedProcedureName = \"dbo.GetSomething\";\n\n        var (peopleList, carsList) = GetPeopleAndCars(connectionString, storedProcedureName);\n\n        Console.WriteLine(\"--- People List ---\");\n        foreach (var p in peopleList)\n        {\n            Console.WriteLine($\"ID: {p.PersonID}, Name: {p.FirstName} {p.LastName}, Email: {p.Email}\");\n        }\n\n        Console.WriteLine(\"\\n--- Car List ---\");\n        foreach (var c in carsList)\n        {\n            Console.WriteLine($\"ID: {c.CarID}, Make: {c.Make}, Model: {c.Model}, Year: {c.Year}, PersonID: {c.PersonID}\");\n        }\n    }\n}\n```\n\n### Considerations\n\n*   **Client-Side Only:** This method is exclusively for client applications (like .NET, Java, Python with appropriate database drivers) and does not help with consuming multiple result sets directly within T-SQL.\n*   **Order Dependency:** The client code must know the expected order and schema of the result sets to correctly process them.\n*   **Resource Management:** Always ensure `SqlDataReader` and `SqlConnection` objects are properly disposed of (e.g., using `using` statements) to prevent resource leaks.\n\n## Method 4: CLR Stored Procedure with SqlDataReader.NextResult()\n\n**Persona Focus:** üèóÔ∏è Architecture Builder, üîß Problem Solver (for complex scenarios)\n\nWhen you need the power of `SqlDataReader.NextResult()` but must operate within the SQL Server environment (e.g., to process multiple result sets and then insert them into other tables or perform further T-SQL logic), a Common Language Runtime (CLR) stored procedure can bridge the gap. This approach allows you to write C# (or other .NET languages) code that executes within SQL Server.\n\n### How it Works\n\nA CLR stored procedure can connect back to the same SQL Server instance (or another) using a `SqlConnection` and `SqlCommand`. Inside the CLR procedure, you can execute the target multi-result stored procedure, use `SqlDataReader.NextResult()` to iterate through its result sets, and then process each result set as needed (e.g., insert into temporary tables, perform aggregations, etc.). Finally, the CLR procedure can return its own result set(s) or output parameters.\n\n### Implementation Steps (High-Level)\n\n1.  **Enable CLR:** Ensure CLR integration is enabled on your SQL Server instance.\n2.  **Create .NET Project:** Develop a C# class library project in Visual Studio.\n3.  **Write CLR Code:**\n    *   Create a `SqlProcedure` method.\n    *   Inside this method, establish a `SqlConnection` (using `context connection=true` for in-process connections).\n    *   Execute the target multi-result stored procedure using `SqlCommand.ExecuteReader()`.\n    *   Use `SqlDataReader.NextResult()` to iterate through result sets.\n    *   Process each result set (e.g., read data, build `DataTable`s, or use `SqlPipe.Send()` to return results directly to the caller).\n4.  **Deploy Assembly:** Compile the project and deploy the resulting assembly to SQL Server.\n5.  **Create CLR Stored Procedure:** Create a T-SQL stored procedure that points to your CLR method.\n\n### Cloud Architecture Diagram: CLR Stored Procedure Flow\n\n```mermaid\ngraph TD\n    subgraph SQL Server Instance\n        A[T-SQL Caller] --> B(CLR Stored Procedure)\n        B -- Executes --> C(Internal SqlConnection)\n        C -- Calls Multi-Result SP --> D(Target Multi-Result Stored Procedure)\n        D -- Returns Result Sets --> E(SqlDataReader in CLR SP)\n        E -- NextResult() --> F(Process Result Set 1)\n        E -- NextResult() --> G(Process Result Set 2)\n        F -- e.g., Insert into #TempTable --> H(SQL Server TempDB)\n        G -- e.g., Insert into #TempTable --> H\n        B -- Returns Final Result/Output --> A\n    end\n\n    style A fill:#bbf,stroke:#333,stroke-width:2px;\n    style B fill:#f9f,stroke:#333,stroke-width:2px;\n    style C fill:#ccf,stroke:#333,stroke-width:2px;\n    style D fill:#ccf,stroke:#333,stroke-width:2px;\n    style E fill:#ccf,stroke:#333,stroke-width:2px;\n    style F fill:#ccf,stroke:#333,stroke-width:2px;\n    style G fill:#ccf,stroke:#333,stroke-width:2px;\n    style H fill:#ccf,stroke:#333,stroke-width:2px;\n```\n\n### Code Examples\n\n#### Example 4.1: C# CLR Code (Visual Studio Project)\n\nCreate a new C# Class Library project (e.g., `SqlClrMultiResultReader`).\n\n```csharp\nusing System;\nusing System.Data;\nusing System.Data.SqlClient;\nusing System.Data.SqlTypes;\nusing Microsoft.SqlServer.Server;\nusing System.Collections.Generic;\n\npublic class MultiResultSetProcessor\n{\n    [SqlProcedure]\n    public static void ProcessAndReturnMultiResultSets(SqlString spName)\n    {\n        // Use the context connection for an in-process connection to the same SQL Server instance\n        using (SqlConnection connection = new SqlConnection(\"context connection=true\"))\n        {\n            SqlCommand command = new SqlCommand(spName.ToString(), connection);\n            command.CommandType = CommandType.StoredProcedure;\n\n            connection.Open();\n\n            using (SqlDataReader reader = command.ExecuteReader())\n            {\n                int resultSetIndex = 0;\n                do\n                {\n                    resultSetIndex++;\n                    SqlContext.Pipe.Send($\"--- Processing Result Set {resultSetIndex} from '{spName}' ---\");\n\n                    if (reader.HasRows)\n                    {\n                        // Send the current result set directly to the caller\n                        // This is useful if you want the CLR SP to just pass through the results\n                        SqlContext.Pipe.Send(reader);\n                    }\n                    else\n                    {\n                        SqlContext.Pipe.Send(\"No rows found in this result set.\");\n                    }\n\n                } while (reader.NextResult());\n            }\n        }\n    }\n\n    // Example of processing and inserting into a temporary table (more complex)\n    [SqlProcedure]\n    public static void ProcessAndInsertMultiResultSets(SqlString spName)\n    {\n        using (SqlConnection connection = new SqlConnection(\"context connection=true\"))\n        {\n            connection.Open();\n\n            // Create temporary tables for demonstration (must match schema of target SP)\n            // In a real scenario, you'd likely create these outside or dynamically.\n            SqlCommand createTempTablesCmd = new SqlCommand(@\"\n                IF OBJECT_ID('tempdb..#ClrPeople') IS NOT NULL DROP TABLE #ClrPeople;\n                CREATE TABLE #ClrPeople (PersonID INT, FirstName NVARCHAR(50), LastName NVARCHAR(50), Email NVARCHAR(100));\n\n                IF OBJECT_ID('tempdb..#ClrCars') IS NOT NULL DROP TABLE #ClrCars;\n                CREATE TABLE #ClrCars (CarID INT, Make NVARCHAR(50), Model NVARCHAR(50), Year INT, PersonID INT);\n            \", connection);\n            createTempTablesCmd.ExecuteNonQuery();\n\n            SqlCommand command = new SqlCommand(spName.ToString(), connection);\n            command.CommandType = CommandType.StoredProcedure;\n\n            using (SqlDataReader reader = command.ExecuteReader())\n            {\n                // First result set: People\n                if (reader.HasRows)\n                {\n                    using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connection))\n                    {\n                        bulkCopy.DestinationTableName = \"#ClrPeople\";\n                        bulkCopy.WriteToServer(reader);\n                    }\n                }\n\n                // Second result set: Cars\n                if (reader.NextResult() && reader.HasRows)\n                {\n                    using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connection))\n                    {\n                        bulkCopy.DestinationTableName = \"#ClrCars\";\n                        bulkCopy.WriteToServer(reader);\n                    }\n                }\n            }\n\n            // Now the data is in temp tables, can be queried by the caller T-SQL\n            SqlContext.Pipe.Send(\"Data from multi-result SP inserted into #ClrPeople and #ClrCars.\");\n        }\n    }\n}\n```\n\n#### Example 4.2: T-SQL Deployment and Usage\n\n```sql\n-- Step 1: Enable CLR (if not already enabled)\nEXEC sp_configure 'clr enabled', 1;\nRECONFIGURE;\nGO\n\n-- Step 2: Create a database master key if you plan to sign your assembly\n-- (Recommended for production, but optional for simple testing)\n-- CREATE MASTER KEY ENCRYPTION BY PASSWORD = 'YourStrongPassword!';\n-- GO\n\n-- Step 3: Create an ASYMMETRIC KEY from the assembly (if signing)\n-- This allows you to grant UNSAFE ASSEMBLY permission without TRUSTWORTHY ON\n-- CREATE ASYMMETRIC KEY SqlClrMultiResultReaderKey FROM EXECUTABLE FILE = 'C:\\Path\\To\\SqlClrMultiResultReader.dll';\n-- CREATE LOGIN SqlClrMultiResultReaderLogin FROM ASYMMETRIC KEY SqlClrMultiResultReaderKey;\n-- GRANT UNSAFE ASSEMBLY TO SqlClrMultiResultReaderLogin;\n-- GO\n\n-- Step 4: Deploy the assembly (replace path with your actual DLL path)\n-- For simplicity, we'll use PERMISSION_SET = UNSAFE, which requires TRUSTWORTHY ON or ASYMMETRIC KEY\nALTER DATABASE YourDatabaseName SET TRUSTWORTHY ON; -- Use with caution in production!\nGO\n\nCREATE ASSEMBLY SqlClrMultiResultReader\nFROM 'C:\\Path\\To\\SqlClrMultiResultReader.dll' -- Update this path!\nWITH PERMISSION_SET = UNSAFE;\nGO\n\n-- Step 5: Create the CLR Stored Procedures\nCREATE PROCEDURE dbo.ClrGetMultiResultSets\n    @spName NVARCHAR(256)\nAS EXTERNAL NAME SqlClrMultiResultReader.[MultiResultSetProcessor].ProcessAndReturnMultiResultSets;\nGO\n\nCREATE PROCEDURE dbo.ClrInsertMultiResultSetsIntoTempTables\n    @spName NVARCHAR(256)\nAS EXTERNAL NAME SqlClrMultiResultReader.[MultiResultSetProcessor].ProcessAndInsertMultiResultSets;\nGO\n\n-- Step 6: Test the CLR Stored Procedures\n-- Ensure dbo.GetSomething exists and returns multiple result sets (from previous examples)\nEXEC dbo.ClrGetMultiResultSets 'dbo.GetSomething';\nGO\n\n-- Test the insertion into temp tables\nEXEC dbo.ClrInsertMultiResultSetsIntoTempTables 'dbo.GetSomething';\n-- Now query the temp tables created by the CLR SP\nSELECT 'CLR People Temp' AS Source, * FROM #ClrPeople;\nSELECT 'CLR Cars Temp' AS Source, * FROM #ClrCars;\nGO\n\n-- Clean up temp tables (if not dropped by CLR SP)\nDROP TABLE IF EXISTS #ClrPeople;\nDROP TABLE IF EXISTS #ClrCars;\nGO\n\n-- Step 7: Clean up (optional)\n-- DROP PROCEDURE dbo.ClrGetMultiResultSets;\n-- DROP PROCEDURE dbo.ClrInsertMultiResultSetsIntoTempTables;\n-- DROP ASSEMBLY SqlClrMultiResultReader;\n-- ALTER DATABASE YourDatabaseName SET TRUSTWORTHY OFF;\n-- DROP LOGIN SqlClrMultiResultReaderLogin;\n-- DROP ASYMMETRIC KEY SqlClrMultiResultReaderKey;\n-- EXEC sp_configure 'clr enabled', 0; RECONFIGURE;\n```\n\n### Considerations\n\n*   **Complexity:** CLR integration adds a layer of complexity to development, deployment, and debugging.\n*   **Security:** `UNSAFE` permission set (often required for `SqlBulkCopy` or `context connection=true`) can pose security risks if not managed carefully. `TRUSTWORTHY ON` should be avoided in production if possible, favoring signed assemblies.\n*   **Performance:** While powerful, CLR procedures have startup overhead. For simple tasks, native T-SQL is usually faster. For complex data manipulation or external integration, CLR can be highly performant.\n*   **Maintenance:** Requires .NET development skills in addition to T-SQL.\n*   **Limited Use:** This is a niche solution for specific problems where T-SQL alone is insufficient and client-side processing is not an option.\n\n## Method 5: Dynamic SQL with Temporary Tables (Advanced T-SQL Workaround)\n\n**Persona Focus:** üîß Problem Solver, ‚ö° Legacy Maintainer (when refactoring is impossible)\n\nThis method is a T-SQL workaround for situations where you cannot modify the original stored procedure, and you need to capture its multiple result sets into separate temporary tables within a T-SQL context. It's considered \"hacky\" because it relies on dynamic SQL and careful schema management.\n\n**Warning:** This method is generally discouraged due to its complexity, potential for SQL injection (if not handled carefully), and maintenance challenges. Only use if other, cleaner methods are not feasible.\n\n### How it Works\n\nThe core idea is to execute the multi-result stored procedure within a dynamic SQL string. The challenge is that `INSERT...EXEC` only captures the *first* result set. To get subsequent result sets, you would theoretically need to \"skip\" the earlier ones, which T-SQL doesn't natively support.\n\nThe \"hacky\" solution often involves:\n1.  **Creating a wrapper SP:** A new SP that calls the original multi-result SP.\n2.  **Using `OPENROWSET` or `OPENQUERY` with `EXEC`:** This is typically used for linked servers, but can sometimes be coerced to work with local `EXEC` calls, though it's highly problematic for multiple result sets.\n3.  **The most common (still hacky) approach:** Modify the original SP (if possible) to return only one result set at a time based on a parameter (Method 2), or use a CLR SP (Method 4). If the original SP *cannot* be modified, and you *must* stay in T-SQL, you are in a very difficult spot.\n\nLet's re-evaluate the original problem statement and common \"hacks\" that are often proposed but don't quite work for *multiple* result sets in T-SQL without modifying the source SP.\n\n**The `INSERT...EXEC` limitation:**\n`INSERT INTO #TempTable EXEC MyMultiResultSetSP;` will *always* fail if `MyMultiResultSetSP` returns more than one result set, or if the first result set's schema doesn't match `#TempTable`. It will *never* capture subsequent result sets.\n\n**The \"trick\" mentioned in one of the answers (Answer 6) about `SELECT ... INTO temp1 FROM table1` inside a procedure:**\nThis creates *permanent* tables (`temp1`, `temp2`) in the database, not temporary tables. This is highly problematic for concurrency and cleanup.\n\n```sql\n-- Example of the problematic \"trick\" (DO NOT USE IN PRODUCTION)\nCREATE PROC dbo.test_something_bad\nAS\nBEGIN\n    -- This creates a permanent table named temp1\n    SELECT a, b INTO temp1 FROM table1;\n    -- This creates a permanent table named temp2\n    SELECT b, c INTO temp2 FROM table2;\nEND;\nGO\n\n-- If two users run this concurrently, they will conflict on table creation.\n-- Also, these tables are never dropped automatically.\n```\n\n**The only viable T-SQL workaround without modifying the source SP is extremely complex and often involves parsing the output as XML or JSON (Method 6), or using CLR (Method 4).**\n\nHowever, if you *can* modify the stored procedure, even slightly, the parameterized approach (Method 2) is the closest T-SQL solution to selectively retrieving results.\n\n**Let's assume a scenario where you *can* create a wrapper, but the original SP is fixed.**\nThis is still very difficult. The only way to \"skip\" result sets in T-SQL is if the original SP is designed to conditionally return them.\n\n**If the original SP is truly fixed and returns multiple result sets, and you *must* consume them in T-SQL without CLR, the only way is to capture the *entire output* as a single string (e.g., XML/JSON) and then parse it.** This leads us to Method 6.\n\n**Therefore, Method 5, as a pure T-SQL way to capture *separate* result sets from an *unmodified* multi-result SP, is largely impractical or relies on highly problematic techniques.** The closest \"workaround\" is to use the parameterized approach (Method 2) if modification is possible, or CLR (Method 4) if not.\n\n**Let's illustrate a common *misconception* or a technique that *doesn't work* for multiple result sets, to highlight why this is hard.**\n\n#### Example 5.1: Attempting to use `OPENROWSET` (Fails for multiple result sets)\n\n```sql\n-- This will only capture the FIRST result set, and will fail if the SP returns more.\n-- It also requires Ad Hoc Distributed Queries to be enabled, which is a security risk.\nEXEC sp_configure 'show advanced options', 1;\nRECONFIGURE;\nEXEC sp_configure 'Ad Hoc Distributed Queries', 1;\nRECONFIGURE;\nGO\n\n-- Create a dummy multi-result SP for demonstration\nIF OBJECT_ID('dbo.MyMultiResultSP') IS NOT NULL DROP PROCEDURE dbo.MyMultiResultSP;\nGO\nCREATE PROCEDURE dbo.MyMultiResultSP\nAS\nBEGIN\n    SELECT 1 AS ID, 'First' AS Name;\n    SELECT 2 AS ID, 'Second' AS Name, GETDATE() AS CurrentDate;\nEND;\nGO\n\n-- Attempt to capture the first result set\nCREATE TABLE #Result1 (ID INT, Name NVARCHAR(50));\nINSERT INTO #Result1\nSELECT ID, Name\nFROM OPENROWSET('SQLNCLI11', 'Server=(local);Trusted_Connection=yes;',\n                'EXEC YourDatabaseName.dbo.MyMultiResultSP;');\n-- This will fail with \"The OLE DB provider \"SQLNCLI11\" for linked server \"(null)\"\n-- returned a rowset that was not expected.\" because the SP returns multiple result sets.\n-- Even if it didn't, it would only ever get the first.\n\nSELECT * FROM #Result1;\nDROP TABLE #Result1;\nGO\n\n-- Clean up\nEXEC sp_configure 'Ad Hoc Distributed Queries', 0;\nRECONFIGURE;\nEXEC sp_configure 'show advanced options', 0;\nRECONFIGURE;\nDROP PROCEDURE dbo.MyMultiResultSP;\nGO\n```\n\n**Conclusion for Method 5:** For truly *unmodified* multi-result stored procedures, capturing *multiple distinct* result sets into separate T-SQL temporary tables is not directly supported by `INSERT...EXEC` or `OPENROWSET`. The most practical T-SQL solutions involve either modifying the source SP (Method 1 or 2) or using CLR (Method 4) or XML/JSON output (Method 6).\n\n## Method 6: XML Output for Multiple Result Sets\n\n**Persona Focus:** üé® Output Focused, ‚ö° Legacy Maintainer (for complex, hierarchical data)\n\nWhen you need to retrieve multiple result sets from a stored procedure in a single, structured output that can be parsed within T-SQL or by a client, converting the results to XML (or JSON) is a viable, albeit often performance-intensive, option. This method consolidates all data into a single string, which can then be processed.\n\n### How it Works\n\nYou modify the stored procedure to combine all its `SELECT` statements into a single XML document. This typically involves using `FOR XML PATH` or `FOR XML AUTO` with `ROOT` and `TYPE` directives to create a well-formed XML structure. The client or calling T-SQL then receives this single XML string and parses it to extract the individual data sets.\n\n### Implementation Steps\n\n1.  **Modify SP:** Change the `SELECT` statements in your stored procedure to use `FOR XML PATH`, `FOR XML AUTO`, or `FOR XML RAW` clauses.\n2.  **Combine XML:** If multiple logical result sets are needed, you might combine them into a single root XML element.\n3.  **Return XML:** The stored procedure returns this single XML string.\n4.  **Parse XML:** The calling T-SQL or client application parses the XML string to extract the desired data.\n\n### Code Examples\n\nLet's use our `dbo.Person` and `dbo.Car` tables.\n\n#### Example 6.1: Stored Procedure Returning XML\n\n```sql\n-- Drop existing SP if it exists\nIF OBJECT_ID('dbo.GetSomethingAsXml') IS NOT NULL\n    DROP PROCEDURE dbo.GetSomethingAsXml;\nGO\n\nCREATE PROCEDURE dbo.GetSomethingAsXml\nAS\nBEGIN\n    SET NOCOUNT ON;\n\n    SELECT\n        (SELECT PersonID, FirstName, LastName, Email\n         FROM dbo.Person\n         FOR XML PATH('Person'), TYPE) AS People,\n        (SELECT CarID, Make, Model, Year, PersonID\n         FROM dbo.Car\n         FOR XML PATH('Car'), TYPE) AS Cars\n    FOR XML PATH('Data'), ROOT('Root'), TYPE;\nEND;\nGO\n```\n\n#### Example 6.2: Consuming XML in T-SQL\n\n```sql\n-- Declare a variable to hold the XML output\nDECLARE @xmlData XML;\n\n-- Execute the stored procedure and capture the XML output\nINSERT INTO @xmlData\nEXEC dbo.GetSomethingAsXml;\n\n-- Now parse the XML to extract data into temporary tables or table variables\n\n-- Extract People data\nSELECT\n    T.C.value('PersonID[1]', 'INT') AS PersonID,\n    T.C.value('FirstName[1]', 'NVARCHAR(50)') AS FirstName,\n    T.C.value('LastName[1]', 'NVARCHAR(50)') AS LastName,\n    T.C.value('Email[1]', 'NVARCHAR(100)') AS Email\nFROM @xmlData.nodes('/Root/Data/People/Person') AS T(C);\n\n-- Extract Car data\nSELECT\n    T.C.value('CarID[1]', 'INT') AS CarID,\n    T.C.value('Make[1]', 'NVARCHAR(50)') AS Make,\n    T.C.value('Model[1]', 'NVARCHAR(50)') AS Model,\n    T.C.value('Year[1]', 'INT') AS Year,\n    T.C.value('PersonID[1]', 'INT') AS PersonID\nFROM @xmlData.nodes('/Root/Data/Cars/Car') AS T(C);\nGO\n```\n\n#### Example 6.3: Stored Procedure Returning JSON (SQL Server 2016+)\n\n```sql\n-- Drop existing SP if it exists\nIF OBJECT_ID('dbo.GetSomethingAsJson') IS NOT NULL\n    DROP PROCEDURE dbo.GetSomethingAsJson;\nGO\n\nCREATE PROCEDURE dbo.GetSomethingAsJson\nAS\nBEGIN\n    SET NOCOUNT ON;\n\n    SELECT\n        (SELECT PersonID, FirstName, LastName, Email\n         FROM dbo.Person\n         FOR JSON PATH) AS People,\n        (SELECT CarID, Make, Model, Year, PersonID\n         FROM dbo.Car\n         FOR JSON PATH) AS Cars\n    FOR JSON PATH, ROOT('Root');\nEND;\nGO\n```\n\n#### Example 6.4: Consuming JSON in T-SQL (SQL Server 2016+)\n\n```sql\n-- Declare a variable to hold the JSON output\nDECLARE @jsonData NVARCHAR(MAX);\n\n-- Execute the stored procedure and capture the JSON output\nINSERT INTO @jsonData\nEXEC dbo.GetSomethingAsJson;\n\n-- Now parse the JSON to extract data into temporary tables or table variables\n\n-- Extract People data\nSELECT\n    JSON_VALUE(value, '$.PersonID') AS PersonID,\n    JSON_VALUE(value, '$.FirstName') AS FirstName,\n    JSON_VALUE(value, '$.LastName') AS LastName,\n    JSON_VALUE(value, '$.Email') AS Email\nFROM OPENJSON(@jsonData, '$.Root.People') AS PeopleArray;\n\n-- Extract Car data\nSELECT\n    JSON_VALUE(value, '$.CarID') AS CarID,\n    JSON_VALUE(value, '$.Make') AS Make,\n    JSON_VALUE(value, '$.Model') AS Model,\n    JSON_VALUE(value, '$.Year') AS Year,\n    JSON_VALUE(value, '$.PersonID') AS PersonID\nFROM OPENJSON(@jsonData, '$.Root.Cars') AS CarsArray;\nGO\n```\n\n### Considerations\n\n*   **Performance Overhead:** Converting relational data to XML/JSON and then parsing it back is computationally expensive, especially for large datasets. This can significantly impact performance.\n*   **Data Types:** XML/JSON parsing can sometimes be tricky with specific data types (e.g., `XML` data type itself, spatial data).\n*   **Complexity:** The `FOR XML` and `FOR JSON` syntax can be complex to write and debug, especially for nested structures.\n*   **Schema Flexibility:** XML/JSON provides schema flexibility, which can be an advantage for highly variable result sets, but also means you lose the strong typing of relational tables until parsed.\n*   **SQL Server Version:** `FOR JSON` and `OPENJSON` are available from SQL Server ",
  "source_file": "/Users/thaddeus/Documents/on-going projects/deepv-stackoverflow-workflow-complete/data/workflow_queue/processed_question_20082889_retrieve-data-from-stored-procedure-which-has-multiple-result-sets.json",
  "generation_stats": {},
  "workflow_version": "deepv_stackoverflow_v1.0"
}