{
  "metadata": {
    "title": "Why does my JavaScript code receive a \"No 'Access-Control-Allow-Origin' header is present on the requested resource\" error, while Postman does not?: Complete Guide with 6 Solutions",
    "slug": "why-does-my-javascript-code-receive-a-no-access-control",
    "uniqueId": "d0cc8ebb",
    "category": "web-frontend",
    "subcategory": "javascript",
    "description": "The \"No 'Access-Control-Allow-Origin' header is present on the requested resource\" error occurs in browsers due to the Same-Origin Policy (SOP), a fundamenta...",
    "tags": [
      "javascript",
      "jquery",
      "cors",
      "postman",
      "same-origin-policy"
    ],
    "difficulty": "beginner",
    "readTime": 16,
    "publishedAt": "2025-09-17",
    "featured": true,
    "technology": "JavaScript",
    "votes": 3362,
    "answersCount": 8,
    "sourceStackOverflowId": "20035101",
    "generatedAt": "2025-09-17T19:22:21.963309",
    "workflowVersion": "deepv_stackoverflow_v1.0",
    "qualityMetrics": {
      "wordCount": 3127,
      "codeBlocks": 71,
      "sections": 17,
      "personaIntegration": 17,
      "practicalFocusScore": 100
    }
  },
  "content": "# Why does my JavaScript code receive a \"No 'Access-Control-Allow-Origin' header is present on the requested resource\" error, while Postman does not?: Complete Guide with 6 Solutions\n\n## Quick Answer\nThe \"No 'Access-Control-Allow-Origin' header is present on the requested resource\" error occurs in browsers due to the Same-Origin Policy (SOP), a fundamental security mechanism. SOP restricts web pages from making requests to a different domain than the one that served the page. Postman, being a development tool and not a browser, does not enforce SOP, allowing it to make cross-origin requests without encountering this restriction.\n\nTo quickly resolve this error for development or testing purposes, you can configure your server to send the `Access-Control-Allow-Origin` header. Here are a few common server-side quick fixes:\n\n**1. PHP (Server-Side)**\nAdd this at the very beginning of your PHP script that handles the API request:\n```php\n<?php\nheader('Access-Control-Allow-Origin: *');\nheader('Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS');\nheader('Access-Control-Allow-Headers: Content-Type, Authorization, X-Requested-With');\n?>\n```\n\n**2. Node.js with Express (Server-Side)**\nInstall `cors`: `npm install cors`\n```javascript\nconst express = require('express');\nconst cors = require('cors');\nconst app = express();\n\napp.use(cors()); // Enable CORS for all routes\n\napp.get('/api/data', (req, res) => {\n  res.json({ message: 'Data from API' });\n});\n\napp.listen(3000, () => {\n  console.log('Server listening on port 3000');\n});\n```\n\n**3. Flask (Python, Server-Side)**\nInstall `Flask-CORS`: `pip install -U Flask-CORS`\n```python\nfrom flask import Flask, jsonify\nfrom flask_cors import CORS\n\napp = Flask(__name__)\nCORS(app) # Enable CORS for all routes\n\n@app.route(\"/api/hello\")\ndef hello_world():\n    return jsonify(message=\"Hello from Flask API!\")\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n```\n\n**4. Nginx (Server Configuration)**\nAdd these directives within your `location` block for the API:\n```nginx\nlocation /api/ {\n    add_header 'Access-Control-Allow-Origin' '*';\n    add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';\n    add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range';\n    add_header 'Access-Control-Expose-Headers' 'Content-Length,Content-Range';\n\n    if ($request_method = 'OPTIONS') {\n        add_header 'Access-Control-Allow-Origin' '*';\n        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';\n        add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range';\n        add_header 'Access-Control-Max-Age' 1728000;\n        add_header 'Content-Type' 'text/plain charset=UTF-8';\n        add_header 'Content-Length' 0;\n        return 204;\n    }\n    # ... other proxy_pass or fastcgi_pass directives ...\n}\n```\n\n**5. Client-Side (Browser-Specific for Development)**\nFor *local development only*, you can disable web security in Chrome. **Do not use this in production.**\n```bash\nchrome.exe --user-data-dir=\"C:/Chrome dev session\" --disable-web-security --disable-site-isolation-trials\n```\nThis command opens a new Chrome instance with web security disabled, allowing cross-origin requests.\n\n## Choose Your Method\n```mermaid\nflowchart TD\n    A[Your Situation] --> B{Performance Critical?}\n    B -->|Yes| C[Method 1: Speed Optimized]\n    B -->|No| D{Learning Focus?}\n    D -->|Yes| E[Method 2: Educational]\n    D -->|No| F[Method 3: Quick Solution]\n```\n\n## Table of Contents\n- [Ready-to-Use Code](#ready-to-use-code)\n- [Method 1: Understanding CORS and Same-Origin Policy (SOP)](#method-1-understanding-cors-and-same-origin-policy-sop) (Learning Explorer, Architecture Builder)\n- [Method 2: Server-Side CORS Configuration](#method-2-server-side-cors-configuration) (Problem Solver, Architecture Builder, Legacy Maintainer)\n  - [2.1 Node.js with Express](#21-nodejs-with-express)\n  - [2.2 Python with Flask](#22-python-with-flask)\n  - [2.3 PHP](#23-php)\n  - [2.4 Java with Spring Boot](#24-java-with-spring-boot)\n  - [2.5 .NET Web API](#25-net-web-api)\n  - [2.6 Nginx Proxy Configuration](#26-nginx-proxy-configuration)\n  - [2.7 Apache HTTP Server Configuration](#27-apache-http-server-configuration)\n- [Method 3: Client-Side Proxies (Development/Advanced)](#method-3-client-side-proxies-developmentadvanced) (Speed Seeker, Problem Solver)\n  - [3.1 Webpack Dev Server Proxy](#31-webpack-dev-server-proxy)\n  - [3.2 Vite Proxy](#32-vite-proxy)\n- [Method 4: JSONP (Legacy/Specific Use Cases)](#method-4-jsonp-legacyspecific-use-cases) (Legacy Maintainer)\n- [Method 5: Disabling Browser Security (Development Only)](#method-5-disabling-browser-security-development-only) (Speed Seeker, Problem Solver)\n- [Method 6: Using a CORS Proxy Service](#method-6-using-a-cors-proxy-service) (Problem Solver, Speed Seeker)\n- [Performance Comparison](#performance-comparison)\n- [JavaScript Version Support](#javascript-version-support)\n- [Common Problems & Solutions](#common-problems--solutions)\n- [Real-World Examples](#real-world-examples)\n- [Related JavaScript Functions](#related-javascript-functions)\n- [Summary](#summary)\n- [Frequently Asked Questions](#frequently-asked-questions)\n- [Test Your Code](#test-your-code)\n\n## Ready-to-Use Code\n\nHere are several complete, working examples for common scenarios.\n\n**1. Basic Fetch Request with CORS enabled on server (Node.js/Express)**\n*Client-side JavaScript:*\n```javascript\n// Assuming your Node.js server is running on http://localhost:3000\nfetch('http://localhost:3000/api/data')\n  .then(response => {\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    return response.json();\n  })\n  .then(data => console.log('Client received:', data))\n  .catch(error => console.error('Fetch error:', error));\n```\n*Server-side Node.js (Express with CORS):*\n```javascript\nconst express = require('express');\nconst cors = require('cors');\nconst app = express();\nconst port = 3000;\n\napp.use(cors()); // Enable CORS for all origins\n\napp.get('/api/data', (req, res) => {\n  res.json({ message: 'Hello from Node.js API!', timestamp: new Date().toISOString() });\n});\n\napp.listen(port, () => {\n  console.log(`Node.js server listening at http://localhost:${port}`);\n});\n```\n\n**2. POST Request with Credentials (Flask Backend)**\n*Client-side JavaScript (using `fetch` with `credentials`):*\n```javascript\n// Assuming your Flask server is running on http://localhost:5000\nfetch('http://localhost:5000/api/login', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n  },\n  body: JSON.stringify({ username: 'user', password: 'password123' }),\n  credentials: 'include' // Important for sending cookies/auth headers\n})\n  .then(response => {\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    return response.json();\n  })\n  .then(data => console.log('Login successful:', data))\n  .catch(error => console.error('Login failed:', error));\n```\n*Server-side Python (Flask with `Flask-CORS` and `supports_credentials`):*\n```python\nfrom flask import Flask, request, jsonify\nfrom flask_cors import CORS\n\napp = Flask(__name__)\n# Allow specific origin and support credentials\nCORS(app, resources={r\"/api/*\": {\"origins\": \"http://localhost:8080\", \"supports_credentials\": True}})\n\n@app.route(\"/api/login\", methods=[\"POST\"])\ndef login():\n    data = request.get_json()\n    username = data.get('username')\n    password = data.get('password')\n\n    if username == 'user' and password == 'password123':\n        # In a real app, you'd set a session cookie or JWT here\n        response = jsonify(message=\"Login successful\", token=\"fake-jwt-token\")\n        response.set_cookie('session_id', 'some_session_value', httponly=True, samesite='None', secure=True)\n        return response\n    else:\n        return jsonify(message=\"Invalid credentials\"), 401\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=5000)\n```\n*Note: For `credentials: 'include'` to work, the server must respond with `Access-Control-Allow-Credentials: true` and `Access-Control-Allow-Origin` cannot be `*` (it must be a specific origin).*\n\n**3. jQuery AJAX Request with CORS (PHP Backend)**\n*Client-side JavaScript (using jQuery):*\n```javascript\n// Assuming your PHP server is running on http://localhost/api.php\n$.ajax({\n  type: 'GET',\n  url: 'http://localhost/api.php',\n  dataType: 'json',\n  crossDomain: true, // Explicitly state cross-domain\n  xhrFields: {\n    withCredentials: true // Send cookies if needed\n  },\n  success: function(data) {\n    console.log('jQuery AJAX success:', data);\n  },\n  error: function(xhr, status, error) {\n    console.error('jQuery AJAX error:', status, error, xhr.responseText);\n  }\n});\n```\n*Server-side PHP (`api.php`):*\n```php\n<?php\nheader('Access-Control-Allow-Origin: http://localhost:8080'); // Replace with your client's origin\nheader('Access-Control-Allow-Methods: GET, POST, OPTIONS');\nheader('Access-Control-Allow-Headers: Content-Type, Authorization, X-Requested-With');\nheader('Access-Control-Allow-Credentials: true'); // Required for withCredentials\n\nif ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {\n    // Preflight request, respond with 204 No Content\n    http_response_code(204);\n    exit();\n}\n\n// Simulate some data\n$data = [\n    'message' => 'Data from PHP API!',\n    'timestamp' => date('Y-m-d H:i:s')\n];\necho json_encode($data);\n?>\n```\n\n**4. Nginx as a Reverse Proxy for CORS**\n*Nginx configuration (`nginx.conf` or site-specific config):*\n```nginx\nserver {\n    listen 80;\n    server_name your-frontend-domain.com; # Your frontend domain\n\n    location / {\n        root /var/www/your-frontend-app; # Path to your frontend files\n        index index.html;\n        try_files $uri $uri/ /index.html;\n    }\n\n    location /api/ {\n        # Proxy requests to your backend API\n        proxy_pass http://your-backend-api.com:8080/api/; # Your actual backend API URL\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n\n        # CORS headers for the proxied API\n        add_header 'Access-Control-Allow-Origin' '*'; # Or specific origin\n        add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS';\n        add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization';\n        add_header 'Access-Control-Expose-Headers' 'Content-Length,Content-Range';\n\n        if ($request_method = 'OPTIONS') {\n            add_header 'Access-Control-Allow-Origin' '*';\n            add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS';\n            add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization';\n            add_header 'Access-Control-Max-Age' 1728000;\n            add_header 'Content-Type' 'text/plain charset=UTF-8';\n            add_header 'Content-Length' 0;\n            return 204;\n        }\n    }\n}\n```\n*Client-side JavaScript (making requests to the same origin, Nginx handles proxying):*\n```javascript\n// If your frontend is served from your-frontend-domain.com\n// and Nginx proxies /api/ to your backend\nfetch('/api/data') // Relative path, browser thinks it's same-origin\n  .then(response => response.json())\n  .then(data => console.log('Data via Nginx proxy:', data))\n  .catch(error => console.error('Error with Nginx proxy:', error));\n```\n\n**5. Webpack Dev Server Proxy Configuration**\n*`webpack.config.js` (for development):*\n```javascript\nconst path = require('path');\n\nmodule.exports = {\n  mode: 'development',\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist'),\n  },\n  devServer: {\n    static: {\n      directory: path.join(__dirname, 'public'),\n    },\n    compress: true,\n    port: 8080,\n    proxy: {\n      '/api': {\n        target: 'http://localhost:3000', // Your backend API server\n        changeOrigin: true, // Needed for virtual hosted sites\n        pathRewrite: { '^/api': '' }, // Remove /api prefix when forwarding to backend\n        secure: false, // For development with self-signed certs\n      },\n    },\n  },\n};\n```\n*Client-side JavaScript (making requests to the dev server, which proxies to backend):*\n```javascript\n// Your frontend code running on http://localhost:8080\nfetch('/api/data') // Request goes to webpack dev server, then proxied to http://localhost:3000/data\n  .then(response => response.json())\n  .then(data => console.log('Data via Webpack proxy:', data))\n  .catch(error => console.error('Error with Webpack proxy:', error));\n```\n\n**6. Vite Proxy Configuration**\n*`vite.config.js` (for development):*\n```javascript\nimport { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react';\n\nexport default defineConfig({\n  plugins: [react()],\n  server: {\n    port: 3000, // Your frontend dev server port\n    proxy: {\n      '/api': {\n        target: 'http://localhost:5000', // Your backend API server\n        changeOrigin: true,\n        rewrite: (path) => path.replace(/^\\/api/, ''),\n      },\n    },\n  },\n});\n```\n*Client-side JavaScript (making requests to the dev server, which proxies to backend):*\n```javascript\n// Your frontend code running on http://localhost:3000 (Vite dev server)\nfetch('/api/users') // Request goes to Vite dev server, then proxied to http://localhost:5000/users\n  .then(response => response.json())\n  .then(data => console.log('Data via Vite proxy:', data))\n  .catch(error => console.error('Error with Vite proxy:', error));\n```\n\n**7. Disabling Browser Security (Chrome, Development Only)**\n*Command Line:*\n```bash\n\"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe\" --user-data-dir=\"C:/Chrome dev session\" --disable-web-security --disable-site-isolation-trials\n```\n*Note: Adjust path to `chrome.exe` as needed for your OS. This opens a new, isolated Chrome window.*\n\n**8. Using a Public CORS Proxy (e.g., `cors-anywhere`)**\n*Client-side JavaScript:*\n```javascript\nconst targetUrl = 'https://api.example.com/data'; // The actual API you want to access\nconst proxyUrl = 'https://cors-anywhere.herokuapp.com/'; // A public CORS proxy\n\nfetch(proxyUrl + targetUrl)\n  .then(response => response.json())\n  .then(data => console.log('Data via CORS proxy:', data))\n  .catch(error => console.error('Error with CORS proxy:', error));\n```\n*Note: Public proxies are generally not recommended for production due to reliability, security, and rate limiting concerns. Consider hosting your own if this approach is necessary.*\n\n## Method Sections\n\n### Method 1: Understanding CORS and Same-Origin Policy (SOP)\n**User Personas:** Learning Explorer, Architecture Builder\n\nThe core reason for the \"No 'Access-Control-Allow-Origin' header\" error lies in the browser's implementation of the **Same-Origin Policy (SOP)**. SOP is a critical security feature that prevents a malicious website from reading sensitive data from another website.\n\n**What is the Same-Origin Policy?**\nSOP dictates that a web page can only interact with resources (like APIs) that share the same \"origin.\" An origin is defined by the combination of:\n1.  **Protocol:** (e.g., `http`, `https`)\n2.  **Host:** (e.g., `example.com`, `localhost`)\n3.  **Port:** (e.g., `80`, `443`, `3000`)\n\nIf any of these three components differ between the requesting web page and the target resource, the browser considers it a \"cross-origin\" request. By default, browsers block such requests for security reasons.\n\n**Why Postman Works Differently**\nPostman (and similar tools like Insomnia, `curl`, etc.) is not a web browser. It's an API client. It doesn't operate within the security sandbox of a browser and therefore doesn't enforce the Same-Origin Policy. When you make a request from Postman, it's a direct HTTP request from your machine to the server, without the browser's security restrictions. The server receives the request and responds, unaware that a browser would have blocked it.\n\n**Introducing CORS (Cross-Origin Resource Sharing)**\nCORS is a mechanism that allows servers to explicitly grant permission for cross-origin requests. When a browser makes a cross-origin request, it first checks if the server has sent the appropriate CORS headers in its response. If the headers indicate that the origin of the requesting page is allowed, the browser proceeds with the request. If not, it blocks the request and throws the `Access-Control-Allow-Origin` error.\n\n**Types of CORS Requests:**\n1.  **Simple Requests:** These are `GET`, `HEAD`, or `POST` requests with a `Content-Type` of `application/x-www-form-urlencoded`, `multipart/form-data`, or `text/plain`. They don't trigger a preflight request.\n2.  **Preflighted Requests:** These are requests that are \"non-simple\" (e.g., `PUT`, `DELETE`, `PATCH`, `POST` with `application/json` or custom headers). Before sending the actual request, the browser sends an `OPTIONS` request (the \"preflight\" request) to the server. The server must respond to this `OPTIONS` request with CORS headers indicating which methods, headers, and origins are allowed. If the preflight is successful, the browser then sends the actual request.\n\n**Key CORS Headers:**\n*   `Access-Control-Allow-Origin`: Specifies which origins are allowed to access the resource. Can be `*` (any origin) or a specific origin (e.g., `http://localhost:8080`).\n*   `Access-Control-Allow-Methods`: Specifies the HTTP methods allowed for cross-origin requests (e.g., `GET, POST, OPTIONS`).\n*   `Access-Control-Allow-Headers`: Specifies which HTTP headers can be used in the actual request.\n*   `Access-Control-Allow-Credentials`: Indicates whether the browser should include credentials (cookies, HTTP authentication) with the request. Must be `true` for `withCredentials` to work. If `true`, `Access-Control-Allow-Origin` cannot be `*`.\n*   `Access-Control-Max-Age`: Indicates how long the results of a preflight request can be cached.\n\n**Example of a Preflight Request (Browser perspective):**\n1.  **Browser sends `OPTIONS` request:**\n    ```\n    OPTIONS /api/data HTTP/1.1\n    Host: api.example.com\n    Origin: http://my-frontend.com\n    Access-Control-Request-Method: POST\n    Access-Control-Request-Headers: Content-Type, Authorization\n    ```\n2.  **Server responds to `OPTIONS` request:**\n    ```\n    HTTP/1.1 204 No Content\n    Access-Control-Allow-Origin: http://my-frontend.com\n    Access-Control-Allow-Methods: POST, GET, OPTIONS\n    Access-Control-Allow-Headers: Content-Type, Authorization\n    Access-Control-Max-Age: 86400\n    ```\n3.  **Browser sends actual `POST` request (if preflight successful):**\n    ```\n    POST /api/data HTTP/1.1\n    Host: api.example.com\n    Origin: http://my-frontend.com\n    Content-Type: application/json\n    Authorization: Bearer <token>\n\n    {\"key\": \"value\"}\n    ```\n\n### Method 2: Server-Side CORS Configuration\n**User Personas:** Problem Solver, Architecture Builder, Legacy Maintainer\n\nThis is the most robust and recommended solution for production environments. It involves configuring your API server to send the necessary CORS headers.\n\n#### 2.1 Node.js with Express\nThe `cors` middleware simplifies CORS configuration for Express applications.\n\n**Installation:**\n```bash\nnpm install cors\n```\n\n**Basic Usage (Allow all origins - for development/public APIs):**\n```javascript\nconst express = require('express');\nconst cors = require('cors');\nconst app = express();\nconst port = 3000;\n\napp.use(cors()); // Allows all origins, all methods, all headers by default\n\napp.get('/api/public-data', (req, res) => {\n  res.json({ message: 'Public data accessible from anywhere.' });\n});\n\napp.post('/api/submit-form', (req, res) => {\n  res.json({ status: 'Form submitted successfully!' });\n});\n\napp.listen(port, () => {\n  console.log(`Express server running on http://localhost:${port}`);\n});\n```\n\n**Allow Specific Origins (Recommended for production):**\n```javascript\nconst express = require('express');\nconst cors = require('cors');\nconst app = express();\nconst port = 3000;\n\nconst allowedOrigins = ['http://localhost:8080', 'https://my-frontend-app.com'];\nconst corsOptions = {\n  origin: function (origin, callback) {\n    // Allow requests with no origin (like mobile apps or curl requests)\n    if (!origin) return callback(null, true);\n    if (allowedOrigins.indexOf(origin) === -1) {\n      const msg = 'The CORS policy for this site does not allow access from the specified Origin.';\n      return callback(new Error(msg), false);\n    }\n    return callback(null, true);\n  },\n  methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',\n  credentials: true, // Allow cookies to be sent\n  optionsSuccessStatus: 204 // Some legacy browsers (IE11, various SmartTVs) choke on 200\n};\n\napp.use(cors(corsOptions));\n\napp.get('/api/secure-data', (req, res) => {\n  // This endpoint will only be accessible from allowedOrigins\n  res.json({ message: 'Secure data for allowed origins.' });\n});\n\napp.post('/api/auth', (req, res) => {\n  // Handle authentication, potentially setting cookies\n  res.json({ token: 'some-jwt-token' });\n});\n\napp.listen(port, () => {\n  console.log(`Express server with specific CORS running on http://localhost:${port}`);\n});\n```\n\n**Per-Route CORS:**\n```javascript\nconst express = require('express');\nconst cors = require('cors');\nconst app = express();\nconst port = 3000;\n\n// No global CORS middleware\n\napp.get('/api/open-endpoint', cors(), (req, res) => {\n  // This endpoint allows all origins\n  res.json({ message: 'This endpoint is open to all.' });\n});\n\nconst specificCorsOptions = {\n  origin: 'http://localhost:8080',\n  methods: 'POST',\n  allowedHeaders: ['Content-Type', 'Authorization'],\n};\napp.post('/api/restricted-endpoint', cors(specificCorsOptions), (req, res) => {\n  // This endpoint is restricted to http://localhost:8080 and POST method\n  res.json({ message: 'This endpoint is restricted.' });\n});\n\napp.listen(port, () => {\n  console.log(`Express server with per-route CORS running on http://localhost:${port}`);\n});\n```\n\n#### 2.2 Python with Flask\nThe `Flask-CORS` extension provides easy CORS integration for Flask.\n\n**Installation:**\n```bash\npip install Flask-CORS\n```\n\n**Basic Usage (Allow all origins):**\n```python\nfrom flask import Flask, jsonify\nfrom flask_cors import CORS\n\napp = Flask(__name__)\nCORS(app) # Enable CORS for all routes and all origins\n\n@app.route(\"/api/status\")\ndef get_status():\n    return jsonify(status=\"API is running\", version=\"1.0\")\n\n@app.route(\"/api/submit\", methods=[\"POST\"])\ndef submit_data():\n    return jsonify(message=\"Data received successfully!\")\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=5000)\n```\n\n**Allow Specific Origins and Credentials:**\n```python\nfrom flask import Flask, request, jsonify\nfrom flask_cors import CORS\n\napp = Flask(__name__)\n# Configure CORS for specific resources\nCORS(app, resources={r\"/api/*\": {\"origins\": [\"http://localhost:8080\", \"https://my-frontend-app.com\"], \"supports_credentials\": True}})\n\n@app.route(\"/api/user-profile\")\ndef get_user_profile():\n    # This endpoint requires credentials (e.g., session cookie)\n    if 'session_id' in request.cookies:\n        return jsonify(username=\"Alice\", email=\"alice@example.com\")\n    return jsonify(message=\"Unauthorized\"), 401\n\n@app.route(\"/api/update-profile\", methods=[\"PUT\"])\ndef update_user_profile():\n    if 'session_id' in request.cookies:\n        data = request.get_json()\n        return jsonify(message=\"Profile updated\", new_data=data)\n    return jsonify(message=\"Unauthorized\"), 401\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=5000)\n```\n\n**Per-Route CORS:**\n```python\nfrom flask import Flask, jsonify\nfrom flask_cors import CORS, cross_origin\n\napp = Flask(__name__)\n\n@app.route(\"/api/public-info\")\n@cross_origin() # Allow all origins for this specific route\ndef public_info():\n    return jsonify(info=\"This is public information.\")\n\n@app.route(\"/api/admin-data\")\n@cross_origin(origins=[\"http://localhost:8080\"], methods=[\"GET\", \"POST\"], headers=[\"Content-Type\", \"Authorization\"])\ndef admin_data():\n    return jsonify(data=\"Sensitive admin data.\")\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=5000)\n```\n\n#### 2.3 PHP\nCORS headers are set using the `header()` function. This must be done before any output is sent to the browser.\n\n**Basic Usage (Allow all origins):**\n```php\n<?php\n// api.php\nheader('Access-Control-Allow-Origin: *');\nheader('Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS');\nheader('Access-Control-Allow-Headers: Content-Type, Authorization, X-Requested-With');\n\n// Handle preflight OPTIONS request\nif ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {\n    http_response_code(204); // No Content\n    exit();\n}\n\n// Your API logic here\n$data = ['message' => 'Hello from PHP API!', 'timestamp' => date('Y-m-d H:i:s')];\necho json_encode($data);\n?>\n```\n\n**Allow Specific Origins and Credentials:**\n```php\n<?php\n// api-secure.php\n$allowedOrigin = 'http://localhost:8080'; // Replace with your actual frontend origin\n$requestOrigin = $_SERVER['HTTP_ORIGIN'] ?? '';\n\nif (in_array($requestOrigin, [$allowedOrigin])) {\n    header(\"Access-Control-Allow-Origin: $requestOrigin\");\n    header('Access-Control-Allow-Credentials: true'); // Required for withCredentials\n} else {\n    // Optionally, block requests from unallowed origins\n    // header('HTTP/1.1 403 Forbidden');\n    // exit('Forbidden');\n}\n\nheader('Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS');\nheader('Access-Control-Allow-Headers: Content-Type, Authorization, X-Requested-With');\nheader('Access-Control-Max-Age: 86400'); // Cache preflight for 24 hours\n\n// Handle preflight OPTIONS request\nif ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {\n    http_response_code(204);\n    exit();\n}\n\n// Your secure API logic\n$response = ['status' => 'success', 'data' => 'This is secure data.'];\necho json_encode($response);\n?>\n```\n\n#### 2.4 Java with Spring Boot\nSpring Boot provides excellent CORS support through annotations or global configuration.\n\n**Global CORS Configuration:**\n```java\n// src/main/java/com/example/demo/config/WebConfig.java\npackage com.example.demo.config;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.CorsRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n        registry.addMapping(\"/api/**\") // Apply CORS to all /api endpoints\n                .allowedOrigins(\"http://localhost:8080\", \"https://my-frontend-app.com\") // Specific origins\n                .allowedMethods(\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\")\n                .allowedHeaders(\"Content-Type\", \"Authorization\")\n                .allowCredentials(true) // Allow cookies/credentials\n                .maxAge(3600); // Cache preflight response for 1 hour\n    }\n}\n```\n\n**Controller-Level CORS:**\n```java\n// src/main/java/com/example/demo/controller/MyController.java\npackage com.example.demo.controller;\n\nimport org.springframework.web.bind.annotation.*;\n\n@RestController\n@RequestMapping(\"/api\")\n@CrossOrigin(origins = \"http://localhost:8080\", methods = {RequestMethod.GET, RequestMethod.POST}) // Controller-level CORS\npublic class MyController {\n\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return \"Hello from Spring Boot!\";\n    }\n\n    @PostMapping(\"/submit\")\n    public String submit(@RequestBody String data) {\n        return \"Received: \" + data;\n    }\n\n    @GetMapping(\"/public\")\n    @CrossOrigin(origins = \"*\") // Override for this specific method to allow all origins\n    public String publicEndpoint() {\n        return \"This endpoint is public.\";\n    }\n}\n```\n\n#### 2.5 .NET Web API\n.NET Core and .NET 5+ provide robust CORS configuration.\n\n**Installation:**\nEnsure `Microsoft.AspNetCore.Cors` is referenced in your project.\n\n**Startup.cs (Program.cs in .NET 6+):**\n```csharp\n// For .NET 5 and earlier (Startup.cs)\npublic class Startup\n{\n    public void ConfigureServices(IServiceCollection services)\n    {\n        services.AddCors(options =>\n        {\n            options.AddPolicy(name: \"AllowSpecificOrigin\",\n                              builder =>\n                              {\n                                  builder.WithOrigins(\"http://localhost:8080\", \"https://my-frontend-app.com\")\n                                         .AllowAnyHeader()\n                                         .AllowAnyMethod()\n                                         .AllowCredentials(); // Required for withCredentials\n                              });\n\n            options.AddPolicy(name: \"AllowAllOrigins\",\n                              builder =>\n                              {\n                                  builder.AllowAnyOrigin() // Not recommended for production with credentials\n                                         .AllowAnyHeader()\n                                         .AllowAnyMethod();\n                              });\n        });\n        services.AddControllers();\n    }\n\n    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n    {\n        if (env.IsDevelopment())\n        {\n            app.UseDeveloperExceptionPage();\n        }\n\n        app.UseRouting();\n\n        // Apply CORS policy globally or before specific endpoints\n        app.UseCors(\"AllowSpecificOrigin\"); // Use the named policy\n\n        app.UseAuthorization();\n\n        app.UseEndpoints(endpoints =>\n        {\n            endpoints.MapControllers",
  "source_file": "/Users/thaddeus/Documents/on-going projects/deepv-stackoverflow-workflow-complete/data/workflow_queue/processed_question_20035101_why-does-my-javascript-code-receive-a-no-access-control-allow-origin-header-i.json",
  "generation_stats": {
    "timestamp": 1758108141.9615932,
    "model": "google/gemini-2.5-flash",
    "tokens_used": 11806,
    "generation_time": 30.370809078216553
  },
  "workflow_version": "deepv_stackoverflow_v1.0"
}