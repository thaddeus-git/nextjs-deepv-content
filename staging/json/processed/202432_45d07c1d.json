{
  "metadata": {
    "title": "Capture and Log SCP Output Including Progress Bar",
    "slug": "capture-log-scp-output-progress-bar",
    "uniqueId": "45d07c1d",
    "category": "system-devops",
    "subcategory": "shell",
    "description": "Learn how to capture the full output of an SCP command, including the progress bar, for logging and monitoring purposes.",
    "tags": [
      "scp",
      "logging",
      "shell",
      "bash",
      "linux",
      "scripting"
    ],
    "difficulty": "intermediate",
    "readTime": 7,
    "lastUpdated": "2024-09-21T12:30:00.000Z",
    "sourceStackOverflowId": "202432",
    "votes": 26
  },
  "content": "# Capture and Log SCP Output Including Progress Bar\n\nWhen running `scp` commands within scripts, capturing its full output, especially the dynamic progress bar, can be challenging. Standard redirection methods often cause `scp` to suppress the progress bar because it detects that its output is not going to an interactive terminal. This guide explores various methods to effectively capture and log `scp` output, including the progress bar, and how to check for command success.\n\n## Quick Answer\n\nTo capture the `scp` progress bar and full output to a log file, use the `script` command to simulate a terminal environment.\n\n```bash\nscript -q -c \"scp server:/path/to/file /tmp/\" > scp_log.txt\n```\n\nThis command tricks `scp` into believing it's running in an interactive terminal, allowing it to print the progress bar, which is then captured by `script` and redirected to `scp_log.txt`.\n\n## Choose Your Method\n\nThe best method for capturing `scp` output depends on whether you need the progress bar, just the success/failure status, or verbose logging for debugging.\n\n```mermaid\ngraph TD\n    A[Start] --> B{Need SCP Progress Bar in Log?};\n    B -- Yes --> C[Use `script` command];\n    C --> D[Example: `script -q -c \"scp source dest\" > log.txt`];\n    B -- No --> E{Need only Success/Failure Status?};\n    E -- Yes --> F[Check `scp` exit code];\n    F --> G[Example: `scp source dest && echo \"Success\"`];\n    E -- No --> H{Need Verbose Output for Debugging?};\n    H -- Yes --> I[Use `scp -v` and redirect stderr];\n    I --> J[Example: `scp -v source dest 2> log.txt`];\n    D --> K[End];\n    G --> K;\n    J --> K;\n```\n\n## Table of Contents\n1. Quick Answer\n2. Choose Your Method\n3. Capturing Progress Bar with `script`\n4. Checking SCP Success with Exit Codes\n5. Verbose Logging for Debugging\n6. Combining `script` with `tee` for Real-time Output and Logging\n7. Common Problems and Solutions\n8. Summary\n\n## Capturing Progress Bar with `script`\n\nThe `scp` command, like many interactive tools, behaves differently when its output is redirected. It often suppresses dynamic elements like progress bars when it detects that it's not writing to a TTY (Teletypewriter) or terminal. The `script` command can simulate a terminal environment, allowing `scp` to output its progress bar, which `script` then captures.\n\n### How it Works\n\nThe `script` command records everything printed to the terminal, including control codes, into a file. By running `scp` within `script`, you effectively \"trick\" `scp` into displaying its progress bar, and `script` captures this output.\n\n```bash\nscript -q -c \"scp server:/file /tmp/\" > /tmp/test.txt\n```\n\n- `-q`: (quiet mode) Suppresses the \"Script started/ended\" messages.\n- `-c \"command\"`: Executes the specified command within the `script` session.\n\n**Example Output in `/tmp/test.txt`:**\n\n```output\nfile    0%    0     0.0KB/s   --:-- ETA\nfile   18%   11MB  11.2MB/s   00:04 ETA\nfile   36%   22MB  11.2MB/s   00:03 ETA\nfile   54%   34MB  11.2MB/s   00:02 ETA\nfile   73%   45MB  11.2MB/s   00:01 ETA\nfile   91%   56MB  11.2MB/s   00:00 ETA\nfile  100%   61MB  10.2MB/s   00:06\n```\n\nThis method is ideal when you need a complete record of the `scp` operation, including the visual progress, for auditing or detailed logging.\n\n## Checking SCP Success with Exit Codes\n\nIf you don't need the detailed progress bar and are primarily interested in whether the `scp` operation succeeded or failed, checking its exit code is the most robust and straightforward method.\n\n### How it Works\n\nStandard Unix/Linux commands, including `scp`, return an exit code upon completion:\n- `0`: Indicates success.\n- `>0`: Indicates an error occurred.\n\nYou can use shell constructs like `&&` (logical AND) and `||` (logical OR) to execute commands conditionally based on the `scp` command's success.\n\n```bash\nscp myfile user@host.com:. && echo \"SCP successful!\" >> scp_status.log || echo \"SCP failed!\" >> scp_status.log\n```\n\n- `scp myfile user@host.com:.`: Executes the `scp` command.\n- `&& echo \"SCP successful!\" >> scp_status.log`: If `scp` succeeds (exit code 0), this command is executed, logging a success message.\n- `|| echo \"SCP failed!\" >> scp_status.log`: If `scp` fails (exit code >0), this command is executed, logging a failure message.\n\n**Example:**\n\n```bash\n# Successful transfer\nscp local_file.txt user@remote_host:/tmp/ && echo \"local_file.txt copied successfully!\" >> transfer.log\n\n# Failed transfer (e.g., wrong path, permissions)\nscp non_existent_file.txt user@remote_host:/tmp/ && echo \"non_existent_file.txt copied successfully!\" >> transfer.log || echo \"Failed to copy non_existent_file.txt\" >> transfer.log\n```\n\n**`transfer.log` after both commands:**\n\n```output\nlocal_file.txt copied successfully!\nFailed to copy non_existent_file.txt\n```\n\nThis approach is lightweight and perfect for automated scripts where you just need to know the outcome of the transfer.\n\n## Verbose Logging for Debugging\n\nFor troubleshooting or when you need more detailed information about the `scp` process than just the progress bar or success status, the verbose option (`-v`) is invaluable.\n\n### How it Works\n\nThe `-v` flag tells `scp` to print debugging messages about its progress, including connection details, authentication attempts, and file transfer specifics. This output is typically sent to `stderr` (standard error).\n\nTo capture this verbose output, you need to redirect `stderr` to a file.\n\n```bash\nscp -v -rC root@host:/path/to/directory . 2> copy.log\n```\n\n- `-v`: Enables verbose mode.\n- `-r`: Recursively copies directories.\n- `-C`: Enables compression.\n- `2> copy.log`: Redirects `stderr` (file descriptor 2) to `copy.log`.\n\n**Example `copy.log` content (abbreviated):**\n\n```output\nExecuting: program /usr/bin/ssh -v -x -oFallBackToRsh=no -oProtocol=2 -oBatchMode=yes -l root host -p 22 scp -v -r -d -t /path/to/directory\ndebug1: Reading configuration data /etc/ssh/ssh_config\ndebug1: Connecting to host [IP_ADDRESS] port 22.\ndebug1: Connection established.\ndebug1: identity file /root/.ssh/id_rsa type 1\ndebug1: Authenticating to host [IP_ADDRESS]:22 as 'root'\ndebug1: SSH2_MSG_SERVICE_REQUEST sent\ndebug1: SSH2_MSG_SERVICE_ACCEPT received\ndebug1: SSH2_MSG_KEXINIT sent\ndebug1: SSH2_MSG_KEXINIT received\n...\ndebug1: Sending command: scp -v -r -d -t /path/to/directory\ndebug1: client_loop: send disconnect\ndebug1: channel 0: free: client-session, nchannels 1\ndebug1: fd 0 clearing close-on-exec\ndebug1: fd 1 clearing close-on-exec\ndebug1: fd 2 clearing close-on-exec\ndebug1: Transferred: stdin 0, stdout 0, stderr 256 bytes in 0.0 seconds\ndebug1: Exit status 0\n```\n\nYou can then parse this log file for specific information, such as the number of files copied:\n\n```bash\ngrep \"file\" copy.log | wc -l\n```\n\nThis method is particularly useful for diagnosing connection issues, authentication problems, or unexpected transfer behaviors.\n\n## Combining `script` with `tee` for Real-time Output and Logging\n\nSometimes you need both: the `scp` progress bar displayed on the terminal *and* captured in a log file. The `tee` command allows you to achieve this by splitting the output stream.\n\n### How it Works\n\n`tee` reads standard input and writes it to both standard output (which goes to your terminal) and one or more files. By piping the output of `script` to `tee`, you can view the progress in real-time while simultaneously logging it.\n\n```bash\nscript -q -c \"scp server:/file /tmp/\" | tee scp.log\n```\n\n- `script -q -c \"scp server:/file /tmp/\"`: Executes `scp` in a simulated terminal and captures its output.\n- `| tee scp.log`: Pipes the captured output to `tee`, which then prints it to the console and saves it to `scp.log`.\n\n**Example:**\n\nWhen you run the command, you will see the progress bar updating in your terminal:\n\n```console\nfile    0%    0     0.0KB/s   --:-- ETA\nfile   18%   11MB  11.2MB/s   00:04 ETA\n...\nfile  100%   61MB  10.2MB/s   00:06\n```\n\nAnd `scp.log` will contain the same output:\n\n```output\nfile    0%    0     0.0KB/s   --:-- ETA\nfile   18%   11MB  11.2MB/s   00:04 ETA\n...\nfile  100%   61MB  10.2MB/s   00:06\n```\n\nThis method provides the best of both worlds for interactive monitoring and persistent logging.\n\n## Common Problems and Solutions\n\n### Problem 1: `script` command not found or `-c` option missing.\nSome older or minimal systems might not have `script` installed by default, or its version might not support the `-c` option.\n\n**Solution:**\n- **Install `util-linux`:** On most Linux distributions, `script` is part of the `util-linux` package.\n  ```bash\n  # Debian/Ubuntu\n  sudo apt-get install util-linux\n  # CentOS/RHEL\n  sudo yum install util-linux\n  ```\n- **Alternative for older `script`:** If `-c` is not supported, you can run `script` interactively and then execute `scp`. This is less suitable for automation.\n  ```bash\n  script -q my_session.log\n  scp server:/file /tmp/\n  exit\n  ```\n\n### Problem 2: `script` command output includes control characters.\nThe output from `script` might contain ANSI escape codes or other control characters that make the log file difficult to read, especially if you're viewing it with a basic text editor.\n\n**Solution:**\n- **Filter control characters:** Use `sed` or `col` to remove these characters if they are problematic for your log parsing.\n  ```bash\n  script -q -c \"scp server:/file /tmp/\" | sed 's/\\x1b\\[[0-9;]*[a-zA-Z]//g' > scp_clean_log.txt\n  # Or using col -b (backspace processing)\n  script -q -c \"scp server:/file /tmp/\" | col -b > scp_clean_log.txt\n  ```\n  Note: `sed` command removes most common ANSI escape codes. `col -b` is good for removing backspace characters often used in progress bars.\n\n### Problem 3: `scp` command hangs or requires password interactively.\nIf `scp` requires a password and you're running it in a script, it will hang waiting for input.\n\n**Solution:**\n- **Use SSH keys:** Configure passwordless SSH authentication using SSH keys. This is the most secure and recommended approach for automation.\n- **`sshpass` (use with caution):** For non-interactive password entry, `sshpass` can be used, but it's generally discouraged due to security risks.\n  ```bash\n  sshpass -p 'your_password' scp myfile user@host.com:.\n  ```\n  **Warning:** Storing passwords in scripts is a security risk. Prefer SSH keys.\n\n### Problem 4: `script` command creates a subshell, affecting script flow.\nAs noted in some answers, `script -c \"command\"` runs the command in a subshell. If your script relies on variables or environment changes from `command` to persist, this won't happen. Also, the parent script might not wait for the subshell to fully complete before moving on, especially if backgrounding.\n\n**Solution:**\n- **Ensure sequential execution:** If `script` is used, ensure the parent script explicitly waits for it. The `script -c \"command\"` form generally waits, but if you're doing complex backgrounding, be careful.\n- **Handle exit codes:** Always check the exit code of the `script` command itself, not just the `scp` command inside it, if you need to ensure the entire operation completed successfully.\n  ```bash\n  script -q -c \"scp server:/file /tmp/\" > scp_log.txt\n  if [ $? -eq 0 ]; then\n      echo \"SCP and logging successful.\"\n  else\n      echo \"SCP or logging failed.\"\n  fi\n  ```\n\n## Summary\n\nCapturing `scp` output, especially the dynamic progress bar, requires understanding how `scp` interacts with its terminal environment.\n\n-   **For capturing the progress bar in a log file:** Use the `script` command (`script -q -c \"scp source dest\" > log.txt`). This simulates a terminal, allowing `scp` to print its progress, which is then captured.\n-   **For checking success/failure:** Rely on `scp`'s exit code (`scp source dest && echo \"Success\"`). This is the most robust method for automation.\n-   **For verbose debugging:** Use the `-v` flag and redirect `stderr` (`scp -v source dest 2> debug.log`).\n-   **For real-time display and logging:** Combine `script` with `tee` (`script -q -c \"scp source dest\" | tee log.txt`).\n\nBy choosing the appropriate method, you can effectively monitor and log your `scp` operations to meet your specific scripting and auditing needs.\n\n---\n\n## Image Generation Prompts\n\n**PLACEHOLDER-1:** A clean, modern diagram illustrating the flow of `scp` output when redirected versus when run within `script`. Show `scp` command, then two paths: one with `>` redirection (showing progress bar suppressed), and one with `script -c \"scp...\" >` (showing progress bar captured). Use simple icons for terminal, log file, and `scp` process.\n\n**PLACEHHER-2:** A simple diagram showing the `scp` command returning an exit code. Illustrate `scp` box, then an arrow pointing to a small box labeled \"Exit Code (0 for success, >0 for error)\", followed by conditional paths for \"Success\" and \"Failure\" leading to different actions (e.g., \"Log Success\" or \"Log Failure\").\n\n**PLACEHOLDER-3:** A visual representation of the `tee` command. Show a single input stream (e.g., from `script -c \"scp...\"`) splitting into two output streams: one going to a \"Terminal Display\" icon and the other going to a \"Log File\" icon. Use arrows to clearly indicate data flow.",
  "originalFormat": {
    "image_prompts": {
      "prompts": {
        "PLACEHOLDER-1": "A clean, modern diagram illustrating the flow of `scp` output when redirected versus when run within `script`. Show `scp` command, then two paths: one with `>` redirection (showing progress bar suppressed), and one with `script -c \"scp...\" >` (showing progress bar captured). Use simple icons for terminal, log file, and `scp` process.\n\n**PLACEHHER-2:** A simple diagram showing the `scp` command returning an exit code. Illustrate `scp` box, then an arrow pointing to a small box labeled \"Exit Code (0 for success, >0 for error)\", followed by conditional paths for \"Success\" and \"Failure\" leading to different actions (e.g., \"Log Success\" or \"Log Failure\").",
        "PLACEHOLDER-3": "A visual representation of the `tee` command. Show a single input stream (e.g., from `script -c \"scp...\"`) splitting into two output streams: one going to a \"Terminal Display\" icon and the other going to a \"Log File\" icon. Use arrows to clearly indicate data flow."
      },
      "titles": {},
      "count": 2,
      "placeholder_list": []
    },
    "generated_images": [
      {
        "placeholder": "PLACEHOLDER-1",
        "filename": "45d07c1d-1.png",
        "title": "Image 1",
        "path": "staging/images/45d07c1d-1.png"
      },
      {
        "placeholder": "PLACEHOLDER-3",
        "filename": "45d07c1d-3.png",
        "title": "Image 3",
        "path": "staging/images/45d07c1d-3.png"
      }
    ],
    "source_file": "/Users/thaddeus/Documents/on-going projects/deepv-stackoverflow-workflow-complete/data/crawled_data/202432.json",
    "workflow_version": "deepv_stackoverflow_v2.0_schema_compliant",
    "generated_at": "2025-09-22T22:53:58.743887",
    "word_count": 1957,
    "code_blocks": 36
  }
}