{
  "metadata": {
    "title": "Hierarchical Faceting in Elasticsearch with Nested Aggregations",
    "slug": "hierarchical-faceting-elasticsearch-nested-aggregations",
    "uniqueId": "00ec434a",
    "category": "programming-languages",
    "subcategory": "python",
    "description": "Learn how to implement hierarchical faceting in Elasticsearch using nested aggregations for accurate multi-level category counts.",
    "tags": [
      "elasticsearch",
      "faceting",
      "aggregations",
      "nested-objects",
      "search"
    ],
    "difficulty": "intermediate",
    "readTime": 8,
    "lastUpdated": "2024-09-21T12:30:00.000Z",
    "sourceStackOverflowId": "20618183",
    "votes": 8
  },
  "content": "# Hierarchical Faceting in Elasticsearch with Nested Aggregations\n\nWhen working with Elasticsearch, implementing hierarchical faceting for multi-level categories (like `category > subcategory`) can be tricky. A simple aggregation on flat fields often leads to incorrect counts due to how Elasticsearch indexes arrays of objects. This guide explains how to correctly achieve hierarchical faceting using Elasticsearch's `nested` data type and nested aggregations.\n\n## Quick Answer\n\nTo implement accurate hierarchical faceting in Elasticsearch, define your multi-level category fields as a `nested` data type in your mapping. Then, use a `nested` aggregation followed by `terms` aggregations for each level of your hierarchy.\n\n```json\nPUT /my_index\n{\n  \"mappings\": {\n    \"properties\": {\n      \"categories\": {\n        \"type\": \"nested\",\n        \"properties\": {\n          \"cat_1\": { \"type\": \"keyword\" },\n          \"cat_2\": { \"type\": \"keyword\" }\n        }\n      }\n    }\n  }\n}\n\nGET /my_index/_search?size=0\n{\n  \"aggs\": {\n    \"nested_categories\": {\n      \"nested\": {\n        \"path\": \"categories\"\n      },\n      \"aggs\": {\n        \"main_category_terms\": {\n          \"terms\": {\n            \"field\": \"categories.cat_1\"\n          },\n          \"aggs\": {\n            \"sub_category_terms\": {\n              \"terms\": {\n                \"field\": \"categories.cat_2\"\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n## Concept Explanation\n\nElasticsearch handles arrays of objects in a specific way. When you have an array of objects like `[{\"cat_1\": \"1\", \"cat_2\": \"1.1\"}, {\"cat_1\": \"2\", \"cat_2\": \"2.2\"}]`, Elasticsearch by default \"flattens\" these objects into a single document. This means that `cat_1` values (`1`, `2`) and `cat_2` values (`1.1`, `2.2`) are indexed as if they belong to the same \"parent\" document, losing their original object relationship.\n\nWhen you perform a simple `terms` aggregation on `categories.cat_1` and then a sub-aggregation on `categories.cat_2`, Elasticsearch will incorrectly associate all `cat_2` values with all `cat_1` values within the same document. This leads to inflated and inaccurate counts for subcategories.\n\nThe `nested` data type solves this by indexing each object in an array as a separate, hidden document. This preserves the relationship between the fields within each object. When you then use a `nested` aggregation, Elasticsearch performs the sub-aggregations within the context of these individual nested documents, ensuring accurate hierarchical counts.\n\n![Nested Object Indexing](/images/00ec434a-1.webp)\n\n## Working Code Examples\n\nLet's walk through the process with a practical example.\n\n### 1. Initial Setup (Incorrect Aggregation)\n\nFirst, let's demonstrate the problem with a standard mapping and aggregation.\n\n```json\nDELETE /test_category\n```\n\n```json\nPUT /test_category\n```\n\n```json\nPOST /test_category/test/1\n{\n  \"categories\": [\n    {\n      \"cat_1\": \"Electronics\",\n      \"cat_2\": \"Smartphones\"\n    },\n    {\n      \"cat_1\": \"Books\",\n      \"cat_2\": \"Fiction\"\n    }\n  ]\n}\n```\n\n```json\nPOST /test_category/test/2\n{\n  \"categories\": [\n    {\n      \"cat_1\": \"Electronics\",\n      \"cat_2\": \"Laptops\"\n    },\n    {\n      \"cat_1\": \"Books\",\n      \"cat_2\": \"Non-Fiction\"\n    }\n  ]\n}\n```\n\nNow, let's try a simple two-level aggregation:\n\n```json\nGET /test_category/test/_search?size=0\n{\n  \"aggs\": {\n    \"main_category\": {\n      \"terms\": {\n        \"field\": \"categories.cat_1.keyword\"\n      },\n      \"aggs\": {\n        \"sub_category\": {\n          \"terms\": {\n            \"field\": \"categories.cat_2.keyword\"\n          }\n        }\n      }\n    }\n  }\n}\n```\n\nThe `keyword` type is used here for exact matching of category names.\n\n**Incorrect Response:**\n\n```json\n{\n  \"took\": ...,\n  \"timed_out\": false,\n  \"_shards\": ...,\n  \"hits\": {\n    \"total\": { \"value\": 2, \"relation\": \"eq\" },\n    \"max_score\": null,\n    \"hits\": []\n  },\n  \"aggregations\": {\n    \"main_category\": {\n      \"doc_count_error_upper_bound\": 0,\n      \"sum_other_doc_count\": 0,\n      \"buckets\": [\n        {\n          \"key\": \"Books\",\n          \"doc_count\": 2,\n          \"sub_category\": {\n            \"doc_count_error_upper_bound\": 0,\n            \"sum_other_doc_count\": 0,\n            \"buckets\": [\n              { \"key\": \"Fiction\", \"doc_count\": 1 },\n              { \"key\": \"Non-Fiction\", \"doc_count\": 1 },\n              { \"key\": \"Laptops\", \"doc_count\": 1 },  <== WRONG\n              { \"key\": \"Smartphones\", \"doc_count\": 1 } <== WRONG\n            ]\n          }\n        },\n        {\n          \"key\": \"Electronics\",\n          \"doc_count\": 2,\n          \"sub_category\": {\n            \"doc_count_error_upper_bound\": 0,\n            \"sum_other_doc_count\": 0,\n            \"buckets\": [\n              { \"key\": \"Laptops\", \"doc_count\": 1 },\n              { \"key\": \"Smartphones\", \"doc_count\": 1 },\n              { \"key\": \"Fiction\", \"doc_count\": 1 }, <== WRONG\n              { \"key\": \"Non-Fiction\", \"doc_count\": 1 } <== WRONG\n            ]\n          }\n        }\n      ]\n    }\n  }\n}\n```\nAs you can see, `Books` incorrectly shows `Laptops` and `Smartphones` as subcategories, and `Electronics` incorrectly shows `Fiction` and `Non-Fiction`. This is because the fields are flattened, and all `cat_2` values from a document are associated with all `cat_1` values from that same document.\n\n### 2. Solution with Nested Objects and Aggregations\n\nTo fix this, we need to define the `categories` field as `nested`.\n\n#### Step 1: Define Nested Mapping\n\n```json\nDELETE /test_category_nested\n```\n\n```json\nPUT /test_category_nested\n{\n  \"mappings\": {\n    \"properties\": {\n      \"categories\": {\n        \"type\": \"nested\",\n        \"properties\": {\n          \"cat_1\": { \"type\": \"keyword\" },\n          \"cat_2\": { \"type\": \"keyword\" }\n        }\n      }\n    }\n  }\n}\n```\n\n#### Step 2: Index Documents\n\nIndex the same documents into the new index with the `nested` mapping.\n\n```json\nPOST /test_category_nested/_doc/1\n{\n  \"categories\": [\n    {\n      \"cat_1\": \"Electronics\",\n      \"cat_2\": \"Smartphones\"\n    },\n    {\n      \"cat_1\": \"Books\",\n      \"cat_2\": \"Fiction\"\n    }\n  ]\n}\n```\n\n```json\nPOST /test_category_nested/_doc/2\n{\n  \"categories\": [\n    {\n      \"cat_1\": \"Electronics\",\n      \"cat_2\": \"Laptops\"\n    },\n    {\n      \"cat_1\": \"Books\",\n      \"cat_2\": \"Non-Fiction\"\n    }\n  ]\n}\n```\n\n#### Step 3: Run Nested Aggregation Query\n\nNow, use a `nested` aggregation to correctly group the hierarchical data.\n\n```json\nGET /test_category_nested/_search?size=0\n{\n  \"aggs\": {\n    \"nested_categories\": {\n      \"nested\": {\n        \"path\": \"categories\"\n      },\n      \"aggs\": {\n        \"main_category_terms\": {\n          \"terms\": {\n            \"field\": \"categories.cat_1\"\n          },\n          \"aggs\": {\n            \"sub_category_terms\": {\n              \"terms\": {\n                \"field\": \"categories.cat_2\"\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n**Correct Response:**\n\n```json\n{\n  \"took\": ...,\n  \"timed_out\": false,\n  \"_shards\": ...,\n  \"hits\": {\n    \"total\": { \"value\": 2, \"relation\": \"eq\" },\n    \"max_score\": null,\n    \"hits\": []\n  },\n  \"aggregations\": {\n    \"nested_categories\": {\n      \"doc_count\": 4,\n      \"main_category_terms\": {\n        \"doc_count_error_upper_bound\": 0,\n        \"sum_other_doc_count\": 0,\n        \"buckets\": [\n          {\n            \"key\": \"Books\",\n            \"doc_count\": 2,\n            \"sub_category_terms\": {\n              \"doc_count_error_upper_bound\": 0,\n              \"sum_other_doc_count\": 0,\n              \"buckets\": [\n                { \"key\": \"Fiction\", \"doc_count\": 1 },\n                { \"key\": \"Non-Fiction\", \"doc_count\": 1 }\n              ]\n            }\n          },\n          {\n            \"key\": \"Electronics\",\n            \"doc_count\": 2,\n            \"sub_category_terms\": {\n              \"doc_count_error_upper_bound\": 0,\n              \"sum_other_doc_count\": 0,\n              \"buckets\": [\n                { \"key\": \"Laptops\", \"doc_count\": 1 },\n                { \"key\": \"Smartphones\", \"doc_count\": 1 }\n              ]\n            }\n          }\n        ]\n      }\n    }\n  }\n}\n```\nThis output correctly associates `Fiction` and `Non-Fiction` with `Books`, and `Laptops` and `Smartphones` with `Electronics`, providing accurate hierarchical faceting.\n\n### Extending to More Levels\n\nThe same solution can be extended to more than two levels of hierarchy by simply adding more `terms` sub-aggregations within the `nested` aggregation.\n\n```json\nPUT /products\n{\n  \"mappings\": {\n    \"properties\": {\n      \"category_path\": {\n        \"type\": \"nested\",\n        \"properties\": {\n          \"level1\": { \"type\": \"keyword\" },\n          \"level2\": { \"type\": \"keyword\" },\n          \"level3\": { \"type\": \"keyword\" }\n        }\n      }\n    }\n  }\n}\n```\n\n```json\nPOST /products/_doc/1\n{\n  \"name\": \"Smartphone X\",\n  \"category_path\": [\n    { \"level1\": \"Electronics\", \"level2\": \"Mobile Devices\", \"level3\": \"Smartphones\" }\n  ]\n}\n```\n\n```json\nPOST /products/_doc/2\n{\n  \"name\": \"Laptop Pro\",\n  \"category_path\": [\n    { \"level1\": \"Electronics\", \"level2\": \"Computers\", \"level3\": \"Laptops\" }\n  ]\n}\n```\n\n```json\nGET /products/_search?size=0\n{\n  \"aggs\": {\n    \"nested_category_path\": {\n      \"nested\": {\n        \"path\": \"category_path\"\n      },\n      \"aggs\": {\n        \"level1_terms\": {\n          \"terms\": {\n            \"field\": \"category_path.level1\"\n          },\n          \"aggs\": {\n            \"level2_terms\": {\n              \"terms\": {\n                \"field\": \"category_path.level2\"\n              },\n              \"aggs\": {\n                \"level3_terms\": {\n                  \"terms\": {\n                    \"field\": \"category_path.level3\"\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n## Common Problems & Solutions\n\n### Problem: Incorrect Counts with Simple Aggregations\n**Symptom:** Subcategory counts are inflated or show unrelated categories.\n**Cause:** Using standard object arrays for hierarchical data without `nested` mapping. Elasticsearch flattens the array, losing the object context.\n**Solution:** Always define multi-level category fields as `type: \"nested\"` in your index mapping and use a `nested` aggregation as the parent for your `terms` aggregations.\n\n### Problem: Performance Overhead with Nested Objects\n**Symptom:** Queries involving nested aggregations are slower than expected.\n**Cause:** Nested objects are indexed as separate, hidden documents, which adds overhead during indexing and querying.\n**Solution:**\n*   **Only use `nested` when necessary:** If your hierarchy can be represented by a single string (e.g., \"Electronics > Mobile Devices > Smartphones\") and you only need to facet on the full path or specific parts of it (using path-based aggregations or `path_hierarchy` tokenizer), you might not need `nested` objects.\n*   **Limit nesting depth:** Deeply nested structures can significantly impact performance.\n*   **Optimize field types:** Use `keyword` for exact string matching in categories to avoid analysis overhead.\n\n### Problem: Aggregating on Non-Nested Fields within a Nested Context\n**Symptom:** Trying to aggregate on a field that is *not* part of the `nested` path within a `nested` aggregation.\n**Cause:** The `nested` aggregation creates a scope for its child aggregations. These children can only operate on fields within the `nested` path.\n**Solution:** Ensure that all fields you are aggregating on within a `nested` aggregation are defined as part of the `nested` object's properties. If you need to aggregate on a top-level field, you'll need a separate top-level aggregation.\n\n## Real-World Use Cases\n\n*   **E-commerce Product Catalogs:** Displaying categories and subcategories (e.g., \"Electronics > Laptops > Gaming Laptops\") with accurate product counts for each level.\n*   **Document Management Systems:** Faceting documents by department, project, and sub-project.\n*   **Content Management Systems:** Organizing articles by topic, sub-topic, and specific tags.\n*   **Data Analytics Dashboards:** Allowing users to drill down into data based on hierarchical dimensions.\n\n## Summary\n\nImplementing hierarchical faceting in Elasticsearch requires careful consideration of how data is indexed. By leveraging the `nested` data type and `nested` aggregations, you can accurately represent and aggregate multi-level categorical data, avoiding the pitfalls of Elasticsearch's default array handling. This approach ensures that your facet counts correctly reflect the relationships within your hierarchical structures, providing a robust and intuitive search experience.\n\n---\n\n## Image Generation Prompts\n\n**PLACEHOLDER-1:** A diagram illustrating the difference between how Elasticsearch indexes a standard array of objects versus a `nested` array of objects.\n**Left Side (Standard Array):**\n- Title: \"Standard Object Array Indexing (Flattened)\"\n- Input: A JSON object with a field `categories: [{\"cat_1\": \"A\", \"cat_2\": \"A1\"}, {\"cat_1\": \"B\", \"cat_2\": \"B1\"}]`\n- Process: An arrow pointing to a simplified representation of Elasticsearch's inverted index.\n- Output: \"Indexed Document\" showing `cat_1: [A, B]`, `cat_2: [A1, B1]`.\n- Highlight: A red \"X\" or \"Incorrect\" next to the output, with a note \"Relationships lost\".\n**Right Side (Nested Array):**\n- Title: \"Nested Object Array Indexing (Preserved)\"\n- Input: A JSON object with a field `categories: [{\"cat_1\": \"A\", \"cat_2\": \"A1\"}, {\"cat_1\": \"B\", \"cat_2\": \"B1\"}]` and a note \"Mapping: type: nested\"\n- Process: An arrow pointing to a simplified representation of Elasticsearch's inverted index.\n- Output: \"Indexed Document\" showing:\n  - \"Nested Doc 1\": `cat_1: A`, `cat_2: A1`\n  - \"Nested Doc 2\": `cat_1: B`, `cat_2: B1`\n- Highlight: A green checkmark or \"Correct\" next to the output, with a note \"Relationships preserved\".\n**Overall Style:** Clean, technical diagram with clear labels, distinct sections for comparison, and simple icons for correctness/incorrectness. Use a light background.",
  "originalFormat": {
    "image_prompts": {
      "prompts": {
        "PLACEHOLDER-1": "A diagram illustrating the difference between how Elasticsearch indexes a standard array of objects versus a `nested` array of objects.\n**Left Side (Standard Array):**\n- Title: \"Standard Object Array Indexing (Flattened)\"\n- Input: A JSON object with a field `categories: [{\"cat_1\": \"A\", \"cat_2\": \"A1\"}, {\"cat_1\": \"B\", \"cat_2\": \"B1\"}]`\n- Process: An arrow pointing to a simplified representation of Elasticsearch's inverted index.\n- Output: \"Indexed Document\" showing `cat_1: [A, B]`, `cat_2: [A1, B1]`.\n- Highlight: A red \"X\" or \"Incorrect\" next to the output, with a note \"Relationships lost\".\n**Right Side (Nested Array):**\n- Title: \"Nested Object Array Indexing (Preserved)\"\n- Input: A JSON object with a field `categories: [{\"cat_1\": \"A\", \"cat_2\": \"A1\"}, {\"cat_1\": \"B\", \"cat_2\": \"B1\"}]` and a note \"Mapping: type: nested\"\n- Process: An arrow pointing to a simplified representation of Elasticsearch's inverted index.\n- Output: \"Indexed Document\" showing:\n  - \"Nested Doc 1\": `cat_1: A`, `cat_2: A1`\n  - \"Nested Doc 2\": `cat_1: B`, `cat_2: B1`\n- Highlight: A green checkmark or \"Correct\" next to the output, with a note \"Relationships preserved\".\n**Overall Style:** Clean, technical diagram with clear labels, distinct sections for comparison, and simple icons for correctness/incorrectness. Use a light background."
      },
      "titles": {
        "PLACEHOLDER-1": "Nested Object Indexing"
      },
      "count": 1,
      "placeholder_list": [
        [
          "Nested Object Indexing",
          "1"
        ]
      ]
    },
    "generated_images": [
      {
        "placeholder": "PLACEHOLDER-1",
        "filename": "00ec434a-1.webp",
        "title": "Nested Object Indexing",
        "path": "staging/images/00ec434a-1.png"
      }
    ],
    "source_file": "/Users/thaddeus/Documents/on-going projects/deepv-stackoverflow-workflow-complete/data/crawled_data/20618183.json",
    "workflow_version": "deepv_stackoverflow_v2.0_schema_compliant",
    "generated_at": "2025-09-22T23:13:45.947526",
    "word_count": 1660,
    "code_blocks": 34
  }
}