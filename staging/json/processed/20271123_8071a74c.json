{
  "metadata": {
    "title": "Executing SQL IN Lookups in Go with Dynamic Parameters",
    "slug": "golang-sql-in-lookup",
    "uniqueId": "8071a74c",
    "category": "programming-languages",
    "subcategory": "go",
    "description": "Learn how to correctly execute SQL IN clause queries in Go, handling dynamic lists of parameters safely and efficiently.",
    "tags": [
      "go",
      "sql",
      "database",
      "postgres",
      "in-clause",
      "dynamic-query"
    ],
    "difficulty": "intermediate",
    "readTime": 8,
    "lastUpdated": "2024-09-21T12:30:00.000Z",
    "sourceStackOverflowId": "20271123",
    "votes": 63
  },
  "content": "# Executing SQL IN Lookups in Go with Dynamic Parameters\n\nWhen working with SQL databases in Go, a common requirement is to query for records where a column's value is present in a list of items, often referred to as an `IN` clause lookup. Directly passing a slice or array to a prepared statement's placeholder for an `IN` clause doesn't work as intuitively as one might expect with standard Go `database/sql` package. This guide explores various robust and safe methods to achieve this, focusing on solutions that prevent SQL injection and handle dynamic parameter lists.\n\n## Quick Answer\n\nThe most robust and recommended way to handle `IN` clauses with dynamic parameters in Go, especially for PostgreSQL, is to use the `pq.Array` type with the `ANY` operator or leverage the `sqlx` library's `In` and `Rebind` functions for broader database compatibility.\n\nFor PostgreSQL with `pq.Array`:\n\n```go\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"github.com/lib/pq\" // For pq.Array\n)\n\n// Assume db is an *sql.DB connection\nfunc queryWithPgArray(db *sql.DB, id int, otherFields []string) error {\n\tstmt, err := db.Prepare(\"SELECT * FROM awesome_table WHERE id = $1 AND other_field = ANY($2)\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"prepare statement failed: %w\", err)\n\t}\n\tdefer stmt.Close()\n\n\trows, err := stmt.Query(id, pq.Array(otherFields))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"query failed: %w\", err)\n\t}\n\tdefer rows.Close()\n\n\t// Process rows...\n\tfmt.Println(\"Query successful with pq.Array\")\n\treturn nil\n}\n```\n\nFor general SQL databases using `sqlx`:\n\n```go\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"github.com/jmoiron/sqlx\" // For sqlx.In and sqlx.Rebind\n)\n\n// Assume db is an *sqlx.DB connection\nfunc queryWithSqlxIn(db *sqlx.DB, id int, otherFields []int) error {\n\tquery, args, err := sqlx.In(\"SELECT * FROM awesome_table WHERE id = ? AND other_field IN (?)\", id, otherFields)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"sqlx.In failed: %w\", err)\n\t}\n\n\t// Rebind for PostgreSQL ($1, $2, etc.) or other drivers\n\tquery = db.Rebind(query)\n\n\trows, err := db.Query(query, args...)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"query failed: %w\", err)\n\t}\n\tdefer rows.Close()\n\n\t// Process rows...\n\tfmt.Println(\"Query successful with sqlx.In\")\n\treturn nil\n}\n```\n\n## Choose Your Method\n\nThe best approach depends on your database, whether you're using `sqlx`, and your performance/readability priorities.\n\n```mermaid\ngraph TD\n    A[Start: Need SQL IN clause with dynamic parameters?] --> B{Using PostgreSQL?};\n    B -- Yes --> C{Using `lib/pq` driver?};\n    C -- Yes --> D[Use `pq.Array` with `ANY` operator];\n    C -- No --> E{Using `sqlx`?};\n    E -- Yes --> F[Use `sqlx.In` and `db.Rebind`];\n    E -- No --> G[Dynamically build `IN` clause with `strings.Repeat`];\n    B -- No --> E;\n    G -- Vulnerable to SQL Injection if not careful --> H[Avoid direct string concatenation for parameters];\n    D --> I[End];\n    F --> I;\n    G --> I;\n    H --> I;\n```\n![Decision Tree for SQL IN in Go](/images/8071a74c-1.webp)\n\n## Table of Contents\n1.  Quick Answer\n2.  Choose Your Method\n3.  Method 1: Using `pq.Array` with PostgreSQL's `ANY` Operator\n4.  Method 2: Leveraging `sqlx.In` for Dynamic `IN` Clauses\n5.  Method 3: Dynamically Building the `IN` Clause (Standard `database/sql`)\n6.  Common Problems & Solutions\n7.  Performance Considerations\n8.  Summary\n\n## Method 1: Using `pq.Array` with PostgreSQL's `ANY` Operator\n\nFor PostgreSQL users, the `github.com/lib/pq` driver offers a clean and efficient way to handle `IN` clauses by mapping Go slices directly to PostgreSQL array types. This method is type-safe and prevents SQL injection.\n\nPostgreSQL's `ANY` operator can be used with an array to achieve the same result as an `IN` clause. For example, `other_field = ANY('{this,that}')` is equivalent to `other_field IN ('this', 'that')`.\n\n### Implementation\n\n```go\npackage main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/lib/pq\" // Import the PostgreSQL driver\n\t_ \"github.com/lib/pq\" // Register the driver\n)\n\n// Example usage (assuming you have a PostgreSQL database running)\nfunc main() {\n\t// Replace with your actual PostgreSQL connection string\n\tconnStr := \"user=postgres password=postgres dbname=testdb sslmode=disable\"\n\tdb, err := sql.Open(\"postgres\", connStr)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error opening database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\terr = db.Ping()\n\tif err != nil {\n\t\tlog.Fatalf(\"Error connecting to database: %v\", err)\n\t}\n\tfmt.Println(\"Successfully connected to PostgreSQL!\")\n\n\t// Create a dummy table for demonstration\n\t_, err = db.Exec(`\n\t\tCREATE TABLE IF NOT EXISTS awesome_table (\n\t\t\tid SERIAL PRIMARY KEY,\n\t\t\tother_field TEXT\n\t\t);\n\t\tTRUNCATE TABLE awesome_table;\n\t\tINSERT INTO awesome_table (other_field) VALUES ('apple'), ('banana'), ('cherry'), ('date');\n\t`)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error setting up table: %v\", err)\n\t}\n\n\t// Example 1: Query with string slice\n\tfmt.Println(\"\\n--- Querying with string slice ---\")\n\totherFieldsStr := []string{\"apple\", \"cherry\"}\n\trows, err := queryWithPgArray(db, 1, otherFieldsStr) // id=1 is arbitrary here, adjust as needed\n\tif err != nil {\n\t\tlog.Printf(\"Error querying with string slice: %v\", err)\n\t} else {\n\t\tprintResults(rows)\n\t}\n\n\t// Example 2: Query with integer slice (if other_field was INTEGER)\n\t// For this example, other_field is TEXT, so this would fail or need type casting in SQL\n\t// If other_field was INTEGER, you'd use pq.Array([]int{...})\n}\n\nfunc queryWithPgArray(db *sql.DB, id int, otherFields []string) (*sql.Rows, error) {\n\t// Use $1 for the first parameter (id) and $2 for the array (otherFields)\n\t// The `ANY` operator checks if other_field is equal to any element in the array $2\n\tstmt, err := db.Prepare(\"SELECT id, other_field FROM awesome_table WHERE id > $1 AND other_field = ANY($2)\")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"prepare statement failed: %w\", err)\n\t}\n\tdefer stmt.Close() // Important: defer closing the statement\n\n\t// Pass the Go slice wrapped in pq.Array()\n\trows, err := stmt.Query(0, pq.Array(otherFields)) // Using 0 for id > 0 to get all\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"query failed: %w\", err)\n\t}\n\treturn rows, nil\n}\n\nfunc printResults(rows *sql.Rows) {\n\tdefer rows.Close()\n\tfmt.Println(\"Results:\")\n\tfor rows.Next() {\n\t\tvar id int\n\t\tvar otherField string\n\t\tif err := rows.Scan(&id, &otherField); err != nil {\n\t\t\tlog.Printf(\"Error scanning row: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Printf(\"  ID: %d, Other Field: %s\\n\", id, otherField)\n\t}\n\tif err := rows.Err(); err != nil {\n\t\tlog.Printf(\"Error iterating rows: %v\", err)\n\t}\n}\n```\n\n### Generated SQL\n\nThe `pq.Array` approach effectively translates your Go slice into a PostgreSQL array literal, which is then used with the `ANY` operator.\n\n```sql\nSELECT id, other_field FROM awesome_table WHERE id > 0 AND other_field = ANY('{\"apple\", \"cherry\"}');\n```\n\n## Method 2: Leveraging `sqlx.In` for Dynamic `IN` Clauses\n\nThe `jmoiron/sqlx` library is a popular extension to Go's `database/sql` package, providing convenient features like struct scanning and improved handling of dynamic queries. Its `sqlx.In` function is specifically designed for `IN` clauses with dynamic parameter lists.\n\n`sqlx.In` takes a query string with a single `?` placeholder for the `IN` clause and a slice of values. It expands the `?` into a comma-separated list of `?` placeholders and returns the modified query string and the flattened arguments. For PostgreSQL, you then need to use `db.Rebind` to convert the `?` placeholders to `$1, $2, ...` style.\n\n### Implementation\n\n```go\npackage main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/jmoiron/sqlx\" // Import sqlx\n\t_ \"github.com/lib/pq\"    // Register the PostgreSQL driver\n)\n\n// Assume AwesomeStruct matches your table structure\ntype AwesomeStruct struct {\n\tID         int    `db:\"id\"`\n\tOtherField string `db:\"other_field\"`\n}\n\nfunc main() {\n\t// Replace with your actual PostgreSQL connection string\n\tconnStr := \"user=postgres password=postgres dbname=testdb sslmode=disable\"\n\tdb, err := sqlx.Connect(\"postgres\", connStr) // Use sqlx.Connect\n\tif err != nil {\n\t\tlog.Fatalf(\"Error opening database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\terr = db.Ping()\n\tif err != nil {\n\t\tlog.Fatalf(\"Error connecting to database: %v\", err)\n\t}\n\tfmt.Println(\"Successfully connected to PostgreSQL with sqlx!\")\n\n\t// Create a dummy table for demonstration\n\t_, err = db.Exec(`\n\t\tCREATE TABLE IF NOT EXISTS awesome_table (\n\t\t\tid SERIAL PRIMARY KEY,\n\t\t\tother_field TEXT\n\t\t);\n\t\tTRUNCATE TABLE awesome_table;\n\t\tINSERT INTO awesome_table (other_field) VALUES ('apple'), ('banana'), ('cherry'), ('date');\n\t`)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error setting up table: %v\", err)\n\t}\n\n\t// Example 1: Query with string slice\n\tfmt.Println(\"\\n--- Querying with string slice using sqlx.In ---\")\n\totherFieldsStr := []string{\"apple\", \"cherry\"}\n\tvar resultsStr []AwesomeStruct\n\terr = queryWithSqlxIn(db, 0, otherFieldsStr, &resultsStr) // id > 0 to get all\n\tif err != nil {\n\t\tlog.Printf(\"Error querying with string slice: %v\", err)\n\t} else {\n\t\tfmt.Println(\"Results:\")\n\t\tfor _, res := range resultsStr {\n\t\t\tfmt.Printf(\"  ID: %d, Other Field: %s\\n\", res.ID, res.OtherField)\n\t\t}\n\t}\n\n\t// Example 2: Query with integer slice (if other_field was INTEGER)\n\tfmt.Println(\"\\n--- Querying with integer slice (conceptual, assuming other_field is int) ---\")\n\t// For this example, other_field is TEXT, so this would fail or need type casting in SQL\n\t// If other_field was INTEGER, you'd use []int{...}\n\t// ids := []int{1, 2, 3}\n\t// var resultsInt []AwesomeStruct\n\t// err = queryWithSqlxIn(db, 0, ids, &resultsInt)\n\t// if err != nil {\n\t// \tlog.Printf(\"Error querying with int slice: %v\", err)\n\t// } else {\n\t// \tfmt.Println(\"Results (int):\", resultsInt)\n\t// }\n}\n\nfunc queryWithSqlxIn(db *sqlx.DB, id int, otherFields interface{}, dest interface{}) error {\n\t// The `IN (?)` placeholder will be expanded by sqlx.In\n\t// The first `?` is for `id`, the second `?` is for the `IN` clause\n\tquery, args, err := sqlx.In(\"SELECT id, other_field FROM awesome_table WHERE id > ? AND other_field IN (?)\", id, otherFields)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"sqlx.In failed: %w\", err)\n\t}\n\n\t// Rebind the query for the specific database driver (e.g., PostgreSQL uses $1, $2, ...)\n\tquery = db.Rebind(query)\n\n\t// Use db.Select for multiple rows or db.Get for a single row\n\terr = db.Select(dest, query, args...)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"query failed: %w\", err)\n\t}\n\treturn nil\n}\n```\n\n### Generated SQL\n\n`sqlx.In` transforms the query string and arguments. For `otherFields = []string{\"apple\", \"cherry\"}` and `id = 0`, the query becomes:\n\n```sql\nSELECT id, other_field FROM awesome_table WHERE id > $1 AND other_field IN ($2, $3)\n```\nAnd `args` would be `[0, \"apple\", \"cherry\"]`.\n\n## Method 3: Dynamically Building the `IN` Clause (Standard `database/sql`)\n\nIf you're not using `sqlx` and your database driver doesn't support array types like `lib/pq` does, you can manually construct the `IN` clause. This involves generating the correct number of placeholders (`$1, $2, ...` for PostgreSQL or `?, ?, ...` for MySQL) and then passing the individual elements of your slice as separate arguments to `Query`.\n\nThis method requires careful handling to prevent SQL injection. **Never concatenate user-provided values directly into the SQL string.** Always use parameterized queries.\n\n### Implementation\n\n```go\npackage main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\t\"strings\"\n\n\t_ \"github.com/lib/pq\" // Register the PostgreSQL driver\n)\n\nfunc main() {\n\t// Replace with your actual PostgreSQL connection string\n\tconnStr := \"user=postgres password=postgres dbname=testdb sslmode=disable\"\n\tdb, err := sql.Open(\"postgres\", connStr)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error opening database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\terr = db.Ping()\n\tif err != nil {\n\t\tlog.Fatalf(\"Error connecting to database: %v\", err)\n\t}\n\tfmt.Println(\"Successfully connected to PostgreSQL!\")\n\n\t// Create a dummy table for demonstration\n\t_, err = db.Exec(`\n\t\tCREATE TABLE IF NOT EXISTS awesome_table (\n\t\t\tid SERIAL PRIMARY KEY,\n\t\t\tother_field TEXT\n\t\t);\n\t\tTRUNCATE TABLE awesome_table;\n\t\tINSERT INTO awesome_table (other_field) VALUES ('apple'), ('banana'), ('cherry'), ('date');\n\t`)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error setting up table: %v\", err)\n\t}\n\n\tfmt.Println(\"\\n--- Querying with dynamically built IN clause ---\")\n\totherFields := []string{\"banana\", \"date\"}\n\trows, err := queryDynamically(db, 0, otherFields) // id > 0 to get all\n\tif err != nil {\n\t\tlog.Printf(\"Error querying dynamically: %v\", err)\n\t} else {\n\t\tprintResults(rows)\n\t}\n}\n\nfunc queryDynamically(db *sql.DB, id int, otherFields []string) (*sql.Rows, error) {\n\tif len(otherFields) == 0 {\n\t\treturn nil, fmt.Errorf(\"otherFields slice cannot be empty for IN clause\")\n\t}\n\n\t// Start with the fixed part of the query\n\tbaseQuery := \"SELECT id, other_field FROM awesome_table WHERE id > $1 AND other_field IN (\"\n\n\t// Generate placeholders for the IN clause: $2, $3, ...\n\t// The first placeholder is $2 because $1 is for `id`\n\tplaceholders := make([]string, len(otherFields))\n\tfor i := range otherFields {\n\t\tplaceholders[i] = fmt.Sprintf(\"$%d\", i+2) // Start from $2\n\t}\n\tbaseQuery += strings.Join(placeholders, \", \") + \")\"\n\n\t// Combine all arguments: first `id`, then elements of `otherFields`\n\targs := make([]interface{}, len(otherFields)+1)\n\targs[0] = id // First argument is for $1\n\tfor i, v := range otherFields {\n\t\targs[i+1] = v // Subsequent arguments for $2, $3, ...\n\t}\n\n\tstmt, err := db.Prepare(baseQuery)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"prepare statement failed: %w\", err)\n\t}\n\tdefer stmt.Close()\n\n\trows, err := stmt.Query(args...) // Pass all arguments\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"query failed: %w\", err)\n\t}\n\treturn rows, nil\n}\n\nfunc printResults(rows *sql.Rows) {\n\tdefer rows.Close()\n\tfmt.Println(\"Results:\")\n\tfor rows.Next() {\n\t\tvar id int\n\t\tvar otherField string\n\t\tif err := rows.Scan(&id, &otherField); err != nil {\n\t\t\tlog.Printf(\"Error scanning row: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Printf(\"  ID: %d, Other Field: %s\\n\", id, otherField)\n\t}\n\tif err := rows.Err(); err != nil {\n\t\tlog.Printf(\"Error iterating rows: %v\", err)\n\t}\n}\n```\n\n### Generated SQL\n\nFor `otherFields = []string{\"banana\", \"date\"}` and `id = 0`, the generated query string would be:\n\n```sql\nSELECT id, other_field FROM awesome_table WHERE id > $1 AND other_field IN ($2, $3)\n```\nAnd the arguments passed to `Query` would be `[0, \"banana\", \"date\"]`.\n\n## Common Problems & Solutions\n\n### 1. SQL Injection Risk with String Concatenation\n**Problem:** Directly concatenating user-provided values into the SQL query string (e.g., `query := \"SELECT * FROM users WHERE id IN (\" + strings.Join(ids, \",\") + \")\"`).\n**Solution:** Always use parameterized queries. The methods above (`pq.Array`, `sqlx.In`, or dynamic placeholder generation) all use parameters, which are handled safely by the database driver.\n\n### 2. Empty `IN` Clause List\n**Problem:** If the slice for the `IN` clause is empty, the generated SQL might be `IN ()`, which is often a syntax error or returns no results.\n**Solution:** Add a check for an empty slice and handle it explicitly. You might return an error, return an empty result set, or modify the query to avoid the `IN` clause entirely if it's optional.\n\n```go\nfunc querySafely(db *sql.DB, id int, otherFields []string) (*sql.Rows, error) {\n    if len(otherFields) == 0 {\n        // Handle empty list: e.g., return empty rows or an error\n        return nil, fmt.Errorf(\"cannot query with empty IN clause list\")\n    }\n    // ... proceed with one of the safe methods ...\n    return nil, nil // Placeholder\n}\n```\n\n### 3. Incorrect Placeholder Syntax\n**Problem:** Mixing `?` (MySQL/SQLite) and `$N` (PostgreSQL) placeholders or getting the numbering wrong when dynamically generating them.\n**Solution:**\n*   Be consistent with your database's placeholder style.\n*   When dynamically generating, ensure the numbering starts correctly (e.g., `$1` for the first parameter, `$2` for the second, etc.).\n*   `sqlx.Rebind` helps abstract this for `sqlx` users.\n\n### 4. Performance Overhead of Dynamic Query Generation\n**Problem:** Repeatedly building the query string and preparing statements can incur a slight performance overhead if done in a tight loop.\n**Solution:**\n*   For `pq.Array` and `sqlx.In`, the overhead is minimal as the driver/library handles it efficiently.\n*   For manual dynamic generation, if the `IN` list size varies significantly and queries are frequent, consider caching prepared statements or using a connection pool that handles statement caching. However, for most applications, the overhead is negligible compared to network latency and database processing.\n\n## Performance Considerations\n\n*   **`pq.Array` with `ANY` (PostgreSQL):** This is generally the most performant and idiomatic solution for PostgreSQL. The database is optimized to handle array types efficiently, and the query plan can often be better than a long `IN` list. It also reduces network traffic by sending the array as a single parameter.\n*   **`sqlx.In`:** This method is highly recommended for its balance of safety, readability, and performance across various SQL databases. `sqlx` handles the query string manipulation and argument flattening efficiently. The `Rebind` step is fast.\n*   **Manual Dynamic Generation:** While safe if implemented correctly, it involves string manipulation in Go, which is generally fast. The primary performance consideration here is the database's ability to optimize queries with very long `IN` lists. Some databases might struggle with extremely long `IN` lists (thousands of items), potentially leading to slower query planning or execution. In such cases, consider alternative strategies like temporary tables or batch processing.\n\n## Summary\n\nExecuting SQL `IN` lookups with dynamic parameter lists in Go requires careful handling to ensure both correctness and security.\n\n*   For **PostgreSQL**, the `pq.Array` type combined with the `ANY` operator offers the most direct, type-safe, and often most performant solution.\n*   For a more general approach across different SQL databases, the `sqlx` library's `sqlx.In` and `db.Rebind` functions provide an excellent abstraction, handling placeholder expansion and rebinding automatically.\n*   If you're restricted to the standard `database/sql` package and a driver without array support, you can dynamically construct the `IN` clause by generating the correct number of placeholders and passing individual slice elements as arguments. This method demands strict adherence to parameterized queries to prevent SQL injection.\n\nAlways prioritize parameterized queries over string concatenation to safeguard your application against vulnerabilities.\n\n---\n\n## Image Generation Prompts\n\n**PLACEHOLDER-1:** A decision tree flowchart. The root node is \"Need SQL IN clause with dynamic parameters?\". Branches lead to \"Using PostgreSQL?\". If Yes, then \"Using `lib/pq` driver?\". If Yes, then \"Use `pq.Array` with `ANY` operator\". If No, then \"Using `sqlx`?\". If Yes, then \"Use `sqlx.In` and `db.Rebind`\". If No, then \"Dynamically build `IN` clause with `strings.Repeat`\". If \"Dynamically build `IN` clause\", add a warning branch \"Vulnerable to SQL Injection if not careful\" leading to \"Avoid direct string concatenation for parameters\". All end nodes should lead to \"End\". Use a clean, modern flowchart style with distinct colors for decision nodes and action nodes.",
  "originalFormat": {
    "image_prompts": {
      "prompts": {
        "PLACEHOLDER-1": "A decision tree flowchart. The root node is \"Need SQL IN clause with dynamic parameters?\". Branches lead to \"Using PostgreSQL?\". If Yes, then \"Using `lib/pq` driver?\". If Yes, then \"Use `pq.Array` with `ANY` operator\". If No, then \"Using `sqlx`?\". If Yes, then \"Use `sqlx.In` and `db.Rebind`\". If No, then \"Dynamically build `IN` clause with `strings.Repeat`\". If \"Dynamically build `IN` clause\", add a warning branch \"Vulnerable to SQL Injection if not careful\" leading to \"Avoid direct string concatenation for parameters\". All end nodes should lead to \"End\". Use a clean, modern flowchart style with distinct colors for decision nodes and action nodes."
      },
      "titles": {
        "PLACEHOLDER-1": "Decision Tree for SQL IN in Go"
      },
      "count": 1,
      "placeholder_list": [
        [
          "Decision Tree for SQL IN in Go",
          "1"
        ]
      ]
    },
    "generated_images": [
      {
        "placeholder": "PLACEHOLDER-1",
        "filename": "8071a74c-1.webp",
        "title": "Decision Tree for SQL IN in Go",
        "path": "staging/images/8071a74c-1.png"
      }
    ],
    "source_file": "/Users/thaddeus/Documents/on-going projects/deepv-stackoverflow-workflow-complete/data/crawled_data/20271123.json",
    "workflow_version": "deepv_stackoverflow_v2.0_schema_compliant",
    "generated_at": "2025-09-22T22:53:08.602849",
    "word_count": 2834,
    "code_blocks": 20
  }
}