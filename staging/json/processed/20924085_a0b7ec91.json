{
  "metadata": {
    "title": "Python Coordinate Conversion: Cartesian to Polar and Vice Versa",
    "slug": "python-cartesian-polar-coordinate-conversion",
    "uniqueId": "a0b7ec91",
    "category": "programming-languages",
    "subcategory": "python",
    "description": "Learn how to convert between Cartesian (x, y) and Polar (rho, phi) coordinates in Python using NumPy, cmath, and custom functions.",
    "tags": [
      "python",
      "numpy",
      "cmath",
      "coordinate-systems",
      "polar-coordinates",
      "cartesian-coordinates"
    ],
    "difficulty": "intermediate",
    "readTime": 8,
    "lastUpdated": "2024-09-21T12:30:00.000Z",
    "sourceStackOverflowId": "20924085",
    "votes": 91
  },
  "content": "# Python Coordinate Conversion: Cartesian to Polar and Vice Versa\n\nConverting between Cartesian (x, y) and Polar (rho, phi) coordinate systems is a common task in various scientific and engineering applications. While MATLAB provides built-in functions like `cart2pol`, Python offers several robust ways to achieve this, primarily using the `numpy` and `cmath` libraries, or even custom implementations.\n\n## Quick Answer\n\nThe most straightforward way to convert between Cartesian and Polar coordinates in Python is using `numpy` for numerical arrays or `cmath` for single complex numbers.\n\n**Cartesian to Polar (NumPy):**\n```python\nimport numpy as np\n\ndef cart2pol(x, y):\n    rho = np.hypot(x, y)  # Calculates magnitude (rho)\n    phi = np.arctan2(y, x) # Calculates angle (phi) in radians\n    return rho, phi\n\n# Example\nx_coord, y_coord = 3, 4\nrho, phi = cart2pol(x_coord, y_coord)\nprint(f\"Cartesian ({x_coord}, {y_coord}) -> Polar (rho={rho}, phi={phi} radians)\")\n```\n\n**Polar to Cartesian (NumPy):**\n```python\nimport numpy as np\n\ndef pol2cart(rho, phi):\n    x = rho * np.cos(phi)\n    y = rho * np.sin(phi)\n    return x, y\n\n# Example\nrho_coord, phi_coord = 5, np.arctan2(4, 3) # Using the phi from previous example\nx, y = pol2cart(rho_coord, phi_coord)\nprint(f\"Polar (rho={rho_coord}, phi={phi_coord} radians) -> Cartesian (x={x}, y={y})\")\n```\n\n## Choose Your Method\n\nThe best method depends on your specific needs:\n- **NumPy:** Ideal for vectorized operations on arrays of coordinates, offering good performance.\n- **cmath:** Excellent for single coordinate pairs, especially if you're comfortable with complex numbers, and often faster for scalar operations.\n- **Custom `math` module:** Suitable for basic, non-vectorized conversions without external dependencies.\n- **`hyperspherical` package:** For higher-dimensional conversions beyond 2D.\n\nHere's a decision tree to help you choose:\n\n```mermaid\ngraph TD\n    A[Start] --> B{Need to convert coordinates?};\n    B --> C{Working with arrays/large datasets?};\n    C -- Yes --> D{Need high performance and vectorized operations?};\n    D -- Yes --> E[Use NumPy's `arctan2`, `hypot`, `cos`, `sin`];\n    D -- No --> F{Need to convert higher dimensions (3D+)?};\n    F -- Yes --> G[Consider `hyperspherical` package];\n    F -- No --> E;\n    C -- No --> H{Working with single coordinate pairs?};\n    H -- Yes --> I{Comfortable with complex numbers?};\n    I -- Yes --> J[Use `cmath.polar` and complex number arithmetic];\n    I -- No --> K[Use Python's built-in `math` module (`math.atan2`, `math.hypot`, `math.cos`, `math.sin`)];\n    H -- No --> B;\n```\n\n## Working Code Examples\n\nThis section provides detailed examples for various conversion scenarios.\n\n### 1. Using NumPy for Vectorized Operations\n\nNumPy is the go-to library for numerical operations in Python, especially when dealing with arrays of data.\n\n**Cartesian to Polar:**\n```python\nimport numpy as np\n\ndef cart2pol_numpy(x, y):\n    \"\"\"\n    Converts Cartesian coordinates (x, y) to Polar coordinates (rho, phi).\n    phi is returned in radians.\n    \"\"\"\n    rho = np.hypot(x, y)  # Equivalent to np.sqrt(x**2 + y**2) but more robust\n    phi = np.arctan2(y, x) # Returns angle in radians, handling quadrants correctly\n    return rho, phi\n\n# Single point\nx_single, y_single = 3, 4\nrho_single, phi_single = cart2pol_numpy(x_single, y_single)\nprint(f\"Single point: Cartesian ({x_single}, {y_single}) -> Polar (rho={rho_single:.2f}, phi={phi_single:.2f} rad)\")\n\n# Array of points\nx_arr = np.array([1, -1, 0, 2])\ny_arr = np.array([0, 1, -1, 2])\nrho_arr, phi_arr = cart2pol_numpy(x_arr, y_arr)\nprint(f\"\\nArray points: Cartesian (x={x_arr}, y={y_arr})\")\nprint(f\"              -> Polar (rho={rho_arr}, phi={phi_arr} rad)\")\n```\n\n**Polar to Cartesian:**\n```python\nimport numpy as np\n\ndef pol2cart_numpy(rho, phi):\n    \"\"\"\n    Converts Polar coordinates (rho, phi) to Cartesian coordinates (x, y).\n    phi should be in radians.\n    \"\"\"\n    x = rho * np.cos(phi)\n    y = rho * np.sin(phi)\n    return x, y\n\n# Single point\nrho_single, phi_single = 5, 0.927 # Example values\nx_single, y_single = pol2cart_numpy(rho_single, phi_single)\nprint(f\"Single point: Polar (rho={rho_single:.2f}, phi={phi_single:.2f} rad) -> Cartesian (x={x_single:.2f}, y={y_single:.2f})\")\n\n# Array of points (using output from previous cart2pol_numpy example)\nx_reconverted, y_reconverted = pol2cart_numpy(rho_arr, phi_arr)\nprint(f\"\\nArray points: Polar (rho={rho_arr}, phi={phi_arr} rad)\")\nprint(f\"              -> Cartesian (x={x_reconverted}, y={y_reconverted})\")\n```\n\n### 2. Using `cmath` for Complex Numbers\n\nThe `cmath` module provides functions for complex number mathematics, which naturally maps to polar and Cartesian forms. This is often very concise for single point conversions.\n\n**Cartesian to Polar:**\n```python\nimport cmath\n\ndef cart2pol_cmath(x, y):\n    \"\"\"\n    Converts Cartesian (x, y) to Polar (rho, phi) using cmath.\n    Returns rho (magnitude) and phi (angle in radians).\n    \"\"\"\n    z = complex(x, y)\n    return cmath.polar(z)\n\n# Example\nx_coord, y_coord = 3, 4\nrho, phi = cart2pol_cmath(x_coord, y_coord)\nprint(f\"Cartesian ({x_coord}, {y_coord}) -> Polar (rho={rho:.2f}, phi={phi:.2f} rad) using cmath\")\n```\n\n**Polar to Cartesian:**\n```python\nimport cmath\n\ndef pol2cart_cmath(rho, phi):\n    \"\"\"\n    Converts Polar (rho, phi) to Cartesian (x, y) using cmath.\n    phi should be in radians.\n    \"\"\"\n    z = cmath.rect(rho, phi) # Creates a complex number from polar coordinates\n    return z.real, z.imag\n\n# Example\nrho_coord, phi_coord = 5, 0.927\nx, y = pol2cart_cmath(rho_coord, phi_coord)\nprint(f\"Polar (rho={rho_coord:.2f}, phi={phi_coord:.2f} rad) -> Cartesian (x={x:.2f}, y={y:.2f}) using cmath\")\n```\n\n### 3. Custom Functions with `math` Module\n\nFor basic conversions without `numpy` or `cmath`, Python's built-in `math` module can be used. This is not vectorized.\n\n**Cartesian to Polar:**\n```python\nimport math\n\ndef cart2pol_math(x, y):\n    \"\"\"\n    Converts Cartesian (x, y) to Polar (rho, phi) using math module.\n    phi is returned in radians.\n    \"\"\"\n    rho = math.hypot(x, y)\n    phi = math.atan2(y, x)\n    return rho, phi\n\n# Example\nx_coord, y_coord = 3, 4\nrho, phi = cart2pol_math(x_coord, y_coord)\nprint(f\"Cartesian ({x_coord}, {y_coord}) -> Polar (rho={rho:.2f}, phi={phi:.2f} rad) using math\")\n```\n\n**Polar to Cartesian:**\n```python\nimport math\n\ndef pol2cart_math(rho, phi):\n    \"\"\"\n    Converts Polar (rho, phi) to Cartesian (x, y) using math module.\n    phi should be in radians.\n    \"\"\"\n    x = rho * math.cos(phi)\n    y = rho * math.sin(phi)\n    return x, y\n\n# Example\nrho_coord, phi_coord = 5, 0.927\nx, y = pol2cart_math(rho_coord, phi_coord)\nprint(f\"Polar (rho={rho_coord:.2f}, phi={phi_coord:.2f} rad) -> Cartesian (x={x:.2f}, y={y:.2f}) using math\")\n```\n\n### 4. Handling Degrees vs. Radians\n\nBy default, `numpy` and `math` functions like `arctan2`, `cos`, and `sin` operate in radians. If your input or desired output is in degrees, you'll need to convert.\n\n```python\nimport numpy as np\nimport math\n\n# Cartesian to Polar (output in degrees)\ndef cart2pol_degrees(x, y):\n    rho = np.hypot(x, y)\n    phi_radians = np.arctan2(y, x)\n    phi_degrees = np.degrees(phi_radians) # Convert radians to degrees\n    return rho, phi_degrees\n\nx_val, y_val = -1, 1\nrho_deg, phi_deg = cart2pol_degrees(x_val, y_val)\nprint(f\"Cartesian ({x_val}, {y_val}) -> Polar (rho={rho_deg:.2f}, phi={phi_deg:.2f} degrees)\")\n\n# Polar to Cartesian (input in degrees)\ndef pol2cart_degrees(rho, phi_degrees):\n    phi_radians = np.radians(phi_degrees) # Convert degrees to radians\n    x = rho * np.cos(phi_radians)\n    y = rho * np.sin(phi_radians)\n    return x, y\n\nrho_val, phi_val_deg = 1.41, 135\nx_deg, y_deg = pol2cart_degrees(rho_val, phi_val_deg)\nprint(f\"Polar (rho={rho_val:.2f}, phi={phi_val_deg:.2f} degrees) -> Cartesian (x={x_deg:.2f}, y={y_deg:.2f})\")\n```\n\n### 5. Converting Arrays of (x,y) or (rho,phi) Tuples\n\nIf your coordinates are stored as an array of `[x, y]` or `[rho, phi]` pairs, you can adapt the NumPy functions.\n\n```python\nimport numpy as np\n\ndef cart2pol_array_input(xy_array):\n    \"\"\"\n    Converts an N x 2 array of Cartesian coordinates to Polar.\n    xy_array: NumPy array of shape (N, 2) where each row is [x, y]\n    Returns: NumPy array of shape (N, 2) where each row is [rho, phi]\n    \"\"\"\n    x = xy_array[:, 0]\n    y = xy_array[:, 1]\n    rho = np.hypot(x, y)\n    phi = np.arctan2(y, x)\n    return np.column_stack((rho, phi))\n\ndef pol2cart_array_input(rho_phi_array):\n    \"\"\"\n    Converts an N x 2 array of Polar coordinates to Cartesian.\n    rho_phi_array: NumPy array of shape (N, 2) where each row is [rho, phi]\n    Returns: NumPy array of shape (N, 2) where each row is [x, y]\n    \"\"\"\n    rho = rho_phi_array[:, 0]\n    phi = rho_phi_array[:, 1]\n    x = rho * np.cos(phi)\n    y = rho * np.sin(phi)\n    return np.column_stack((x, y))\n\n# Example usage with arrays\ncartesian_points = np.array([[1, 0], [0, 1], [-1, 0], [0, -1], [3, 4]])\npolar_points = cart2pol_array_input(cartesian_points)\nprint(f\"Cartesian points:\\n{cartesian_points}\")\nprint(f\"Converted to Polar:\\n{polar_points}\")\n\nreconverted_cartesian_points = pol2cart_array_input(polar_points)\nprint(f\"\\nPolar points:\\n{polar_points}\")\nprint(f\"Reconverted to Cartesian:\\n{reconverted_cartesian_points}\")\n```\n\n## Performance Comparison\n\nWhen choosing between `numpy` and `cmath` for scalar operations, `cmath` can sometimes be significantly faster due to its direct implementation for complex numbers. However, for array operations, `numpy`'s vectorized nature makes it superior.\n\nHere's a benchmark demonstrating the difference for single point conversions:\n\n```python\nimport cmath, numpy as np\nimport timeit\n\n# Define functions for comparison\ndef cart2pol_cmath_scalar(x, y):\n    return cmath.polar(complex(x, y))\n\ndef pol2cart_cmath_scalar(rho, phi):\n    z = cmath.rect(rho, phi)\n    return z.real, z.imag\n\ndef cart2pol_numpy_scalar(x, y):\n    return np.hypot(x, y), np.arctan2(y, x)\n\ndef pol2cart_numpy_scalar(rho, phi):\n    return rho * np.cos(phi), rho * np.sin(phi)\n\n# Test data\nxy = (100, 100)\npolar = (141.42, 0.785) # Equivalent to (100, 100) in polar form\n\nprint(\"--- Scalar Performance Comparison ---\")\nprint(f\"cart2pol_cmath_scalar: {timeit.timeit('cart2pol_cmath_scalar(*xy)', globals=globals(), number=1000000):.4f} seconds\")\nprint(f\"pol2cart_cmath_scalar: {timeit.timeit('pol2cart_cmath_scalar(*polar)', globals=globals(), number=1000000):.4f} seconds\")\nprint(f\"cart2pol_numpy_scalar: {timeit.timeit('cart2pol_numpy_scalar(*xy)', globals=globals(), number=1000000):.4f} seconds\")\nprint(f\"pol2cart_numpy_scalar: {timeit.timeit('pol2cart_numpy_scalar(*polar)', globals=globals(), number=1000000):.4f} seconds\")\n\n# For array operations, NumPy is generally much faster\nprint(\"\\n--- Array Performance Comparison (NumPy vs. loop with cmath) ---\")\nnum_points = 10000\nx_arr = np.random.rand(num_points) * 100\ny_arr = np.random.rand(num_points) * 100\n\ndef cart2pol_loop_cmath(x_arr, y_arr):\n    rho_list = []\n    phi_list = []\n    for x, y in zip(x_arr, y_arr):\n        rho, phi = cmath.polar(complex(x, y))\n        rho_list.append(rho)\n        phi_list.append(phi)\n    return np.array(rho_list), np.array(phi_list)\n\nprint(f\"cart2pol_numpy (array): {timeit.timeit('cart2pol_numpy_scalar(x_arr, y_arr)', globals=globals(), number=1000):.4f} seconds\")\nprint(f\"cart2pol_loop_cmath (array): {timeit.timeit('cart2pol_loop_cmath(x_arr, y_arr)', globals=globals(), number=1000):.4f} seconds\")\n```\n![Performance Comparison Chart](/images/a0b7ec91-1.webp)\nThe output typically shows `cmath` being faster for single point conversions, while `numpy` is significantly faster for array operations due to its vectorized nature.\n\n## Common Problems & Solutions\n\n### 1. Angle Units (Radians vs. Degrees)\n- **Problem:** `np.arctan2`, `math.atan2`, `np.cos`, `np.sin`, `math.cos`, `math.sin` all operate in radians by default. If you expect or provide degrees, your results will be incorrect.\n- **Solution:** Explicitly convert between radians and degrees using `np.degrees()` and `np.radians()` (or `math.degrees()` and `math.radians()`).\n    ```python\n    import numpy as np\n\n    # Convert 45 degrees to radians\n    angle_rad = np.radians(45)\n    print(f\"45 degrees in radians: {angle_rad:.2f}\")\n\n    # Convert pi/2 radians to degrees\n    angle_deg = np.degrees(np.pi / 2)\n    print(f\"pi/2 radians in degrees: {angle_deg:.2f}\")\n    ```\n\n### 2. Quadrant Handling for `atan` vs. `atan2`\n- **Problem:** Using `math.atan(y/x)` or `np.arctan(y/x)` will only return angles in the range `(-pi/2, pi/2)` or `(-90, 90)` degrees, which is incorrect for points in the 2nd and 3rd quadrants.\n- **Solution:** Always use `math.atan2(y, x)` or `np.arctan2(y, x)`. These functions take `y` and `x` as separate arguments and correctly determine the angle's quadrant, returning values in the range `(-pi, pi]` or `(-180, 180]` degrees.\n    ```python\n    import numpy as np\n\n    # Point in 2nd quadrant (-1, 1)\n    x, y = -1, 1\n    angle_atan2 = np.arctan2(y, x)\n    print(f\"Angle for ({x}, {y}) using arctan2: {np.degrees(angle_atan2):.2f} degrees\") # Should be 135 degrees\n\n    # Incorrect usage with arctan\n    # angle_atan = np.arctan(y/x) # This would give -45 degrees, which is wrong\n    # print(f\"Angle for ({x}, {y}) using arctan: {np.degrees(angle_atan):.2f} degrees\")\n    ```\n\n### 3. Numerical Precision with `sqrt(x**2 + y**2)` vs. `hypot`\n- **Problem:** For very large or very small `x` and `y` values, `np.sqrt(x**2 + y**2)` can suffer from overflow or underflow before the square root is taken, leading to precision issues or errors.\n- **Solution:** Use `np.hypot(x, y)` (or `math.hypot(x, y)`). This function is specifically designed to compute the Euclidean distance robustly, avoiding intermediate overflow/underflow.\n    ```python\n    import numpy as np\n\n    # Example with large numbers (conceptual, actual overflow depends on float limits)\n    x_large, y_large = 1e200, 1e200\n\n    # Using hypot is safer\n    rho_hypot = np.hypot(x_large, y_large)\n    print(f\"Rho using hypot for large numbers: {rho_hypot}\")\n\n    # Using sqrt(x**2 + y**2) might lead to issues\n    # rho_sqrt = np.sqrt(x_large**2 + y_large**2) # x_large**2 might overflow\n    # print(f\"Rho using sqrt for large numbers: {rho_sqrt}\")\n    ```\n\n## Real-World Use Cases\n\nCoordinate conversions are fundamental in many fields:\n\n*   **Robotics and Navigation:** Converting sensor readings (e.g., from a LiDAR in polar form) to a robot's Cartesian coordinate system for path planning.\n*   **Computer Graphics:** Rotating objects around a point often involves converting to polar, adjusting the angle, and converting back to Cartesian.\n*   **Physics and Engineering:** Analyzing wave phenomena, electrical circuits (phasors), or mechanical systems where rotational motion is involved.\n*   **Data Visualization:** Plotting data that naturally fits a circular pattern (e.g., wind direction and speed) often benefits from polar coordinates.\n*   **Signal Processing:** Representing signals in the frequency domain using complex numbers, where magnitude and phase correspond to polar coordinates.\n\n## Related: Other Coordinate Systems\n\nWhile this article focuses on 2D Cartesian and Polar coordinates, Python also supports conversions for other systems, particularly in 3D:\n\n*   **Spherical Coordinates (3D):** Often represented as (r, theta, phi), where `r` is the radial distance, `theta` is the polar angle (inclination), and `phi` is the azimuthal angle. Libraries like `scipy.spatial.transform` or `astropy` (for astronomical applications) can handle these.\n*   **Cylindrical Coordinates (3D):** An extension of 2D polar coordinates into 3D, typically (rho, phi, z), where `rho` and `phi` are 2D polar coordinates and `z` is the height.\n\nFor example, `astropy` provides `spherical_to_cartesian` and `cartesian_to_spherical` functions:\n```python\n# Example using astropy (requires installation: pip install astropy)\n# import astropy.units as u\n# from astropy.coordinates import spherical_to_cartesian, cartesian_to_spherical\n\n# # Spherical to Cartesian\n# r = 1.0 * u.m\n# lat = 30.0 * u.deg # Latitude (theta)\n# lon = 45.0 * u.deg # Longitude (phi)\n# x, y, z = spherical_to_cartesian(r, lat, lon)\n# print(f\"Spherical (r={r}, lat={lat}, lon={lon}) -> Cartesian (x={x:.2f}, y={y:.2f}, z={z:.2f})\")\n\n# # Cartesian to Spherical\n# x_val, y_val, z_val = 0.5 * u.m, 0.5 * u.m, 0.707 * u.m\n# r_out, lat_out, lon_out = cartesian_to_spherical(x_val, y_val, z_val)\n# print(f\"Cartesian (x={x_val}, y={y_val}, z={z_val}) -> Spherical (r={r_out:.2f}, lat={lat_out:.2f}, lon={lon_out:.2f})\")\n```\n\n## Summary\n\nPython offers flexible and powerful tools for converting between Cartesian and Polar coordinate systems.\n- For **single point conversions**, `cmath` provides a concise and often performant approach by leveraging complex numbers.\n- For **array-based or vectorized operations**, `numpy` is the recommended choice, offering efficiency and robustness with functions like `np.hypot` and `np.arctan2`.\n- Always be mindful of **angle units** (radians vs. degrees) and use `atan2` to correctly handle all quadrants.\n- For 3D or higher-dimensional conversions, specialized libraries like `astropy` or `hyperspherical` can be utilized.\n\n---\n\n## Image Generation Prompts\n\n**PLACEHOLDER-1:** A bar chart comparing the execution times of different Python coordinate conversion methods for scalar operations and array operations. The x-axis should list the methods: \"cmath (scalar)\", \"NumPy (scalar)\", \"NumPy (array)\", \"cmath loop (array)\". The y-axis should be \"Execution Time (seconds, log scale)\". The bars for scalar operations should be significantly shorter than array operations, and within array operations, NumPy should be much shorter than cmath loop. Use distinct colors for each bar. Include a title \"Performance Comparison: Scalar vs. Array Coordinate Conversion\".",
  "originalFormat": {
    "image_prompts": {
      "prompts": {
        "PLACEHOLDER-1": "A bar chart comparing the execution times of different Python coordinate conversion methods for scalar operations and array operations. The x-axis should list the methods: \"cmath (scalar)\", \"NumPy (scalar)\", \"NumPy (array)\", \"cmath loop (array)\". The y-axis should be \"Execution Time (seconds, log scale)\". The bars for scalar operations should be significantly shorter than array operations, and within array operations, NumPy should be much shorter than cmath loop. Use distinct colors for each bar. Include a title \"Performance Comparison: Scalar vs. Array Coordinate Conversion\"."
      },
      "titles": {
        "PLACEHOLDER-1": "Performance Comparison Chart"
      },
      "count": 1,
      "placeholder_list": [
        [
          "Performance Comparison Chart",
          "1"
        ]
      ]
    },
    "generated_images": [
      {
        "placeholder": "PLACEHOLDER-1",
        "filename": "a0b7ec91-1.webp",
        "title": "Performance Comparison Chart",
        "path": "staging/images/a0b7ec91-1.png"
      }
    ],
    "source_file": "/Users/thaddeus/Documents/on-going projects/deepv-stackoverflow-workflow-complete/data/crawled_data/20924085.json",
    "workflow_version": "deepv_stackoverflow_v2.0_schema_compliant",
    "generated_at": "2025-09-22T22:53:37.903290",
    "word_count": 2332,
    "code_blocks": 32
  }
}